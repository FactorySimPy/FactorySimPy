{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Discrete event Simulation for Manufacturing","text":""},{"location":"#overview","title":"Overview","text":"<p>FactorySimPy is a opensource, python library for modeling and Discrete-event simulation of systems seen in manufacturing systems. This library has a canonical set of components that are seen in a typical manufacuting setting like Machines with processing delay or Joints that pack incoming items from different other components, etc. These components' behaviour is pre-built and configurable. User has to provide the model structure and the component parameters to run the simulation model. User can include new features by deriving from the existing classes. This library is built on SimPy 4 and supports as fast as possible and rela time simulation.   Currently, the library supports discrete flows only and is ideal for systems where the structure remains unchanged. We also plan to add support for material flow.</p> <p>System consists of two types of components namely Nodes and Edges and is defined as a graph with nodes which are the active components in the system like machine with a processing delay (or machines that pack or unpack items, etc). and edges that represent objects corresponding to conveyor or fleet of human operators or ware-house robots or transport vehicles that are used for item transfer in the system from one node to another.</p>"},{"location":"#model-description","title":"Model Description","text":"<p>User defines the system as a graph with nodes and edges. Nodes are the components that represents machines with processing delays and edges are the components that used to join two nodes together.</p> <p>A node has a set of in_edges and out_edges. An edge connects exactly two nodes and serves as an in_edge for the dest_node and out_edge for the src_node. Graph can have loops(and self loops).</p>"},{"location":"#example-representation","title":"Example Representation","text":"<p>An example model with 2 nodes and an edge</p>"},{"location":"#component-designimportant-classes","title":"Component Design:Important Classes","text":"<p><code>Node</code> and <code>Edge</code> serves as the base classes. There is another class to represent the items that flow in the system and is named as <code>Item</code> class. <code>Nodes</code> are the active elements in the system and are static and <code>Edge</code> represents the passive elements in the systems and are used to interconnect two nodes.</p> <p>Node has in_edges and out_edges which contains reference to edge objects. Other parameters of Node are id and name. <code>Machine</code> is a class derived from node class to represent all the nodes that have a processing capability. <code>Processor</code>, <code>Split</code>, and <code>Joint</code> are classes that are derived from <code>Machine</code> class. <code>Processor</code> has parameters capacity(int) which is the maximum number of items that can be processed simultaneously in the machine and delay which is the time taken for processing an item. Delay can be a number(integer or real-valued) or a generator function that can be used to generate random variates from a distribution. Other components that are derived from node are <code>Source</code> and <code>Sink</code>. Edge has parameters dest_node, source_node and capacity and has methods can_put, put, can_get and get. <code>Conveyor</code>, <code>Fleet</code> and <code>Buffer</code> are classes that are derived from Edge base class.  In <code>Conveyors</code>, items are moved in sequence from one node to another and the order of the items are preseved. It has parameters capacity(int, maximum number of items it can hold), occupancy(int, number of items currently present on it) and state. State represents the state of the conveyor and takes values stalled, moving or empty.</p> <p><code>Conveyor</code> can support discrete(slotted belt) movement of items and continuous flow of discrete items. </p> <p>In a discrete motion conveyor, the items are moved in fixed steps or stages and will be halted for sometime defined as delayperslot. where as in conitnuous motion conveyor, items move continuously at a defined speed.</p> <p>If an item is present at the other end of the conveyor, then an accumulating conveyor allows other incoming items to be placed in the conveyor and it will get lined up behind the the last item, until the capacity of the conveyor is reached. But, a non-accumulating conveyor will only allow one incoming item at the starting end of the conveyor if an item is already present at the other end of the conveyor.</p> <p><code>Fleets</code> represents the objects that can transport items from a node to another by a fleet of carriers, warehouse robots, human operators, etc. The order of the items is not preserved here. It is characterised by the parameters size of fleet, delay, and state. The size of fleet(int) that the number of carriers, delay represents the time it take to transport the items. Delay can be a number(integer or real-valued) or a generator function that can be used to generate random variates from a distribution. State variable represents the state of every agent. The values it takes are <code>occupied</code> or <code>not-occupied</code>. If the state is occupied, then the fleet will be moving.</p> <p>Here, is an example of a model with 3 nodes that are connected using 2 edges. Nodes are of type source, machine and sink and edges are of type conveyor. </p>"},{"location":"#system-description","title":"System Description","text":""},{"location":"#rules-for-interconnection","title":"Rules for interconnection","text":"<ol> <li>Nodes are static entities like processor, source, sink, split, joints, etc.</li> <li>Edges are directed and connects one node to another. Conveyor, buffer and fleet are the entities that are of type Edge.</li> <li>Items are discrete parts that flow in the system through the directed edges from one node to another. </li> <li>Each Node has two lists <code>in_edges</code> and <code>out_edges</code> that points to the references of the edges that comes in and go out of the node</li> <li>Each Edge stores pointers to a <code>src_node</code> and a <code>dest_node</code>. An Edge can be used only to connect a single node(<code>src_node</code>) to another (or same) node(<code>dest_node</code>).</li> <li>An Edge can have the same node in both <code>src_node</code> and <code>dest_node</code>. (ie, a node can be connected to itself)</li> <li>Nodes are the active elements whose activites initiates state changes in the system.</li> <li>Edges are the passive elements and state change occurs due to actions initiated by nodes</li> <li>To split the output from a <code>processor</code> node into two streams, a <code>Split</code> must be connected to the <code>processor</code> using an Edge.</li> <li>To join two streams and to feed as input to a <code>processor</code> node, a <code>Joint</code> must be connected to the <code>processor</code> using an Edge</li> </ol>"},{"location":"#steps-for-connecting-components","title":"Steps for Connecting Components","text":"<ol> <li>Instantiate nodes and edges:    <pre><code>n1 = Node()\nn2 = Node()\nn3 = Sink()\ne1 = Edge()\n</code></pre></li> <li>Establish connections:    <pre><code>e1.connect(n1, n2)\ne2.connect(n2,n3)\n</code></pre></li> </ol>"},{"location":"#class-hierarchy","title":"Class Hierarchy","text":"<pre><code>\u251c\u2500\u2500 Node(Base Class for components that processes items)\n    \u251c\u2500\u2500 Machine     # Base class for nodes that Processes items \n      \u251c\u2500\u2500 Processor     # Processes items \n      \u251c\u2500\u2500 Joint      # Merges multiple flows into one\n      \u251c\u2500\u2500 Split       # Splits a flow into multiple branches.\n    \u251c\u2500\u2500 Sink        # Consumes items\n    \u251c\u2500\u2500 Source       # generates items\n\n\n\u251c\u2500\u2500 Edge(Base Class for components that transfer items from one node to another)\n    \u251c\u2500\u2500 Conveyor   # transfers items in a sequence from a node to another and order is preserved\n    \u251c\u2500\u2500 Fleet      # Fleet of human operstor, warehouse robots or transport vehicles\n    \u251c\u2500\u2500 Buffer     # Queue of items waiting to be accepted by the next node in a model\n</code></pre>"},{"location":"#behavior-of-components","title":"Behavior of Components","text":""},{"location":"#edge-e","title":"Edge ( E ):","text":"<ul> <li>Purpose: Connects two nodes.  </li> <li>Parameters<ul> <li><code>edge_id</code>: unique id of an edge</li> </ul> </li> </ul>"},{"location":"#derived-classes-from-edge","title":"Derived Classes from Edge","text":"<ol> <li> <p>Conveyor ( E_c ):</p> <ul> <li>FIFO Behavior: Maintains the order of items.</li> <li>Parameters:</li> <li><code>num_slots</code>: Capacity of the conveyor.</li> <li><code>delay_per_slot</code>: Time for an item to move from one slot to the next.</li> <li><code>accumulating</code>: Boolean indicating if items can accumulate at the conveyor's end.</li> <li>Blocking Conveyor: Blocks further additions if the last slot is occupied.</li> <li>Methods:</li> <li><code>can_put()</code>, <code>put()</code>: Add items.</li> <li><code>can_get()</code>, <code>get()</code>: Retrieve items.</li> </ul> </li> <li> <p>Transporter ( E_t ):</p> <ul> <li>Purpose: Handles bursty traffic by operating in parallel.</li> <li>Behavior: Spawns additional instances as required to manage flow surges.</li> </ul> </li> <li> <p>Buffer ( E_b ):</p> <ul> <li>Purpose: Handles bursty traffic by operating in parallel.</li> <li>Behavior: Spawns additional instances as required to manage flow surges.</li> </ul> </li> </ol>"},{"location":"#node-n","title":"Node ( N ):","text":"<ul> <li>Purpose: Active elements in the system.  </li> <li>Parameters<ul> <li><code>node_id</code>: unique id of a node</li> </ul> </li> </ul>"},{"location":"#derived-classes-from-node","title":"Derived Classes from Node","text":"<ol> <li> <p>Source ( N_src ):</p> <ul> <li>Purpose: to mark the start of the model</li> <li>Behavior: Calls <code>can_put</code> on the connected edge. If <code>True</code>, the item is added using <code>put</code>. Otherwise, the item is dropped (non-blocking behavior).</li> <li>Parameters<ul> <li><code>delay</code>: Time between item generations.</li> <li><code>can_put()</code>: Checks edge availability.</li> <li><code>put()</code>: Adds item to the edge.</li> </ul> </li> </ul> </li> <li> <p>Sink ( N_snk ):</p> <ul> <li>Purpose: To mark the end of the model</li> <li>Behavior: Entity to consume items </li> </ul> </li> <li> <p>Machine ( N_m ):</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>work_capacity</code>: Capacity of the machine.</li> <li><code>store_capacity</code>: Capacity of the store.</li> <li><code>delay</code>: Time for processing.</li> <li><code>name</code>: string name of the machine.</li> </ul> </li> <li> <p>Methods:</p> <ul> <li><code>can_put()</code>, <code>put()</code>: Add items.</li> <li><code>can_get()</code>, <code>get()</code>: Retrieve items.</li> </ul> </li> <li> <p>Derived Classes from Machines:</p> <ol> <li> <p>Processor ( N_p ):</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>work_capacity</code>: Capacity of the machine.</li> <li><code>store_capacity</code>: Capacity of the store.</li> <li><code>delay</code>: Time for processing.</li> <li><code>name</code>: string name of the machine.</li> </ul> </li> <li> <p>Methods:</p> <ul> <li><code>can_put()</code>, <code>put()</code>: Add items.</li> <li><code>can_get()</code>, <code>get()</code>: Retrieve items.</li> </ul> </li> </ul> </li> <li> <p>Split ( N_sp ):</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>work_capacity</code>: Capacity of the machine.</li> <li><code>store_capacity</code>: Capacity of the store.</li> <li><code>delay</code>: Time for processing.</li> <li><code>name</code>: string name of the machine.</li> </ul> </li> <li> <p>Methods:</p> <ul> <li><code>can_put()</code>, <code>put()</code>: Add items.</li> <li><code>can_get()</code>, <code>get()</code>: Retrieve items</li> </ul> </li> </ul> </li> <li> <p>Joint ( N_jt ):</p> <ul> <li>Parameters:<ul> <li><code>work_capacity</code>: Capacity of the machine.</li> <li><code>store_capacity</code>: Capacity of the store.</li> <li><code>delay</code>: Time for processing.</li> <li><code>name</code>: string name of the machine.</li> </ul> </li> <li>Methods:<ul> <li><code>can_put()</code>, <code>put()</code>: Add items.</li> <li><code>can_get()</code>, <code>get()</code>: Retrieve items</li> </ul> </li> </ul> </li> </ol> </li> </ul> </li> </ol>"},{"location":"#item-i","title":"Item ( I ):","text":"<ul> <li>Purpose: Items that flow in the system  </li> <li>Parameters<ul> <li><code>item_id</code>: unique id of an item</li> <li><code>delay</code>: inter-arrival time</li> </ul> </li> </ul>"},{"location":"#summary","title":"Summary","text":"<p>By adhering to this framework, FactorySimPy ensures a structured, intuitive simulation environment for modeling discrete item flows in manufacturing systems. The notations and rules defined here aim to provide clarity and minimize ambiguity during model creation.</p>"},{"location":"extendedresources/","title":"Extended resources for FactorySimPy","text":"<p>Welcome to the extended resources documentation for FactorySimPy!</p>"},{"location":"extendedresources/#reservablepriorityreqstore","title":"ReservablePriorityReqStore","text":"<p>The ReservablePriorityReqStore\u00a0is a class derived from SimPy's Store class that addresses a missing capability in the library by allowing both priority-based retrieval and reservation of items(or space) before they are actually retrieved (or put), respecting the capacity of the store. This is particularly useful in manufacturing systems where materials or products must be allocated in advance, ensuring that specific parts are reserved for machines before processing begins. It also allows priority-based retrieval, ensuring that urgent requests are handled first. Additionally, decoupling reservation from yielding a \"get\" request ensures that items remain in storage until they are actually needed, improving coordination in assembly lines and buffer management. Unlike SimPy\u2019s existing resource reservation methods, which manage process-related elements like machines or operators, ReservablePriorityReqStore focuses on item-level management, making it a valuable addition for handling inventory, buffer stocks, and material flows in discrete-event simulations. However, when implementhing SimPy interrupts, the events should be manually cancelled incase of an interruption.</p> <p>The <code>ReservablePriorityReqStore</code> extends SimPy's <code>Store</code> by allowing users to:  </p> <ul> <li> <p>Reserve Capacity: Processes can reserve space (or item) in the store before actual put (or get) in it.  </p> </li> <li> <p>Enforce Reservation Rules: Prohibits any process from adding (or getting) items to the store without a prior reservation.  </p> </li> <li> <p>Priority for requests: Users can pass a priority along with the reservation requests. The requests with the highest priority(lowest first) will be yielded first. Two requests with same priority will be yielded in a FIFO manner.</p> </li> <li> <p>Cancel a reservation: Allows users to cancel a placed/yielded reserve_put (or reserve_get) request.</p> </li> </ul>"},{"location":"extendedresources/#parameters","title":"Parameters","text":"<ul> <li><code>env</code>: The SimPy environment managing the simulation.  </li> <li><code>capacity</code>: Maximum number of items the store can hold (default: infinite).  </li> </ul>"},{"location":"extendedresources/#example-usage","title":"Example Usage","text":"<pre><code>import simpy\nimport random\nfrom ReservablePriorityReqStore import ReservablePriorityReqStore\n\nclass Item:\n    \"\"\"Represents an item to be stored.\"\"\"\n    def __init__(self, name):\n        self.name = name\n\n# Simulation Setup\nenv = simpy.Environment()\nitemstore = ReservablePriorityReqStore(env, capacity=3)\n\ndef producer(env, itemstore, name, priority):\n    \"\"\"Producer process produces items and puts it in the store.\"\"\"\n    yield env.timeout(random.uniform(1, 3))  # Simulate time before producing\n\n    put_reservation = itemstore.reserve_put(priority=priority)\n    yield put_reservation  # Wait for reservation to succeed\n\n    item = Item(f\"{name}\")\n    itemstore.put(put_reservation, item)\n    print(f\"T={env.now:.2f} : {name} added to store with priority {priority}\")\n\ndef consumer(env, itemstore, name, priority, cancel=False):\n    \"\"\"Consumer process picks up items from the store.\"\"\"\n\n    get_reservation = itemstore.reserve_get(priority=priority)\n    print(f\"T={env.now:.2f} : {name} placed a reserve_get request \n             to store with priority {priority}\")\n\n    if cancel and random.choice([True, False]):\n        itemstore.reserve_get_cancel(get_reservation)\n        print(f\"T={env.now:.2f} : {name} CANCELED reservation\")\n        return\n\n    yield get_reservation  # Wait for reservation to succeed\n    print(f\"T={env.now:.2f} : {name} yielded from store with priority {priority}\")\n    yield env.timeout(random.uniform(2, 5))\n    item = itemstore.get(get_reservation)\n    print(f\"T={env.now:.2f} : {name} retrieved {item.name} from store with \n                priority {priority}\")\n\n# Creating producers and consumers\nenv.process(consumer(env, itemstore, \"Consumer1\", priority=3, cancel=True))\nenv.process(consumer(env, itemstore, \"Consumer2\", priority=1))\nenv.process(consumer(env, itemstore, \"Consumer3\", priority=2))\n\n\nenv.process(producer(env, itemstore, \"ItemA\", priority=2))\nenv.process(producer(env, itemstore, \"ItemB\", priority=1))\nenv.process(producer(env, itemstore, \"ItemC\", priority=3))\n\n\nenv.run(until=10)\n</code></pre> <p>Simulation output <pre><code>T=0.00 : Consumer1 placed a reserve_get request to store with priority 3\nT=0.00 : Consumer1 CANCELED reservation\nT=0.00 : Consumer2 placed a reserve_get request to store with priority 1\nT=0.00 : Consumer3 placed a reserve_get request to store with priority 2\nT=2.14 : ItemB added to store with priority 1\nT=2.14 : Consumer2 yielded from store with priority 1\nT=2.23 : ItemA added to store with priority 2\nT=2.23 : Consumer3 yielded from store with priority 2\nT=2.54 : ItemC added to store with priority 3\nT=5.40 : Consumer2 retrieved ItemB from store with priority 1\nT=6.02 : Consumer3 retrieved ItemA from store with priority 2 \n</code></pre></p>"},{"location":"extendedresources/#usecase","title":"Usecase","text":"<pre><code># @title Usecase\nimport simpy\nfrom ReservablePriorityReqStore import ReservablePriorityReqStore\n\n'''\nIn this simulation, two machines (MachineGreen and MachineOrange) produce\nnew items by consuming specific part. MachineGreen,which produces green balls, \nrequests parts (like yellow and blue balls) with a higher priority, while \nMachineOrange, which produces orange balls, requests parts\n(like yellow and red balls) with lower priority. Producers generate red, yellow, \nand blue balls at defined intervals, and consumers retrieve the assembled green \nand orange balls from their respective stores.'''\n\n\n\n# ----- Producer -----\ndef producer(env, interarrival, store, item_prefix):\n    \"\"\"Produces items with a given prefix into a store.\"\"\"\n    i = 0\n    while True:\n        yield env.timeout(interarrival)\n        put_req = store.reserve_put()\n        yield put_req\n        item_name = f\"{item_prefix}{i+1}\"\n        store.put(put_req, item_name)\n        print(f\"T={env.now:.2f}: Producer {item_prefix}: added {item_name})\")\n\n        i += 1\n\n# ----- Consumer -----\ndef consumer(env, interarrival, store, consumer_name):\n    \"\"\"Consumes items from a store.\"\"\"\n    while True:\n        yield env.timeout(interarrival)\n        get_req = store.reserve_get()\n        yield get_req\n        item = store.get(get_req)\n        print(f\"T={env.now:.2f}: Consumer {consumer_name}: got item {item}\")\n\n\n# ----- Machine -----\ndef machine(env, delay, input_stores, input_priorities, \n               output_store, output_prefix):\n    \"\"\"\n    A machine that requests multiple items from input stores \n    (with optional priorities),waits processing time, and outputs a new item.\n\n    Args:\n        input_stores (list): list of stores to get inputs from\n        input_priorities (list): list of priorities (None if no priority)\n        output_store: where to put output\n        output_prefix: name prefix for output items\n    \"\"\"\n    i = 0\n    while True:\n        put_req = output_store.reserve_put()\n        yield put_req\n\n        # Request input items\n        input_requests = []\n        for store, priority in zip(input_stores, input_priorities):\n            if priority is not None:\n                req = store.reserve_get(priority=priority)\n            else:\n                req = store.reserve_get()\n            input_requests.append(req)\n\n        print(f\"T={env.now:.2f}: Machine {output_prefix}: waiting to yield \n                           reserve_get requests\")\n        yield env.all_of(input_requests)\n\n        # Get input items\n        for store, req in zip(input_stores, input_requests):\n            store.get(req)\n\n        print(f\"T={env.now:.2f}: Machine {output_prefix}: got both inputs\")\n        yield env.timeout(delay)\n\n        output_store.put(put_req, f\"{output_prefix}{i}\")\n        print(f\"T={env.now:.2f}: Machine {output_prefix}: finished product is \n                        available in its store\")\n        i += 1\n\n# ----- Simulation Setup -----\ndef run_simulation():\n    env = simpy.Environment()\n\n    # Create Stores\n    redstore = ReservablePriorityReqStore(env, capacity=5)\n    yellowstore = ReservablePriorityReqStore(env, capacity=1)\n    bluestore = ReservablePriorityReqStore(env, capacity=5)\n    orangestore = ReservablePriorityReqStore(env, capacity=1)\n    greenstore = ReservablePriorityReqStore(env, capacity=1)\n\n    # Producer setups\n    producer_params = [\n        (1, redstore, \"red\"),\n        (2, yellowstore, \"yellow\"),\n        (1, bluestore, \"blue\")\n    ]\n\n    # Consumer setups\n    consumer_params = [\n        (1, orangestore, \"orange\"),\n        (1, greenstore, \"green\")\n    ]\n\n    # Machine setups\n    machine_params = [\n       (1, [yellowstore, redstore], [None, None], orangestore, \"orange\"),#Machine1\n       (1, [yellowstore, bluestore], [-2, None], greenstore, \"green\") # Machine2\n    ]\n\n    # Start Producers\n    for interarrival, store, prefix in producer_params:\n        env.process(producer(env, interarrival, store, prefix))\n\n    # Start Consumers\n    for interarrival, store, name in consumer_params:\n        env.process(consumer(env, interarrival, store, name))\n\n    # Start Machines\n    for delay, inputs, priorities, output, prefix in machine_params:\n        env.process(machine(env, delay, inputs, priorities, output, prefix))\n\n    # Run Simulation\n    env.run(until=5)\n\n\n\n# Run it\nrun_simulation()\n</code></pre> <p>Simulation output </p> <pre><code>T=0.00: Machine orange: waiting to yield reserve_get requests\nT=0.00: Machine green: waiting to yield reserve_get requests\nT=1.00: Producer red: added red1 \nT=1.00: Producer blue: added blue1 \nT=2.00: Producer yellow: added yellow1\nT=2.00: Producer red: added red2 \nT=2.00: Producer blue: added blue2\nT=2.00: Machine green: got both inputs\nT=3.00: Machine green: finished product is available in its store\nT=3.00: Producer red: added red3 \nT=3.00: Producer blue: added blue3\nT=3.00: Consumer green: got item green0\nT=3.00: Machine green: waiting to yield reserve_get requests\nT=4.00: Producer yellow: added yellow2 \nT=4.00: Producer red: added red4 \nT=4.00: Producer blue: added blue4 \nT=4.00: Machine green: got both inputs\n</code></pre> <p>Go to API Reference</p>"},{"location":"extendedresources/#priorityreqstore","title":"PriorityReqStore","text":"<p>PriorityReqStore is a resource store with priority handling capabilities. Users can add a priority for each of the get(or put) requests. Request with lower values of priority yields first among all get(or put) requests. If two requests with same priority are placed from two processes then FIFO order is followed to yield the requests.</p> <p>Main Features:</p> <ul> <li>Priority for requests: Manages concurrent requests with different priority values.</li> </ul>"},{"location":"extendedresources/#parameters_1","title":"Parameters","text":"<ul> <li><code>env</code>: The SimPy environment managing the simulation.  </li> <li><code>capacity</code>: Maximum number of items the store can hold (default: infinite).  </li> </ul>"},{"location":"extendedresources/#example-usage_1","title":"Example Usage","text":"<pre><code>import simpy\nfrom PriorityReqStore import PriorityReqStore\n\nclass item:\n  def __init__(self,name):\n    self.name=name\n\ndef source(name,env,delay,priority=0):\n    i=1\n\n    yield env.timeout(delay)\n    item1 = item(name='item'+str(name)+str(i))\n    print(f'T={env.now:.2f}: Source {name} Going to put an item in \n                    store {item1.name} with priority {priority}')\n\n    yield store.put(item1,priority)\n    i+=2\ndef sink(name,env,delay,priority):\n\n    yield env.timeout(delay)\n    print(f'T={env.now:.2f}: Sink {name} placed a get request with \n                     priority {priority} in the store')\n    item = yield store.get(priority)\n    print(f'T={env.now:.2f}: Sink {name} Got an item from store {item.name}')\n\n\n\nenv= simpy.Environment()\nstore= PriorityReqStore(env,2)\n\np1= env.process(sink('OUT-1',env,0,2))\np2= env.process(sink('OUT-2',env,0,1))\np3= env.process(source('IN-A',env,1,2))\np4= env.process(source('IN-B',env,1,1))\n\nenv.run(until=5)\n</code></pre> <p>Simulation output <pre><code>T=0.00: Sink OUT-1 placed a get request with priority 2 in the store\nT=0.00: Sink OUT-2 placed a get request with priority 1 in the store\nT=1.00: Source IN-A Going to put an item in store itemIN-A1 with priority 2\nT=1.00: Source IN-B Going to put an item in store itemIN-B1 with priority 1\nT=1.00: Sink OUT-2 Got an item from store itemIN-A1\nT=1.00: Sink OUT-1 Got an item from store itemIN-B1\n</code></pre></p>"},{"location":"extendedresources/#usecase_1","title":"Usecase","text":"<pre><code>'''\nA university\u2019s Central IT Department supports Admin, Library, Student Labs,\nand Research Labs. Departments request IT systems (computers). Systems are\nallocated based on request priority \u2014 higher-priority departments get\nsystems first.'''\n\n\nimport simpy\nfrom PriorityReqStore import PriorityReqStore  # Importing your PriorityReqStore\n\nclass CentralITDepartment:\n    def __init__(self, env, initial_stock=0):\n        self.env = env\n        self.store = PriorityReqStore(env)\n        self.results = []\n\n        # Pre-load some stock if needed\n        for i in range(initial_stock):\n            self.store.items.append(f\"Preloaded_System_{i+1}\")\n\n    def department_request(self, department_name, priority):\n        \"\"\"Department places a request for a system.\"\"\"\n        print(f\"T={self.env.now:.2f}: {department_name} places a request with \n                                 priority {priority}\")\n        system = yield self.store.get(priority=priority)\n        self.results.append((self.env.now, department_name, system))\n        print(f\"T={self.env.now:.2f}: {department_name} received {system}\")\n\n    def add_systems(self, count, delay=0):\n        \"\"\"IT department adds systems after a delay.\"\"\"\n        yield self.env.timeout(delay)\n        for i in range(count):\n            system_name = f\"System_{i+1}_after_delay\"\n            yield self.store.put(system_name)\n            print(f\"T={self.env.now:.2f}: IT Department added {system_name}\")\n\ndef run_central_it_simulation():\n    env = simpy.Environment()\n    it_department = CentralITDepartment(env)\n\n    # Start departments making requests\n    env.process(it_department.department_request('Admin', priority=3))\n    env.process(it_department.department_request('Library', priority=3))\n    env.process(it_department.department_request('Student Lab', priority=1))\n    env.process(it_department.department_request('Research Lab', priority=2))\n\n    # IT Department will add new systems after 2 time units\n    env.process(it_department.add_systems(count=3, delay=2))\n\n    env.run(until=10)\n\n\nif __name__ == \"__main__\":\n    run_central_it_simulation()\n</code></pre> <p>Simulation output <pre><code>T=0.00: Admin places a request with priority 3\nT=0.00: Library places a request with priority 3\nT=0.00: Student Lab places a request with priority 1\nT=0.00: Research Lab places a request with priority 2\nT=2.00: IT Department added System_1_after_delay\nT=2.00: Student Lab received System_1_after_delay\nT=2.00: IT Department added System_2_after_delay\nT=2.00: Research Lab received System_2_after_delay\nT=2.00: IT Department added System_3_after_delay\nT=2.00: Admin received System_3_after_delay\n</code></pre></p> <p>Go to API Reference</p>"},{"location":"priorityreqstore/","title":"API Reference","text":""},{"location":"priorityreqstore/#priority_req_store","title":"<code>priority_req_store</code>","text":""},{"location":"priorityreqstore/#priority_req_store.SortedQueue","title":"<code>SortedQueue</code>","text":"<p>               Bases: <code>list</code></p> <p>Queue for sorting events by their :attr:<code>~PriorityRequest.key</code> attribute.</p>"},{"location":"priorityreqstore/#priority_req_store.SortedQueue.maxlen","title":"<code>maxlen = maxlen</code>  <code>instance-attribute</code>","text":"<p>Maximum length of the queue.</p>"},{"location":"priorityreqstore/#priority_req_store.SortedQueue.append","title":"<code>append(item)</code>","text":"<p>Sort item into the queue.</p> <p>Raise a :exc:<code>RuntimeError</code> if the queue is full.</p>"},{"location":"priorityreqstore/#priority_req_store.PriorityGet","title":"<code>PriorityGet</code>","text":"<p>               Bases: <code>Get</code></p>"},{"location":"priorityreqstore/#priority_req_store.PriorityGet.priority","title":"<code>priority = priority</code>  <code>instance-attribute</code>","text":"<p>The priority of this request. A smaller number means higher priority.</p>"},{"location":"priorityreqstore/#priority_req_store.PriorityGet.time","title":"<code>time = resource._env.now</code>  <code>instance-attribute</code>","text":"<p>The time at which the request was made.</p>"},{"location":"priorityreqstore/#priority_req_store.PriorityPut","title":"<code>PriorityPut</code>","text":"<p>               Bases: <code>Put</code></p>"},{"location":"priorityreqstore/#priority_req_store.PriorityPut.priority","title":"<code>priority = priority</code>  <code>instance-attribute</code>","text":"<p>The priority of this request. A smaller number means higher priority.</p>"},{"location":"priorityreqstore/#priority_req_store.PriorityPut.time","title":"<code>time = resource._env.now</code>  <code>instance-attribute</code>","text":"<p>The time at which the request was made.</p>"},{"location":"priorityreqstore/#priority_req_store.PriorityReqStore","title":"<code>PriorityReqStore</code>","text":"<p>               Bases: <code>Store</code></p> <p>This is a class derived from SimPy's Store class and has extra capabilities that makes it a priority-based store for put and get.</p> <p>Processes can pass a priority as argument in the put and get request. Request with lower values of priority yields first among all get(or put) requests. If two requests with same  priority are placed from two processes then FIFO order is followed to yield the requests.</p>"},{"location":"priorityreqstore/#priority_req_store.PriorityReqStore.get","title":"<code>get = BoundClass(PriorityGet)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>yields a get request with the given priority.</p>"},{"location":"priorityreqstore/#priority_req_store.PriorityReqStore.put","title":"<code>put = BoundClass(PriorityPut)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>yields a put request with the given priority</p>"},{"location":"reservablepriorityreqstore/","title":"API Reference","text":""},{"location":"reservablepriorityreqstore/#reservable_priority_req_store","title":"<code>reservable_priority_req_store</code>","text":""},{"location":"reservablepriorityreqstore/#reservable_priority_req_store.ReservablePriorityReqStore","title":"<code>ReservablePriorityReqStore</code>","text":"<p>               Bases: <code>Store</code></p> <p>This is a class that is derived from SimPy's Store class and has extra capabilities that makes it a priority-based reservable store for processes to reserve space for storing and retrieving items with priority-based access.</p> <p>Processes can use reserve_put() and reserve_get() methods to get notified when a space becomes available in the store or when an item gets available in the ReservablePriorityReqStore. These methods returns a unique event (SimPy.Event) to the process for every reserve requests it makes. Processes can also pass a priority as argument in the request. Lower values indicate higher priority.</p> <p>get and put are two methods that can be used for item storing and retrieval from ReservablePriorityReqStore. Process has to make a prior reservation and pass the associated reservation event as argument in the get and put requests. ReservablePriorityReqStore maintains separate queues for <code>reserve_put</code> and <code>reserve_get</code> operations to ensures that only processes with valid reservations can store or retrieve items.</p> <p>ReservablePriorityReqStore preserves item order by associating an unreserved item in the store with a reservation event by index when a reserve_get() request is made. As a result, it maintains a list of reserved events to preserve item order.</p> <p>It also allows users to cancel an already placed reserve_get or reserve_put request even if it is yielded. It also handles the dissociation of the event and item done at the time of reservation when an already yielded event is canceled.</p> <p>Attributes:</p> Name Type Description <code>reserved_events</code> <code>list</code> <p>Maintains events corresponding to reserved items to preserve item order by index</p> <code>reserve_put_queue</code> <code>list</code> <p>Queue for managing reserve_put reservations</p> <code>reservations_put</code> <code>list</code> <p>List of successful put reservations</p> <code>reserve_get_queue</code> <code>list</code> <p>Queue for managing reserve_get reservations</p> <code>reservations_get</code> <code>list</code> <p>List of successful get reservations</p>"},{"location":"reservablepriorityreqstore/#reservable_priority_req_store.ReservablePriorityReqStore.reserve_put","title":"<code>reserve_put(priority=0)</code>","text":"<p>Create a reservation request to put an item into the store.</p> <p>This function generates a SimPy event representing a reservation request. The event is assigned attributes such as priority, resource name, and the process making the request. The event is then added to <code>reserve_put_queue</code>, which is maintained in priority order.</p> <p>After adding the event to the queue, <code>_trigger_reserve_put</code> is called to process any pending reservations.</p> <p>Parameters:</p> Name Type Description Default <code>priority</code> <code>int</code> <p>The priority level of the reservation request.                       Lower values indicate higher priority. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>event</code> <code>Event</code> <p>A reservation event that will succeed when space is available.</p>"},{"location":"reservablepriorityreqstore/#reservable_priority_req_store.ReservablePriorityReqStore.reserve_put_cancel","title":"<code>reserve_put_cancel(put_event_to_cancel)</code>","text":"<p>Cancel a previously made <code>reserve_put</code> request.</p> <p>This method allows a process to cancel its reservation for putting an item into the store. If the reservation exists in the <code>reserve_put_queue</code>, it is removed before triggering <code>_trigger_reserve_put</code> to process any pending reservations. If the reservation is already in <code>reservations_put</code>, it is also removed and <code>_trigger_reserve_put</code> is triggered.</p> <p>Parameters:</p> Name Type Description Default <code>put_event_to_cancel</code> <code>Event</code> <p>The reservation event that needs to be canceled.</p> required <p>Returns:</p> Name Type Description <code>proceed</code> <code>bool</code> <p>True if the reservation was successfully canceled.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the specified event does not exist in <code>reserve_put_queue</code>           or <code>reservations_put</code>.</p>"},{"location":"reservablepriorityreqstore/#reservable_priority_req_store.ReservablePriorityReqStore.reserve_get_cancel","title":"<code>reserve_get_cancel(get_event_to_cancel)</code>","text":"<p>Cancel a previously made <code>reserve_get</code> request.</p> <p>This method allows a process to cancel its reservation for retrieving an item from the store. If the reservation exists in the <code>reserve_get_queue</code>, it is removed, and <code>_trigger_reserve_get()</code> is called to process any remaining reservations.</p> <p>If the reservation is already in <code>reservations_get</code>, it is removed, and the corresponding item is repositioned in the store to maintain order. <code>_trigger_reserve_get()</code> is then triggered to handle pending reservations.</p> <p>Parameters:</p> Name Type Description Default <code>get_event_to_cancel</code> <code>Event</code> <p>The reservation event that needs to be canceled.</p> required <p>Returns:</p> Name Type Description <code>proceed</code> <code>bool</code> <p>True if the reservation was successfully canceled.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the specified event does not exist in <code>reserve_get_queue</code>           or <code>reservations_get</code>.</p>"},{"location":"reservablepriorityreqstore/#reservable_priority_req_store.ReservablePriorityReqStore.reserve_get","title":"<code>reserve_get(priority=0)</code>","text":"<p>Create a reservation request to retrieve an item from the store.</p> <p>This method generates a SimPy event representing a request to reserve an item for retrieval (<code>get</code>). The event is assigned attributes such as priority, the resource it belongs to, and the process making the request.</p> <p>The event is then added to <code>reserve_get_queue</code>, which is maintained in priority order, and <code>_trigger_reserve_get()</code> is called to process pending reservations if items are available.</p> <p>Parameters:</p> Name Type Description Default <code>priority</code> <code>int</code> <p>The priority level of the reservation request.                       Lower values indicate higher priority. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>event</code> <code>Event</code> <p>A reservation event that will succeed when an item becomes available.</p>"},{"location":"reservablepriorityreqstore/#reservable_priority_req_store.ReservablePriorityReqStore.get","title":"<code>get(get_event)</code>","text":"<p>Retrieve an item from the store after a successful reservation.</p> <p>This method attempts to retrieve an item associated with a <code>reserve_get</code> event. If the reservation exists, it triggers <code>_trigger_get</code> to retrieve the item. If successful, <code>_trigger_reserve_put</code> is called to process any pending <code>reserve_put</code> requests. If the item retrieval fails, an error message is raised.</p> <p>Parameters:</p> Name Type Description Default <code>get_event</code> <code>Event</code> <p>The reservation event associated with the request.</p> required <p>Returns:</p> Name Type Description <code>item</code> <code>Object</code> <p>The retrieved item if successful, otherwise raises an error</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no reservations are available in the reservations_get</p> <code>RuntimeError</code> <p>If item returned is None</p>"},{"location":"reservablepriorityreqstore/#reservable_priority_req_store.ReservablePriorityReqStore.put","title":"<code>put(put_event, item)</code>","text":"<p>Perform a <code>put</code> operation on the store and trigger any pending <code>reserve_get</code> requests.</p> <p>Ensures that only processes with a valid reservation can put items into the store. If the put operation succeeds, it triggers <code>_trigger_reserve_get</code> to process pending get requests.</p> <p>Parameters:</p> Name Type Description Default <code>put_event</code> <code>Event</code> <p>The event corresponding to the reservation.</p> required <code>item</code> <code>object</code> <p>The item to be added to the store.</p> required <p>Returns:</p> Name Type Description <code>proceed</code> <code>bool</code> <p>True if the put operation succeeded, False otherwise.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no reservations are available in the reservations_put</p> <code>RuntimeError</code> <p>If proceed is False after put operation</p>"}]}