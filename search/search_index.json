{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Discrete event Simulation for Manufacturing \u00b6 FactorySimPy \u00b6 FactorySimPy is an open-source, light-weight Python library for modeling and discrete-event simulation (DES) of manufacturing systems. It provides a well-defined set of canonical components commonly found in a manufacturing setting\u2014such as machines with configurable processing delays, combiners that packs/joins items from multiple inputs, buffers that operate as queues holding items that wait, etc. These components come with pre-built behavior that is easily configurable, enabling users to rapidly construct simulation models. To use the library, users define the structure of the system and specify the parameters for each component. The modular design allows users to extend functionality by subclassing existing components, making the library extensible and reusable. Built on top of SimPy 4, FactorySimPy supports both \"as fast as possible\" and real-time simulation modes. It is currently designed for discrete-item flow systems where the model structure remains fixed during the simulation. Future development plans include extending support to material flows. Model Description \u00b6 The system is modeled as a graph consisting of two types of components: Nodes and Edges. Nodes represent active components that drive state changes\u2014such as machines that introduce delays by performing operations like packing, unpacking, or modifying items. Edges, in contrast, represent passive components such as conveyor belts, human operators, warehouse robots, or transport vehicles that facilitate the movement of items between nodes. Each node maintains two lists: in_edges and out_edges , with references to input and output edges, respectively. An edge connects exactly two nodes and holds reference to its src_node (source node) and dest_node (destination node). The graph supports both loops and self-loops. Edge can be uniquely associated with one source and one destination node or a source node to itself in the case of a self-loop. State transitions in the simulation are triggered solely by the actions of the nodes, ensuring a clear separation between control (Nodes) and transport (Edges) within the model. Class Hierarchy \u00b6 \u251c\u2500\u2500 Node(Base Class for components that processes items) \u251c\u2500\u2500 Machine # Processes items \u251c\u2500\u2500 Combiner # Merges multiple flows into one \u251c\u2500\u2500 Splitter # Splits a flow into multiple branches. \u251c\u2500\u2500 Sink # Consumes items \u251c\u2500\u2500 Source # generates items \u251c\u2500\u2500 Edge(Base Class for components that transfer items from one node to another) \u251c\u2500\u2500 Conveyor #transfers items in a sequence from node to another and order is preserved \u251c\u2500\u2500 Fleet # Fleet of human operator, warehouse robots or transport vehicles \u251c\u2500\u2500 Buffer # Queue of items waiting to be accepted by the next node in a model \u251c\u2500\u2500 BaseFlowItem(Base Class for components that flow through the systen) \u251c\u2500\u2500 Item #Smallest unit of discrete item. It cannot hold other items inside. \u251c\u2500\u2500 Pallet #Entities that can store multiple smaller units of items. Simple Example \u00b6 A simple example simulating a machine that gets an item from a buffer and pushes it to one of its output edges after processing it # System layout # SRC \u2500\u2500> BUF1 \u2500\u2500> MACHINE1 \u2500\u2500> BUF2 \u2500\u2500> SINK import factorysimpy from factorysimpy.nodes.machine import Machine from factorysimpy.edges.buffer import Buffer from factorysimpy.nodes.source import Source from factorysimpy.nodes.sink import Sink env = simpy . Environment () # Initializing nodes SRC = Source ( env , id = \"SRC\" , flow_item_type = \"item\" , inter_arrival_time = 0.8 , blocking = False , out_edge_selection = \"RANDOM\" ) MACHINE1 = Machine ( env , id = \"MACHINE1\" , work_capacity = 4 , processing_delay = 1.1 , blocking = False , in_edge_selection = \"RANDOM\" , out_edge_selection = \"RANDOM\" ) SINK = Sink ( env , id = \"SINK\" ) # Initializing edges BUF1 = Buffer ( env , id = \"BUF1\" , store_capacity = 4 , delay = 0.5 , mode = \"FIFO\" ) BUF2 = Buffer ( env , id = \"BUF2\" , store_capacity = 4 , delay = 0.5 , mode = \"FIFO\" ) # Adding connections BUF1 . connect ( SRC , MACHINE1 ) BUF2 . connect ( MACHINE1 , SINK ) env . run ( until = 10 )","title":"Overview"},{"location":"#discrete-event-simulation-for-manufacturing","text":"","title":"Discrete event Simulation for Manufacturing"},{"location":"#factorysimpy","text":"FactorySimPy is an open-source, light-weight Python library for modeling and discrete-event simulation (DES) of manufacturing systems. It provides a well-defined set of canonical components commonly found in a manufacturing setting\u2014such as machines with configurable processing delays, combiners that packs/joins items from multiple inputs, buffers that operate as queues holding items that wait, etc. These components come with pre-built behavior that is easily configurable, enabling users to rapidly construct simulation models. To use the library, users define the structure of the system and specify the parameters for each component. The modular design allows users to extend functionality by subclassing existing components, making the library extensible and reusable. Built on top of SimPy 4, FactorySimPy supports both \"as fast as possible\" and real-time simulation modes. It is currently designed for discrete-item flow systems where the model structure remains fixed during the simulation. Future development plans include extending support to material flows.","title":"FactorySimPy"},{"location":"#model-description","text":"The system is modeled as a graph consisting of two types of components: Nodes and Edges. Nodes represent active components that drive state changes\u2014such as machines that introduce delays by performing operations like packing, unpacking, or modifying items. Edges, in contrast, represent passive components such as conveyor belts, human operators, warehouse robots, or transport vehicles that facilitate the movement of items between nodes. Each node maintains two lists: in_edges and out_edges , with references to input and output edges, respectively. An edge connects exactly two nodes and holds reference to its src_node (source node) and dest_node (destination node). The graph supports both loops and self-loops. Edge can be uniquely associated with one source and one destination node or a source node to itself in the case of a self-loop. State transitions in the simulation are triggered solely by the actions of the nodes, ensuring a clear separation between control (Nodes) and transport (Edges) within the model.","title":"Model Description"},{"location":"#class-hierarchy","text":"\u251c\u2500\u2500 Node(Base Class for components that processes items) \u251c\u2500\u2500 Machine # Processes items \u251c\u2500\u2500 Combiner # Merges multiple flows into one \u251c\u2500\u2500 Splitter # Splits a flow into multiple branches. \u251c\u2500\u2500 Sink # Consumes items \u251c\u2500\u2500 Source # generates items \u251c\u2500\u2500 Edge(Base Class for components that transfer items from one node to another) \u251c\u2500\u2500 Conveyor #transfers items in a sequence from node to another and order is preserved \u251c\u2500\u2500 Fleet # Fleet of human operator, warehouse robots or transport vehicles \u251c\u2500\u2500 Buffer # Queue of items waiting to be accepted by the next node in a model \u251c\u2500\u2500 BaseFlowItem(Base Class for components that flow through the systen) \u251c\u2500\u2500 Item #Smallest unit of discrete item. It cannot hold other items inside. \u251c\u2500\u2500 Pallet #Entities that can store multiple smaller units of items.","title":"Class Hierarchy"},{"location":"#simple-example","text":"A simple example simulating a machine that gets an item from a buffer and pushes it to one of its output edges after processing it # System layout # SRC \u2500\u2500> BUF1 \u2500\u2500> MACHINE1 \u2500\u2500> BUF2 \u2500\u2500> SINK import factorysimpy from factorysimpy.nodes.machine import Machine from factorysimpy.edges.buffer import Buffer from factorysimpy.nodes.source import Source from factorysimpy.nodes.sink import Sink env = simpy . Environment () # Initializing nodes SRC = Source ( env , id = \"SRC\" , flow_item_type = \"item\" , inter_arrival_time = 0.8 , blocking = False , out_edge_selection = \"RANDOM\" ) MACHINE1 = Machine ( env , id = \"MACHINE1\" , work_capacity = 4 , processing_delay = 1.1 , blocking = False , in_edge_selection = \"RANDOM\" , out_edge_selection = \"RANDOM\" ) SINK = Sink ( env , id = \"SINK\" ) # Initializing edges BUF1 = Buffer ( env , id = \"BUF1\" , store_capacity = 4 , delay = 0.5 , mode = \"FIFO\" ) BUF2 = Buffer ( env , id = \"BUF2\" , store_capacity = 4 , delay = 0.5 , mode = \"FIFO\" ) # Adding connections BUF1 . connect ( SRC , MACHINE1 ) BUF2 . connect ( MACHINE1 , SINK ) env . run ( until = 10 )","title":"Simple Example"},{"location":"RTsimulation/","text":"","title":"Enabling real-time simulation"},{"location":"api_ref_main_page/","text":"API Reference \u00b6 Click on the links below to navigate to its API documentation: Here's a link to the repo Node classes Node (source code) Machine (source code) Source (source code) Splitter (source code) Combiner (source code) Sink (source code) Edge classes Edge Buffer Conveyor Fleet Extended classes from SimPy ReservablePriorityReqStore PriorityReqStore ReservablePriorityReqFilterStore","title":"API Reference"},{"location":"api_ref_main_page/#api-reference","text":"Click on the links below to navigate to its API documentation: Here's a link to the repo Node classes Node (source code) Machine (source code) Source (source code) Splitter (source code) Combiner (source code) Sink (source code) Edge classes Edge Buffer Conveyor Fleet Extended classes from SimPy ReservablePriorityReqStore PriorityReqStore ReservablePriorityReqFilterStore","title":"API Reference"},{"location":"api_ref_main_page_2/","text":"API Reference \u00b6 factorysimpy \u00b6 base \u00b6 belt_store \u00b6 BeltStore ( env , capacity = float ( 'inf' ), speed = 1 , accumulation_mode_indicator = True ) \u00b6 Bases: Store This is a class that is derived from SimPy's Store class and has extra capabilities that makes it a reservable store for processes to reserve space for storing and retrieving items. Processes can use reserve_put() and reserve_get() methods to get notified when a space becomes available in the store or when an item gets available in the ReservableReqStore. These methods returns a unique event (SimPy.Event) to the process for every reserve requests it makes. get and put are two methods that can be used for item storing and retrieval from ReservableReqStore. Process has to make a prior reservation and pass the associated reservation event as argument in the get and put requests. ReservableReqStore maintains separate queues for reserve_put and reserve_get operations to ensures that only processes with valid reservations can store or retrieve items. ReservableReqStore preserves item order by associating an unreserved item in the store with a reservation event by index when a reserve_get() request is made. As a result, it maintains a list of reserved events to preserve item order. It also allows users to cancel an already placed reserve_get or reserve_put request even if it is yielded. It also handles the dissociation of the event and item done at the time of reservation when an already yielded event is canceled. When an item is added into the BeltStore using put(), it is associated with a delay representing the time it takes for the item to move through the belt. The item is not immediately available for retrieval after being put into the store. Instead, it becomes available only after the specified delay has elapsed, simulating the movement of items on a conveyor belt. Attributes: reserved_events ( list ) \u2013 Maintains events corresponding to reserved items to preserve item order by index reserve_put_queue ( list ) \u2013 Queue for managing reserve_put reservations reservations_put ( list ) \u2013 List of successful put reservations reserve_get_queue ( list ) \u2013 Queue for managing reserve_get reservations reservations_get ( list ) \u2013 List of successful get reservations Initializes a reservable store with reservations. Args: capacity (int, optional): The maximum number of items the store can hold. Defaults to infinity. mode (str, optional): The mode of the store ('FIFO' or 'LIFO'). Defaults to 'FIFO'. speed (float, optional): The speed of the conveyor belt. Defaults to 1. accumulation_mode_indicator (bool, optional): Indicates if the belt is in accumulation mode. Defaults to True. capacity (int, optional): The maximum number of items the store can hold. Defaults to infinity. Source code in src/factorysimpy/base/belt_store.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 def __init__ ( self , env , capacity = float ( 'inf' ), speed = 1 , accumulation_mode_indicator = True ): \"\"\" Initializes a reservable store with reservations. Args: capacity (int, optional): The maximum number of items the store can hold. Defaults to infinity. mode (str, optional): The mode of the store ('FIFO' or 'LIFO'). Defaults to 'FIFO'. speed (float, optional): The speed of the conveyor belt. Defaults to 1. accumulation_mode_indicator (bool, optional): Indicates if the belt is in accumulation mode. Defaults to True. capacity (int, optional): The maximum number of items the store can hold. Defaults to infinity. \"\"\" super () . __init__ ( env , capacity ) self . env = env self . speed = speed # Speed of the conveyor belt (units per time) self . reserve_put_queue = [] # Queue for managing reserve_put reservations self . reservations_put = [] # List of successful put reservations self . reserve_get_queue = [] # Queue for managing reserve_get reservations self . reservations_get = [] # List of successful get reservations self . reserved_events = [] # Maintains events corresponding to reserved items to preserve item order self . ready_items = [] #Maintains the items ready to be taken out self . reserved_items = [] # parallel list of the exact items reserved self . _last_level_change_time = self . env . now self . _last_num_items = 0 self . _weighted_sum = 0.0 self . time_averaged_num_of_items_in_store = 0.0 # Time-averaged number of items in the store # Process tracking for interrupt functionality self . active_move_processes = {} # Dictionary to track active move_to_ready_items processes self . active_delayed_interrupt_processes = {} # Dictionary to track active delayed interrupt processes self . resume_event = self . env . event () # Event to signal when to resume processes self . noaccumulation_mode_on = False # to control if the belt is in noaccumulation mode self . accumulation_mode_indicator = accumulation_mode_indicator # to indicate if the belt is in accumulation mode or not self . one_item_inserted = False # to control insertion of only one item in noaccumulation mode self . ready_item_event = self . env . event () get ( get_event ) \u00b6 Retrieve an item from the store after a successful reservation. This method attempts to retrieve an item associated with a reserve_get event. If the reservation exists, it triggers _trigger_get to retrieve the item. If successful, _trigger_reserve_put is called to process any pending reserve_put requests. If the item retrieval fails, an error message is raised. Parameters: get_event ( Event ) \u2013 The reservation event associated with the request. Returns: item ( Object ) \u2013 The retrieved item if successful, otherwise raises an error Raises: RuntimeError \u2013 If no reservations are available in the reservations_get RuntimeError \u2013 If item returned is None Source code in src/factorysimpy/base/belt_store.py 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 def get ( self , get_event ): \"\"\" Retrieve an item from the store after a successful reservation. This method attempts to retrieve an item associated with a `reserve_get` event. If the reservation exists, it triggers `_trigger_get` to retrieve the item. If successful, `_trigger_reserve_put` is called to process any pending `reserve_put` requests. If the item retrieval fails, an error message is raised. Args: get_event (simpy.Event): The reservation event associated with the request. Returns: item (Object): The retrieved item if successful, otherwise raises an error Raises: RuntimeError: If no reservations are available in the reservations_get RuntimeError: If item returned is None \"\"\" item = None #if there are reservations, then call _trigger_get if self . reservations_get : item = self . _trigger_get ( get_event ) #else raise an error else : raise RuntimeError ( \"No matching reservation found for process: reservations_get is empty\" ) #if an item is returned then call _trigger_reserve_put to process pending requests if item is not None : self . _trigger_reserve_put ( None ) if item is None : raise RuntimeError ( f \"No item found in the store for { get_event . requesting_process } and get request failed\" ) else : #self._update_time_averaged_level() return item handle_new_item_during_interruption ( item ) \u00b6 Handle new item added during STALLED_ACCUMULATING_STATE with accumulation=1. Computes delay using same logic as for existing items. Source code in src/factorysimpy/base/belt_store.py 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 def handle_new_item_during_interruption ( self , item ): \"\"\" Handle new item added during STALLED_ACCUMULATING_STATE with accumulation=1. Computes delay using same logic as for existing items. \"\"\" # Build the updated belt pattern with new item current_pattern = self . _get_belt_pattern () print ( f \"T= { self . env . now : .2f } Current belt pattern after adding new item: { current_pattern [ 0 ] } and items { current_pattern [ 1 ] } \" ) updated_pattern = list ( current_pattern [ 0 ]) # Recompute item positions item_positions = [ i for i , c in enumerate ( updated_pattern ) if c == '*' ] print ( \"item_positions with new item\" , item_positions ) # Get interruption plan interruption_plan = self . _calculate_gap_based_interruptions ( '' . join ( updated_pattern ), item_positions , current_pattern [ 1 ]) print ( f \"T= { self . env . now : .2f } Interruption plan with new item: { interruption_plan } \" ) # The new item is the last one added in pattern delay_for_new_item = interruption_plan [ 0 ][ 'delay' ] item_id = item [ 0 ] . id if hasattr ( item [ 0 ], 'id' ) else str ( id ( item )) item_id = item [ 0 ] . id if hasattr ( item [ 0 ], 'id' ) else str ( id ( item )) item_length = item [ 0 ] . length if hasattr ( item [ 0 ], 'length' ) else 1.0 delay_for_new_item = delay_for_new_item * ( item_length / self . speed ) if delay_for_new_item > 0 : print ( f \"T= { self . env . now : .2f } New item { item_id } will be interrupted after { delay_for_new_item } time units\" ) interrupt_process = self . env . process ( self . _delayed_interrupt ( item_id , delay_for_new_item , \"New item during interruption\" )) item_id = item [ 0 ] . id if hasattr ( item [ 0 ], 'id' ) else str ( id ( item )) self . active_delayed_interrupt_processes [ item_id ] = interrupt_process else : print ( f \"T= { self . env . now : .2f } New item { item_id } { interruption_plan [ 0 ][ 'item_index' ] } { interruption_plan [ - 1 ][ 'delay' ] } interrupted immediately\" ) self . _interrupt_specific_item ( item_id , \"New item during interruption\" ) interrupt_all_move_processes ( reason = 'External interrupt' ) \u00b6 Interrupt all active move_to_ready_items processes. Parameters: reason ( str , default: 'External interrupt' ) \u2013 Reason for the interrupt Source code in src/factorysimpy/base/belt_store.py 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 def interrupt_all_move_processes ( self , reason = \"External interrupt\" ): \"\"\" Interrupt all active move_to_ready_items processes. Args: reason (str): Reason for the interrupt \"\"\" print ( f \"T= { self . env . now : .2f } Belt_Store interrupting { len ( self . active_move_processes ) } move processes - { reason } \" ) for item_id , process_info in self . active_move_processes . items (): process = process_info [ 'process' ] if process and not process . processed : try : process . interrupt ( reason ) print ( f \"T= { self . env . now : .2f } Interrupted move process for item { item_id } \" ) except RuntimeError : # Process might already be finished pass interrupt_and_resume_all_delayed_interrupt_processes ( reason = 'State change interrupt' ) \u00b6 Interrupt all active delayed interrupt processes and clear them. Parameters: reason ( str , default: 'State change interrupt' ) \u2013 Reason for the interrupt Source code in src/factorysimpy/base/belt_store.py 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 def interrupt_and_resume_all_delayed_interrupt_processes ( self , reason = \"State change interrupt\" ): \"\"\" Interrupt all active delayed interrupt processes and clear them. Args: reason (str): Reason for the interrupt \"\"\" print ( f \"T= { self . env . now : .2f } Belt_Store interrupting { len ( self . active_delayed_interrupt_processes ) } delayed interrupt processes - { reason } \" ) for item_id , process in list ( self . active_delayed_interrupt_processes . items ()): if process and not process . processed : try : process . interrupt ( reason ) print ( f \"T= { self . env . now : .2f } Interrupted delayed interrupt process for item { item_id } \" ) except RuntimeError : # Process might already be finished pass # Remove from tracking regardless self . active_delayed_interrupt_processes . pop ( item_id , None ) move_to_ready_items ( item ) \u00b6 Move items from the store to the ready_items list after a put operation. This method is called as a process to ensure that items are moved asynchronously. Handles interrupts when state changes to stalled and resumes when state changes back. Movement is split into two phases: 1. First phase: item[0].length/self.speed time (time for item to fully enter belt) 2. Second phase: remaining time (time for item to reach exit) Source code in src/factorysimpy/base/belt_store.py 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 def move_to_ready_items ( self , item ): \"\"\" Move items from the store to the ready_items list after a put operation. This method is called as a process to ensure that items are moved asynchronously. Handles interrupts when state changes to stalled and resumes when state changes back. Movement is split into two phases: 1. First phase: item[0].length/self.speed time (time for item to fully enter belt) 2. Second phase: remaining time (time for item to reach exit) \"\"\" item_id = item [ 0 ] . id if hasattr ( item [ 0 ], 'id' ) else str ( id ( item )) event = self . env . event () total_interruption_time = 0 #self.delay=item[0].length/self.speed #print(f\"created Added event suceeded{self.delay}\") event . callbacks . append ( self . _trigger_reserve_put ) # after putting an item, an event is created and will be triggered ater delay amount of time to allow waiting get calls to succeed in a stalled belt #event.callbacks.append(self._trigger_put)# this may not be needed #print(f\"{self.env.now}Added event suceed ed\") # Calculate the two phases of movement phase1_time = item [ 0 ] . length / self . speed # Time for item to fully enter belt phase2_time = item [ 1 ] - phase1_time # Remaining time to reach exit item [ 0 ] . total_interruption_time = total_interruption_time item [ 0 ] . interruption_start_time = None try : # Move items to the ready_items list if self . items : print ( f \"T= { self . env . now : .2f } beltstore received an item { item [ 0 ] . id , item [ 1 ] } . Item started moving in belt\" ) # Phase 1: Item entering the belt (length/speed time) remaining_phase1_time = phase1_time print ( f \"T= { self . env . now : .2f } Item { item_id } starting Phase 1 (entering belt): { phase1_time : .2f } time\" ) while remaining_phase1_time > 0 : try : start_time = self . env . now yield self . env . timeout ( remaining_phase1_time ) # If we reach here, phase 1 completed without interruption event . succeed () remaining_phase1_time = 0 break except simpy . Interrupt as interrupt : # Calculate how much time has passed interruption_start_time_phase1 = self . env . now item [ 0 ] . interruption_start_time = interruption_start_time_phase1 print ( f \" { self . env . now } for item { item_id } Phase 1 started interruption at { interruption_start_time_phase1 } \" ) elapsed_time = self . env . now - start_time remaining_phase1_time -= elapsed_time print ( f \"T= { self . env . now : .2f } Move process Phase 1 for item { item_id } interrupted: { interrupt . cause } \" ) print ( f \"T= { self . env . now : .2f } Remaining Phase 1 time for item { item_id } : { remaining_phase1_time : .2f } \" ) # Wait for resume signal print ( f \"T= { self . env . now : .2f } Item { item_id } waiting for resume signal with { remaining_phase1_time : .2f } time left to complete(Phase 1)...\" ) yield self . resume_event total_interruption_time += self . env . now - interruption_start_time_phase1 item [ 0 ] . interruption_start_time = None item [ 0 ] . total_interruption_time = total_interruption_time print ( f \"T= { self . env . now : .2f } Item { item_id } resuming Phase 1 movement with { remaining_phase1_time : .2f } time remaining\" ) print ( f \"T= { self . env . now : .2f } Item { item_id } completed Phase 1 (fully entered belt)\" ) # Phase 2: Item moving through the belt to exit remaining_phase2_time = phase2_time print ( f \"T= { self . env . now : .2f } Item { item_id } starting Phase 2 (moving to exit): { phase2_time : .2f } time\" ) while remaining_phase2_time > 0 : try : start_time = self . env . now yield self . env . timeout ( remaining_phase2_time ) # If we reach here, phase 2 completed without interruption remaining_phase2_time = 0 break except simpy . Interrupt as interrupt : # Calculate how much time has passed interruption_start_time_phase2 = self . env . now item [ 0 ] . interruption_start_time = interruption_start_time_phase2 print ( f \" { self . env . now } for item { item_id } Phase 2 started interruption at { interruption_start_time_phase2 } \" ) elapsed_time = self . env . now - start_time remaining_phase2_time -= elapsed_time print ( f \"T= { self . env . now : .2f } Move process Phase 2 for item { item_id } interrupted: { interrupt . cause } \" ) print ( f \"T= { self . env . now : .2f } Remaining Phase 2 time for item { item_id } : { remaining_phase2_time : .2f } \" ) # Wait for resume signal print ( f \"T= { self . env . now : .2f } Item { item_id } waiting for resume signal (Phase 2) time left- { remaining_phase2_time : .2f } ...\" ) yield self . resume_event item [ 0 ] . interruption_start_time = None total_interruption_time += self . env . now - interruption_start_time_phase2 item [ 0 ] . total_interruption_time = total_interruption_time print ( f \"T= { self . env . now : .2f } Item { item_id } resuming Phase 2 movement with { remaining_phase2_time : .2f } time remaining\" ) print ( f \"T= { self . env . now : .2f } Item { item_id } completed Phase 2 (reached exit)\" ) #print(f\"T={self.env.now:.2f} bufferstore finished moving item {item[0].id, item[1]} going to ready_items\") item_index = self . items . index ( item ) item_to_put = self . items . pop ( item_index ) # Remove the item if len ( self . ready_items ) + len ( self . items ) < self . capacity : self . ready_items . append ( item_to_put [ 0 ]) item_to_put [ 0 ] . conveyor_ready_item_entry_time = self . env . now print ( \"Total items on belt\" , len ( self . ready_items ) + len ( self . items )) if not self . ready_item_event . triggered : self . ready_item_event . succeed () print ( f \"T= { self . env . now : .2f } bufferstore finished moving item { item [ 0 ] . id , item [ 1 ] } moved to ready_items\" ) self . _trigger_reserve_get ( None ) self . _trigger_reserve_put ( None ) else : raise RuntimeError ( \"Total number of items in the store exceeds capacity. Cannot move item to ready_items.\" ) except simpy . Interrupt as interrupt : # Handle any uncaught interrupts print ( f \"T= { self . env . now : .2f } Item { item_id } move process was interrupted: { interrupt . cause } \" ) finally : # Clean up the process tracking when done if item_id in self . active_move_processes : del self . active_move_processes [ item_id ] print ( f \"T= { self . env . now : .2f } Removed tracking for completed move process of item { item_id } \" ) put ( put_event , item ) \u00b6 Perform a put operation on the store and trigger any pending reserve_get requests. Ensures that only processes with a valid reservation can put items into the store. If the put operation succeeds, it triggers _trigger_reserve_get to process pending get requests. Parameters: put_event ( Event ) \u2013 The event corresponding to the reservation. item ( object ) \u2013 The item to be added to the store. Returns: proceed ( bool ) \u2013 True if the put operation succeeded, False otherwise. Raises: RuntimeError \u2013 If no reservations are available in the reservations_put RuntimeError \u2013 If proceed is False after put operation Source code in src/factorysimpy/base/belt_store.py 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 def put ( self , put_event , item ): \"\"\" Perform a `put` operation on the store and trigger any pending `reserve_get` requests. Ensures that only processes with a valid reservation can put items into the store. If the put operation succeeds, it triggers `_trigger_reserve_get` to process pending get requests. Args: put_event (simpy.Event): The event corresponding to the reservation. item (object): The item to be added to the store. Returns: proceed (bool): True if the put operation succeeded, False otherwise. Raises: RuntimeError: If no reservations are available in the reservations_put RuntimeError: If proceed is False after put operation \"\"\" proceed = False if self . reservations_put : proceed = self . _trigger_put ( put_event , item ) else : raise RuntimeError ( \"No matching reservation found for process: reservations_put is empty\" ) if proceed : #print(f\"{self.env.now} proceed\") #self._trigger_get(None) self . _trigger_reserve_get ( None ) if not proceed : raise RuntimeError ( f \"No matching put_event found in the reservations and put failed for { item } \" ) else : #self._update_time_averaged_level() return proceed reserve_get () \u00b6 Create a reservation request to retrieve an item from the store. This method generates a SimPy event representing a request to reserve an item for retrieval ( get ). The event is assigned attributes such as the resource it belongs to, and the process making the request. The event is then added to reserve_get_queue , which is maintained in the order in which the requests are made, and _trigger_reserve_get() is called to process pending reservations if items are available. Returns: event ( Event ) \u2013 A reservation event that will succeed when an item becomes available. Source code in src/factorysimpy/base/belt_store.py 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 def reserve_get ( self ): \"\"\" Create a reservation request to retrieve an item from the store. This method generates a SimPy event representing a request to reserve an item for retrieval (`get`). The event is assigned attributes such as the resource it belongs to, and the process making the request. The event is then added to `reserve_get_queue`, which is maintained in the order in which the requests are made, and `_trigger_reserve_get()` is called to process pending reservations if items are available. Returns: event (simpy.Event): A reservation event that will succeed when an item becomes available. \"\"\" #adding attributes to the newly created event for reserve_get event = self . env . event () event . resourcename = self event . requesting_process = self . env . active_process # Associate event with the current process self . reserve_get_queue . append ( event ) self . _trigger_reserve_get ( event ) return event reserve_get_cancel ( get_event_to_cancel ) \u00b6 Cancel a previously made reserve_get request. Source code in src/factorysimpy/base/belt_store.py 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 def reserve_get_cancel ( self , get_event_to_cancel ): \"\"\" Cancel a previously made `reserve_get` request. \"\"\" # Case 1: still waiting if get_event_to_cancel in self . reserve_get_queue : self . reserve_get_queue . remove ( get_event_to_cancel ) self . _trigger_reserve_get ( None ) return True # Case 2: already yielded reservation if get_event_to_cancel in self . reservations_get : # 1) Remove from active reservations self . reservations_get . remove ( get_event_to_cancel ) # 2) Find its index in the parallel lists ev_idx = self . reserved_events . index ( get_event_to_cancel ) # 3) Pop out the exact item reference item = self . reserved_items . pop ( ev_idx ) # 4) Drop the event token self . reserved_events . pop ( ev_idx ) # 5) Remove it from ready_items wherever it currently is try : self . ready_items . remove ( item ) except ValueError : raise RuntimeError ( f \"Item { item !r} not found in ready_items during cancel.\" ) # 6) Compute new insertion index insert_idx = len ( self . ready_items ) - len ( self . reserved_events ) - 1 # 7) Re\u2011insert it self . ready_items . insert ( insert_idx , item ) # 8) Trigger any other pending reservations self . _trigger_reserve_get ( None ) return True # No such reservation raise RuntimeError ( \"No matching event in reserve_get_queue or reservations_get\" ) reserve_put () \u00b6 Create a reservation request to put an item into the store. This function generates a SimPy event representing a reservation request. The event is assigned attributes such as resource name, and the process making the request. The event is then added to reserve_put_queue , which is maintained in the order in which the request is made. After adding the event to the queue, _trigger_reserve_put is called to process any pending reservations. Returns: event ( Event ) \u2013 A reservation event that will succeed when space is available. Source code in src/factorysimpy/base/belt_store.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def reserve_put ( self ): \"\"\" Create a reservation request to put an item into the store. This function generates a SimPy event representing a reservation request. The event is assigned attributes such as resource name, and the process making the request. The event is then added to `reserve_put_queue`, which is maintained in the order in which the request is made. After adding the event to the queue, `_trigger_reserve_put` is called to process any pending reservations. Returns: event (simpy.Event): A reservation event that will succeed when space is available. \"\"\" event = self . env . event () event . resourcename = self # Store reference event . requesting_process = self . env . active_process # Process making the reservation self . reserve_put_queue . append ( event ) # Attempt to process reservations self . _trigger_reserve_put ( event ) return event reserve_put_cancel ( put_event_to_cancel ) \u00b6 Cancel a previously made reserve_put request. This method allows a process to cancel its reservation for putting an item into the store. If the reservation exists in the reserve_put_queue , it is removed before triggering _trigger_reserve_put to process any pending reservations. If the reservation is already in reservations_put , it is also removed and _trigger_reserve_put is triggered. Parameters: put_event_to_cancel ( Event ) \u2013 The reservation event that needs to be canceled. Returns: proceed ( bool ) \u2013 True if the reservation was successfully canceled. Raises: RuntimeError \u2013 If the specified event does not exist in reserve_put_queue or reservations_put . Source code in src/factorysimpy/base/belt_store.py 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 def reserve_put_cancel ( self , put_event_to_cancel ): \"\"\" Cancel a previously made `reserve_put` request. This method allows a process to cancel its reservation for putting an item into the store. If the reservation exists in the `reserve_put_queue`, it is removed before triggering `_trigger_reserve_put` to process any pending reservations. If the reservation is already in `reservations_put`, it is also removed and `_trigger_reserve_put` is triggered. Args: put_event_to_cancel (simpy.Event): The reservation event that needs to be canceled. Returns: proceed (bool): True if the reservation was successfully canceled. Raises: RuntimeError: If the specified event does not exist in `reserve_put_queue` or `reservations_put`. \"\"\" #checking and removing the event if it is not yielded and is present in the reserve_put_queue proceed = False if put_event_to_cancel in self . reserve_put_queue : self . reserve_put_queue . remove ( put_event_to_cancel ) self . _trigger_reserve_put ( None ) #if t is removed, then a waiting event can be succeeded, if any proceed = True #checking and removing the event if it is already yielded and is present in the reservations_put elif put_event_to_cancel in self . reservations_put : self . reservations_put . remove ( put_event_to_cancel ) self . _trigger_reserve_put ( None ) #if t is removed, then a waiting event can be succeeded, if any proceed = True else : raise RuntimeError ( \"No matching event in reserve_put_queue or reservations_put for this process\" ) return proceed resume_all_move_processes () \u00b6 Resume all interrupted move_to_ready_items processes. Source code in src/factorysimpy/base/belt_store.py 774 775 776 777 778 779 780 781 782 783 def resume_all_move_processes ( self ): \"\"\" Resume all interrupted move_to_ready_items processes. \"\"\" print ( f \"T= { self . env . now : .2f } Belt_Store resuming move processes\" ) # Create a new resume event and trigger it old_resume_event = self . resume_event self . resume_event = self . env . event () old_resume_event . succeed () selective_interrupt ( reason = 'Selective interrupt' ) \u00b6 Perform selective interruption based on belt occupancy patterns and mode. When noaccumulation_mode_on=True (STALLED_NONACCUMULATING_STATE): - Interrupt all items immediately When noaccumulation_mode_on=False (STALLED_ACCUMULATING_STATE): - Use pattern-based interruption with delays based on item positions Pattern-based rules for accumulating mode: - For patterns like '_ *', interrupt all items. - For patterns like '_ _ _', interrupt item in second last position after 1 delay, and second item after 2 delays. - For patterns like ' ___*', interrupt first item and second item after 3 delays. - For patterns like ' __*', interrupt first item, second after 2 delays, and third after 2 delays. Parameters: reason ( str , default: 'Selective interrupt' ) \u2013 Reason for the interrupt Source code in src/factorysimpy/base/belt_store.py 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 def selective_interrupt ( self , reason = \"Selective interrupt\" ): \"\"\" Perform selective interruption based on belt occupancy patterns and mode. When noaccumulation_mode_on=True (STALLED_NONACCUMULATING_STATE): - Interrupt all items immediately When noaccumulation_mode_on=False (STALLED_ACCUMULATING_STATE): - Use pattern-based interruption with delays based on item positions Pattern-based rules for accumulating mode: - For patterns like '_****', interrupt all items. - For patterns like '_*_*_', interrupt item in second last position after 1 delay, and second item after 2 delays. - For patterns like '*___*', interrupt first item and second item after 3 delays. - For patterns like '**__*', interrupt first item, second after 2 delays, and third after 2 delays. Args: reason (str): Reason for the interrupt \"\"\" if not self . items : print ( f \"T= { self . env . now : .2f } No items on belt to interrupt\" ) return # If noaccumulation_mode_on is True (STALLED_NONACCUMULATING_STATE), interrupt all items immediately if self . noaccumulation_mode_on == True : print ( f \"T= { self . env . now : .2f } Noaccumulation_mode_on: interrupting all items immediately\" ) for i , item in enumerate ( self . items ): item_id = item [ 0 ] . id if hasattr ( item [ 0 ], 'id' ) else str ( id ( item )) self . _interrupt_specific_item ( item_id , f \" { reason } - immediate (no accumulation)\" ) return # For accumulating mode (STALLED_ACCUMULATING_STATE), use pattern-based interruption if self . accumulation_mode_indicator == True : #if self.noaccumulation_mode_on == False: print ( f \"T= { self . env . now : .2f } Accumulating mode: using pattern-based interruption\" ) # Get current belt pattern all_patterns = self . _get_belt_pattern () pattern = all_patterns [ 0 ] beltitems = all_patterns [ 1 ] print ( f \"T= { self . env . now : .2f } Current belt pattern: { pattern } and items { beltitems } \" ) # Analyze pattern and determine interruption strategy interruption_plan = self . _analyze_pattern_for_interruption ( all_patterns ) if not interruption_plan : print ( f \"T= { self . env . now : .2f } No interruption needed for current pattern\" ) return print ( f \"T= { self . env . now : .2f } Executing selective interruption plan: { interruption_plan } \" ) # Execute the interruption plan self . _execute_interruption_plan ( interruption_plan , reason ) buffer_store \u00b6 BufferStore ( env , capacity = float ( 'inf' ), mode = 'FIFO' ) \u00b6 Bases: Store This is a class that is derived from SimPy's Store class and has extra capabilities that makes it a reservable store for processes to reserve space for storing and retrieving items. Processes can use reserve_put() and reserve_get() methods to get notified when a space becomes available in the store or when an item gets available in the ReservableReqStore. These methods returns a unique event (SimPy.Event) to the process for every reserve requests it makes. get and put are two methods that can be used for item storing and retrieval from ReservableReqStore. Process has to make a prior reservation and pass the associated reservation event as argument in the get and put requests. ReservableReqStore maintains separate queues for reserve_put and reserve_get operations to ensures that only processes with valid reservations can store or retrieve items. ReservableReqStore preserves item order by associating an unreserved item in the store with a reservation event by index when a reserve_get() request is made. As a result, it maintains a list of reserved events to preserve item order. It also allows users to cancel an already placed reserve_get or reserve_put request even if it is yielded. It also handles the dissociation of the event and item done at the time of reservation when an already yielded event is canceled. An item that is added into the BufferStore using put(), it is associated with a delay representing the time it takes for the item to be available for retrieval. The delay can also be 0. The items can be retrieved in FIFO or LIFO manner based on the mode of operation of the BufferStore. Attributes: reserved_events ( list ) \u2013 Maintains events corresponding to reserved items to preserve item order by index reserve_put_queue ( list ) \u2013 Queue for managing reserve_put reservations reservations_put ( list ) \u2013 List of successful put reservations reserve_get_queue ( list ) \u2013 Queue for managing reserve_get reservations reservations_get ( list ) \u2013 List of successful get reservations Args: capacity (int, optional): The maximum number of items the store can hold. Defaults to infinity. mode (str, optional): The mode of the store ('FIFO' or 'LIFO'). Defaults to 'FIFO'. Source code in src/factorysimpy/base/buffer_store.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def __init__ ( self , env , capacity = float ( 'inf' ), mode = 'FIFO' ): \"\"\" Args: capacity (int, optional): The maximum number of items the store can hold. Defaults to infinity. mode (str, optional): The mode of the store ('FIFO' or 'LIFO'). Defaults to 'FIFO'. \"\"\" super () . __init__ ( env , capacity ) self . env = env self . mode = mode self . reserve_put_queue = [] # Queue for managing reserve_put reservations self . reservations_put = [] # List of successful put reservations self . reserve_get_queue = [] # Queue for managing reserve_get reservations self . reservations_get = [] # List of successful get reservations self . reserved_events = [] # Maintains events corresponding to reserved items to preserve item order self . ready_items = [] #Maintains the items ready to be taken out self . reserved_items = [] # parallel list of the exact items reserved self . _last_level_change_time = self . env . now self . _last_num_items = 0 self . _weighted_sum = 0.0 self . time_averaged_num_of_items_in_store = 0.0 # Time-averaged number of items in the store get ( get_event ) \u00b6 Retrieve an item from the store after a successful reservation. This method attempts to retrieve an item associated with a reserve_get event. If the reservation exists, it triggers _trigger_get to retrieve the item. If successful, _trigger_reserve_put is called to process any pending reserve_put requests. If the item retrieval fails, an error message is raised. Parameters: get_event ( Event ) \u2013 The reservation event associated with the request. Returns: item ( Object ) \u2013 The retrieved item if successful, otherwise raises an error Raises: RuntimeError \u2013 If no reservations are available in the reservations_get RuntimeError \u2013 If item returned is None Source code in src/factorysimpy/base/buffer_store.py 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 def get ( self , get_event ): \"\"\" Retrieve an item from the store after a successful reservation. This method attempts to retrieve an item associated with a `reserve_get` event. If the reservation exists, it triggers `_trigger_get` to retrieve the item. If successful, `_trigger_reserve_put` is called to process any pending `reserve_put` requests. If the item retrieval fails, an error message is raised. Args: get_event (simpy.Event): The reservation event associated with the request. Returns: item (Object): The retrieved item if successful, otherwise raises an error Raises: RuntimeError: If no reservations are available in the reservations_get RuntimeError: If item returned is None \"\"\" item = None #if there are reservations, then call _trigger_get if self . reservations_get : item = self . _trigger_get ( get_event ) #else raise an error else : raise RuntimeError ( \"No matching reservation found for process: reservations_get is empty\" ) #if an item is returned then call _trigger_reserve_put to process pending requests if item is not None : self . _trigger_reserve_put ( None ) if item is None : raise RuntimeError ( f \"No item found in the store for { get_event . requesting_process } and get request failed\" ) else : #self._update_time_averaged_level() return item move_to_ready_items ( item ) \u00b6 Move items from the store to the ready_items list after a put operation. This method is called as a process to ensure that items are moved asynchronously. Source code in src/factorysimpy/base/buffer_store.py 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 def move_to_ready_items ( self , item ): \"\"\" Move items from the store to the ready_items list after a put operation. This method is called as a process to ensure that items are moved asynchronously. \"\"\" # Move items to the ready_items list if self . items : #print(f\"T={self.env.now:.2f} beltstore received an item {item[0].id, item[1]} . Item started moving in belt\") yield self . env . timeout ( item [ 1 ]) #print(f\"T={self.env.now:.2f} bufferstore finished moving item {item[0].id, item[1]} going to ready_items\") item_index = self . items . index ( item ) item_to_put = self . items . pop ( item_index ) # Remove the first item #print(item_to_put, item) if len ( self . ready_items ) + len ( self . items ) < self . capacity : self . ready_items . append ( item_to_put [ 0 ]) #print(f\"T={self.env.now:.2f} bufferstore finished moving item {item[0].id, item[1]} moved to ready_items\") self . _trigger_reserve_get ( None ) self . _trigger_reserve_put ( None ) #print(f\"T={self.env.now:.2f} bufferstore is moving item {item[0].id, item[1]} to ready_items. Total items in buffer is {len(self.items)+len(self.ready_items)}\" ) else : raise RuntimeError ( \"Total number of items in the store exceeds capacity. Cannot move item to ready_items.\" ) put ( put_event , item ) \u00b6 Perform a put operation on the store and trigger any pending reserve_get requests. Ensures that only processes with a valid reservation can put items into the store. If the put operation succeeds, it triggers _trigger_reserve_get to process pending get requests. Parameters: put_event ( Event ) \u2013 The event corresponding to the reservation. item ( object ) \u2013 The item to be added to the store. Returns: proceed ( bool ) \u2013 True if the put operation succeeded, False otherwise. Raises: RuntimeError \u2013 If no reservations are available in the reservations_put RuntimeError \u2013 If proceed is False after put operation Source code in src/factorysimpy/base/buffer_store.py 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 def put ( self , put_event , item ): \"\"\" Perform a `put` operation on the store and trigger any pending `reserve_get` requests. Ensures that only processes with a valid reservation can put items into the store. If the put operation succeeds, it triggers `_trigger_reserve_get` to process pending get requests. Args: put_event (simpy.Event): The event corresponding to the reservation. item (object): The item to be added to the store. Returns: proceed (bool): True if the put operation succeeded, False otherwise. Raises: RuntimeError: If no reservations are available in the reservations_put RuntimeError: If proceed is False after put operation \"\"\" proceed = False if self . reservations_put : proceed = self . _trigger_put ( put_event , item ) else : raise RuntimeError ( \"No matching reservation found for process: reservations_put is empty\" ) if proceed : #print(f\"{self.env.now} proceed\") #self._trigger_get(None) self . _trigger_reserve_get ( None ) if not proceed : raise RuntimeError ( f \"No matching put_event found in the reservations and put failed for { item } \" ) else : #self._update_time_averaged_level() return proceed reserve_get () \u00b6 Create a reservation request to retrieve an item from the store. This method generates a SimPy event representing a request to reserve an item for retrieval ( get ). The event is assigned attributes such as the resource it belongs to, and the process making the request. The event is then added to reserve_get_queue , which is maintained in the order in which the requests are made, and _trigger_reserve_get() is called to process pending reservations if items are available. Returns: event ( Event ) \u2013 A reservation event that will succeed when an item becomes available. Source code in src/factorysimpy/base/buffer_store.py 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 def reserve_get ( self ): \"\"\" Create a reservation request to retrieve an item from the store. This method generates a SimPy event representing a request to reserve an item for retrieval (`get`). The event is assigned attributes such as the resource it belongs to, and the process making the request. The event is then added to `reserve_get_queue`, which is maintained in the order in which the requests are made, and `_trigger_reserve_get()` is called to process pending reservations if items are available. Returns: event (simpy.Event): A reservation event that will succeed when an item becomes available. \"\"\" #adding attributes to the newly created event for reserve_get event = self . env . event () event . resourcename = self event . requesting_process = self . env . active_process # Associate event with the current process self . reserve_get_queue . append ( event ) self . _trigger_reserve_get ( event ) return event reserve_get_cancel ( get_event_to_cancel ) \u00b6 Cancel a previously made reserve_get request. Source code in src/factorysimpy/base/buffer_store.py 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 def reserve_get_cancel ( self , get_event_to_cancel ): \"\"\" Cancel a previously made `reserve_get` request. \"\"\" # Case 1: still waiting if get_event_to_cancel in self . reserve_get_queue : self . reserve_get_queue . remove ( get_event_to_cancel ) self . _trigger_reserve_get ( None ) return True # Case 2: already yielded reservation if get_event_to_cancel in self . reservations_get : # 1) Remove from active reservations self . reservations_get . remove ( get_event_to_cancel ) # 2) Find its index in the parallel lists ev_idx = self . reserved_events . index ( get_event_to_cancel ) # 3) Pop out the exact item reference item = self . reserved_items . pop ( ev_idx ) # 4) Drop the event token self . reserved_events . pop ( ev_idx ) # 5) Remove it from ready_items wherever it currently is try : self . ready_items . remove ( item ) except ValueError : raise RuntimeError ( f \"Item { item } not found in ready_items during cancel.\" ) # 6) Compute new insertion index as a get call is cancelled and item that is reserved and associated to an event is now freely available to be assigned to a new incoming event if self . mode == \"FIFO\" : # one slot before the remaining reserved block insert_idx = len ( self . ready_items ) - len ( self . reserved_events ) - 1 else : # LIFO # top of stack insert_idx = len ( self . ready_items ) # 7) Re\u2011insert it self . ready_items . insert ( insert_idx , item ) # 8) Trigger any other pending reservations self . _trigger_reserve_get ( None ) return True # No such reservation raise RuntimeError ( \"No matching event in reserve_get_queue or reservations_get\" ) reserve_put () \u00b6 Create a reservation request to put an item into the store. This function generates a SimPy event representing a reservation request. The event is assigned attributes such as resource name, and the process making the request. The event is then added to reserve_put_queue , which is maintained in the order in which the requests are made. After adding the event to the queue, _trigger_reserve_put is called to process any pending reservations. Returns: event ( Event ) \u2013 A reservation event that will succeed when space is available. Source code in src/factorysimpy/base/buffer_store.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 def reserve_put ( self ): \"\"\" Create a reservation request to put an item into the store. This function generates a SimPy event representing a reservation request. The event is assigned attributes such as resource name, and the process making the request. The event is then added to `reserve_put_queue`, which is maintained in the order in which the requests are made. After adding the event to the queue, `_trigger_reserve_put` is called to process any pending reservations. Returns: event (simpy.Event): A reservation event that will succeed when space is available. \"\"\" event = self . env . event () event . resourcename = self # Store reference event . requesting_process = self . env . active_process # Process making the reservation self . reserve_put_queue . append ( event ) # Attempt to process reservations self . _trigger_reserve_put ( event ) return event reserve_put_cancel ( put_event_to_cancel ) \u00b6 Cancel a previously made reserve_put request. This method allows a process to cancel its reservation for putting an item into the store. If the reservation exists in the reserve_put_queue , it is removed before triggering _trigger_reserve_put to process any pending reservations. If the reservation is already in reservations_put , it is also removed and _trigger_reserve_put is triggered. Parameters: put_event_to_cancel ( Event ) \u2013 The reservation event that needs to be canceled. Returns: proceed ( bool ) \u2013 True if the reservation was successfully canceled. Raises: RuntimeError \u2013 If the specified event does not exist in reserve_put_queue or reservations_put . Source code in src/factorysimpy/base/buffer_store.py 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 def reserve_put_cancel ( self , put_event_to_cancel ): \"\"\" Cancel a previously made `reserve_put` request. This method allows a process to cancel its reservation for putting an item into the store. If the reservation exists in the `reserve_put_queue`, it is removed before triggering `_trigger_reserve_put` to process any pending reservations. If the reservation is already in `reservations_put`, it is also removed and `_trigger_reserve_put` is triggered. Args: put_event_to_cancel (simpy.Event): The reservation event that needs to be canceled. Returns: proceed (bool): True if the reservation was successfully canceled. Raises: RuntimeError: If the specified event does not exist in `reserve_put_queue` or `reservations_put`. \"\"\" #checking and removing the event if it is not yielded and is present in the reserve_put_queue proceed = False if put_event_to_cancel in self . reserve_put_queue : self . reserve_put_queue . remove ( put_event_to_cancel ) self . _trigger_reserve_put ( None ) #if t is removed, then a waiting event can be succeeded, if any proceed = True #checking and removing the event if it is already yielded and is present in the reservations_put elif put_event_to_cancel in self . reservations_put : self . reservations_put . remove ( put_event_to_cancel ) self . _trigger_reserve_put ( None ) #if t is removed, then a waiting event can be succeeded, if any proceed = True else : raise RuntimeError ( \"No matching event in reserve_put_queue or reservations_put for this process\" ) return proceed fleet_store \u00b6 FleetStore ( env , capacity = float ( 'inf' ), delay = 1 , transit_delay = 0 ) \u00b6 Bases: Store This is a class that is derived from SimPy's Store class and has extra capabilities that makes it a priority-based reservable store for processes to reserve space for storing and retrieving items with priority-based access. Processes can use reserve_put() and reserve_get() methods to get notified when a space becomes available in the store or when an item gets available in the ReservablePriorityReqStore. These methods returns a unique event (SimPy.Event) to the process for every reserve requests it makes. Processes can also pass a priority as argument in the request. Lower values indicate higher priority. get and put are two methods that can be used for item storing and retrieval from ReservablePriorityReqStore. Process has to make a prior reservation and pass the associated reservation event as argument in the get and put requests. ReservablePriorityReqStore maintains separate queues for reserve_put and reserve_get operations to ensures that only processes with valid reservations can store or retrieve items. ReservablePriorityReqStore preserves item order by associating an unreserved item in the store with a reservation event by index when a reserve_get() request is made. As a result, it maintains a list of reserved events to preserve item order. It also allows users to cancel an already placed reserve_get or reserve_put request even if it is yielded. It also handles the dissociation of the event and item done at the time of reservation when an already yielded event is canceled. Attributes: reserved_events ( list ) \u2013 Maintains events corresponding to reserved items to preserve item order by index reserve_put_queue ( list ) \u2013 Queue for managing reserve_put reservations reservations_put ( list ) \u2013 List of successful put reservations reserve_get_queue ( list ) \u2013 Queue for managing reserve_get reservations reservations_get ( list ) \u2013 List of successful get reservations Initializes a reservable store with priority-based reservations. Parameters: env ( Environment ) \u2013 The simulation environment. capacity ( int , default: float ('inf') ) \u2013 target quantity of items after which the fleet will be activated Defaults to infinity. delay ( ( int , float ) , default: 1 ) \u2013 Delay after which fleet activates to move items incase the target capacity is not reached. transit_delay ( ( int , float ) , default: 0 ) \u2013 Time to move the items after which the item becomes available. Can be a constant, generator, or callable. Defaults to 0. Source code in src/factorysimpy/base/fleet_store.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def __init__ ( self , env , capacity = float ( 'inf' ), delay = 1 , transit_delay = 0 ): \"\"\" Initializes a reservable store with priority-based reservations. Args: env (simpy.Environment): The simulation environment. capacity (int, optional): target quantity of items after which the fleet will be activated Defaults to infinity. delay (int, float, optional): Delay after which fleet activates to move items incase the target capacity is not reached. transit_delay (int, float, optional): Time to move the items after which the item becomes available. Can be a constant, generator, or callable. Defaults to 0. \"\"\" super () . __init__ ( env , capacity ) self . env = env self . delay = delay self . transit_delay = transit_delay self . reserve_put_queue = [] # Queue for managing reserve_put reservations self . reservations_put = [] # List of successful put reservations self . reserve_get_queue = [] # Queue for managing reserve_get reservations self . reservations_get = [] # List of successful get reservations self . reserved_events = [] # Maintains events corresponding to reserved items to preserve item order self . ready_items = [] #Maintains the items ready to be taken out self . reserved_items = [] # parallel list of the exact items reserved self . _last_level_change_time = self . env . now self . _last_num_items = 0 self . _weighted_sum = 0.0 self . time_averaged_num_of_items_in_store = 0.0 # Time-averaged number of items in the store self . activate_fleet = self . env . event () # Event to activate the fleet when items are available self . env . process ( self . fleet_activation_process ()) # Start the fleet activation process fleet_activation_process () \u00b6 Process to activate the fleet when items are available but not equivalent to self.capacity(level not achieved). This process waits for the activate_fleet event to be triggered. Source code in src/factorysimpy/base/fleet_store.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 def fleet_activation_process ( self ,): \"\"\" Process to activate the fleet when items are available but not equivalent to self.capacity(level not achieved). This process waits for the activate_fleet event to be triggered. \"\"\" while True : timeout_event = self . env . timeout ( self . delay ) event_list = [ timeout_event , self . activate_fleet ] yield self . env . any_of ( event_list ) print ( f \"T= { self . env . now : .2f } : Fleet activation process triggered.\" ) if self . items : print ( f \"T= { self . env . now : .2f } : Fleet activated with { len ( self . items ) } items ready.\" ) self . env . process ( self . move_to_ready_items ( self . items )) #self.env.process(self.move_to_ready_items(self.items)) if self . activate_fleet . triggered : #print(\"yes\") self . activate_fleet = self . env . event () # Reset the event for next activation get ( get_event ) \u00b6 Retrieve an item from the store after a successful reservation. This method attempts to retrieve an item associated with a reserve_get event. If the reservation exists, it triggers _trigger_get to retrieve the item. If successful, _trigger_reserve_put is called to process any pending reserve_put requests. If the item retrieval fails, an error message is raised. Parameters: get_event ( Event ) \u2013 The reservation event associated with the request. Returns: item ( Object ) \u2013 The retrieved item if successful, otherwise raises an error Raises: RuntimeError \u2013 If no reservations are available in the reservations_get RuntimeError \u2013 If item returned is None Source code in src/factorysimpy/base/fleet_store.py 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 def get ( self , get_event ): \"\"\" Retrieve an item from the store after a successful reservation. This method attempts to retrieve an item associated with a `reserve_get` event. If the reservation exists, it triggers `_trigger_get` to retrieve the item. If successful, `_trigger_reserve_put` is called to process any pending `reserve_put` requests. If the item retrieval fails, an error message is raised. Args: get_event (simpy.Event): The reservation event associated with the request. Returns: item (Object): The retrieved item if successful, otherwise raises an error Raises: RuntimeError: If no reservations are available in the reservations_get RuntimeError: If item returned is None \"\"\" item = None #if there are reservations, then call _trigger_get if self . reservations_get : item = self . _trigger_get ( get_event ) #else raise an error else : raise RuntimeError ( \"No matching reservation found for process: reservations_get is empty\" ) #if an item is returned then call _trigger_reserve_put to process pending requests if item is not None : self . _trigger_reserve_put ( None ) if item is None : raise RuntimeError ( f \"No item found in the store for { get_event . requesting_process } and get request failed\" ) else : #self._update_time_averaged_level() return item move_to_ready_items ( items ) \u00b6 Move items from the store to the ready_items list after a put operation. This method is called as a process to ensure that items are moved asynchronously. Source code in src/factorysimpy/base/fleet_store.py 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 def move_to_ready_items ( self , items ): \"\"\" Move items from the store to the ready_items list after a put operation. This method is called as a process to ensure that items are moved asynchronously. \"\"\" # Move items to the ready_items list if items : print ( f \"T= { self . env . now : .2f } : Moving items to ready_items.\" ) #START=self.env.now yield self . env . timeout ( self . transit_delay ) #print(\"WAITED FOR TRANSIT_DELAY BEFORE MOVING\", self.env.now-START) yield self . env . timeout ( self . transit_delay ) for item in items : item_index = self . items . index ( item ) item_to_put = self . items . pop ( item_index ) # Remove the first item if len ( self . ready_items ) < self . capacity : self . ready_items . append ( item_to_put ) #print(f\"T={self.env.now:.2f}: {self.id} moved item {item_to_put.id} to ready_items.\") self . _trigger_reserve_get ( None ) self . _trigger_reserve_put ( None ) #print(f\"T={self.env.now:.2f} bufferstore is moving item {item[0].id, item[1]} to ready_items. Total items in buffer is {len(self.items)+len(self.ready_items)}\" ) else : raise RuntimeError ( \"Total number of items in the store exceeds capacity. Cannot move item to ready_items.\" ) print ( f \"T= { self . env . now : .2f } : Fleetstore moved items to ready_items.\" ) put ( put_event , item ) \u00b6 Perform a put operation on the store and trigger any pending reserve_get requests. Ensures that only processes with a valid reservation can put items into the store. If the put operation succeeds, it triggers _trigger_reserve_get to process pending get requests. Parameters: put_event ( Event ) \u2013 The event corresponding to the reservation. item ( object ) \u2013 The item to be added to the store. Returns: proceed ( bool ) \u2013 True if the put operation succeeded, False otherwise. Raises: RuntimeError \u2013 If no reservations are available in the reservations_put RuntimeError \u2013 If proceed is False after put operation Source code in src/factorysimpy/base/fleet_store.py 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 def put ( self , put_event , item ): \"\"\" Perform a `put` operation on the store and trigger any pending `reserve_get` requests. Ensures that only processes with a valid reservation can put items into the store. If the put operation succeeds, it triggers `_trigger_reserve_get` to process pending get requests. Args: put_event (simpy.Event): The event corresponding to the reservation. item (object): The item to be added to the store. Returns: proceed (bool): True if the put operation succeeded, False otherwise. Raises: RuntimeError: If no reservations are available in the reservations_put RuntimeError: If proceed is False after put operation \"\"\" proceed = False if self . reservations_put : proceed = self . _trigger_put ( put_event , item ) else : raise RuntimeError ( \"No matching reservation found for process: reservations_put is empty\" ) if proceed : #print(f\"{self.env.now} proceed\") #self._trigger_get(None) self . _trigger_reserve_get ( None ) if not proceed : raise RuntimeError ( f \"No matching put_event found in the reservations and put failed for { item } \" ) else : #self._update_time_averaged_level() return proceed reserve_get ( priority = 0 ) \u00b6 Create a reservation request to retrieve an item from the store. This method generates a SimPy event representing a request to reserve an item for retrieval ( get ). The event is assigned attributes such as priority, the resource it belongs to, and the process making the request. The event is then added to reserve_get_queue , which is maintained in priority order, and _trigger_reserve_get() is called to process pending reservations if items are available. Parameters: priority ( int , default: 0 ) \u2013 The priority level of the reservation request. Lower values indicate higher priority. Defaults to 0. Returns: event ( Event ) \u2013 A reservation event that will succeed when an item becomes available. Source code in src/factorysimpy/base/fleet_store.py 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 def reserve_get ( self , priority = 0 ): \"\"\" Create a reservation request to retrieve an item from the store. This method generates a SimPy event representing a request to reserve an item for retrieval (`get`). The event is assigned attributes such as priority, the resource it belongs to, and the process making the request. The event is then added to `reserve_get_queue`, which is maintained in priority order, and `_trigger_reserve_get()` is called to process pending reservations if items are available. Args: priority (int, optional): The priority level of the reservation request. Lower values indicate higher priority. Defaults to 0. Returns: event (simpy.Event): A reservation event that will succeed when an item becomes available. \"\"\" #adding attributes to the newly created event for reserve_get event = self . env . event () event . resourcename = self event . requesting_process = self . env . active_process # Associate event with the current process #event.priority_to_get = (priority, self._env.now) event . priority_to_get = priority #sorting the list based on priority after appending the new event self . reserve_get_queue . append ( event ) self . reserve_get_queue . sort ( key = lambda e : e . priority_to_get ) self . _trigger_reserve_get ( event ) return event reserve_get_cancel ( get_event_to_cancel ) \u00b6 Cancel a previously made reserve_get request. Source code in src/factorysimpy/base/fleet_store.py 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 def reserve_get_cancel ( self , get_event_to_cancel ): \"\"\" Cancel a previously made `reserve_get` request. \"\"\" # Case 1: still waiting if get_event_to_cancel in self . reserve_get_queue : self . reserve_get_queue . remove ( get_event_to_cancel ) self . _trigger_reserve_get ( None ) return True # Case 2: already yielded reservation if get_event_to_cancel in self . reservations_get : # 1) Remove from active reservations self . reservations_get . remove ( get_event_to_cancel ) # 2) Find its index in the parallel lists ev_idx = self . reserved_events . index ( get_event_to_cancel ) # 3) Pop out the exact item reference item = self . reserved_items . pop ( ev_idx ) # 4) Drop the event token self . reserved_events . pop ( ev_idx ) # 5) Remove it from ready_items wherever it currently is try : self . ready_items . remove ( item ) except ValueError : raise RuntimeError ( f \"Item { item !r} not found in ready_items during cancel.\" ) # 6) Compute new insertion index # \"FIFO\": # one slot before the remaining reserved block insert_idx = len ( self . ready_items ) - len ( self . reserved_events ) - 1 # 7) Re\u2011insert it self . ready_items . insert ( insert_idx , item ) # 8) Trigger any other pending reservations self . _trigger_reserve_get ( None ) return True # No such reservation raise RuntimeError ( \"No matching event in reserve_get_queue or reservations_get\" ) reserve_get_cancel1 ( get_event_to_cancel ) \u00b6 Cancel a previously made reserve_get request. This method allows a process to cancel its reservation for retrieving an item from the store. If the reservation exists in the reserve_get_queue , it is removed, and _trigger_reserve_get() is called to process any remaining reservations. If the reservation is already in reservations_get , it is removed, and the corresponding item is repositioned in the store to maintain order. _trigger_reserve_get() is then triggered to handle pending reservations. Parameters: get_event_to_cancel ( Event ) \u2013 The reservation event that needs to be canceled. Returns: proceed ( bool ) \u2013 True if the reservation was successfully canceled. Raises: RuntimeError \u2013 If the specified event does not exist in reserve_get_queue or reservations_get . Source code in src/factorysimpy/base/fleet_store.py 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 def reserve_get_cancel1 ( self , get_event_to_cancel ): \"\"\" Cancel a previously made `reserve_get` request. This method allows a process to cancel its reservation for retrieving an item from the store. If the reservation exists in the `reserve_get_queue`, it is removed, and `_trigger_reserve_get()` is called to process any remaining reservations. If the reservation is already in `reservations_get`, it is removed, and the corresponding item is repositioned in the store to maintain order. `_trigger_reserve_get()` is then triggered to handle pending reservations. Args: get_event_to_cancel (simpy.Event): The reservation event that needs to be canceled. Returns: proceed (bool): True if the reservation was successfully canceled. Raises: RuntimeError: If the specified event does not exist in `reserve_get_queue` or `reservations_get`. \"\"\" proceed = False #checking and removing the event if it is not yielded and is present in the reserve_get_queue if get_event_to_cancel in self . reserve_get_queue : self . reserve_get_queue . remove ( get_event_to_cancel ) self . _trigger_reserve_get ( None ) #if t is removed, then a waiting event can be succeeded, if any proceed = True #checking and removing the event if it is already yielded and is present in the reservations_queue. # 1-to-1 association with items done to preserve item order should also be removed. elif get_event_to_cancel in self . reservations_get : self . reservations_get . remove ( get_event_to_cancel ) #deleting the associated event in the reserved_events list to preserve the order of the items #finding index of the item event_in_index = self . reserved_events . index ( get_event_to_cancel ) delta_position = len ( self . reserved_events ) #shifting the item item_to_shift = self . items . pop ( event_in_index ) self . items . insert ( delta_position - 1 , item_to_shift ) #deleting the event self . reserved_events . pop ( event_in_index ) #if t is removed, then a waiting event can be succeeded, if any self . _trigger_reserve_get ( None ) proceed = True else : raise RuntimeError ( \"No matching event in reserve_get_queue or reservations_get for this process\" ) return proceed reserve_put ( priority = 0 ) \u00b6 Create a reservation request to put an item into the store. This function generates a SimPy event representing a reservation request. The event is assigned attributes such as priority, resource name, and the process making the request. The event is then added to reserve_put_queue , which is maintained in priority order. After adding the event to the queue, _trigger_reserve_put is called to process any pending reservations. Parameters: priority ( int , default: 0 ) \u2013 The priority level of the reservation request. Lower values indicate higher priority. Defaults to 0. Returns: event ( Event ) \u2013 A reservation event that will succeed when space is available. Source code in src/factorysimpy/base/fleet_store.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 def reserve_put ( self , priority = 0 ): \"\"\" Create a reservation request to put an item into the store. This function generates a SimPy event representing a reservation request. The event is assigned attributes such as priority, resource name, and the process making the request. The event is then added to `reserve_put_queue`, which is maintained in priority order. After adding the event to the queue, `_trigger_reserve_put` is called to process any pending reservations. Args: priority (int, optional): The priority level of the reservation request. Lower values indicate higher priority. Defaults to 0. Returns: event (simpy.Event): A reservation event that will succeed when space is available. \"\"\" event = self . env . event () event . resourcename = self # Store reference event . requesting_process = self . env . active_process # Process making the reservation event . priority_to_put = priority # Priority for sorting reservations # Add the event to the reservation queue and sort by priority self . reserve_put_queue . append ( event ) self . reserve_put_queue . sort ( key = lambda e : e . priority_to_put ) # Attempt to process reservations self . _trigger_reserve_put ( event ) return event reserve_put_cancel ( put_event_to_cancel ) \u00b6 Cancel a previously made reserve_put request. This method allows a process to cancel its reservation for putting an item into the store. If the reservation exists in the reserve_put_queue , it is removed before triggering _trigger_reserve_put to process any pending reservations. If the reservation is already in reservations_put , it is also removed and _trigger_reserve_put is triggered. Parameters: put_event_to_cancel ( Event ) \u2013 The reservation event that needs to be canceled. Returns: proceed ( bool ) \u2013 True if the reservation was successfully canceled. Raises: RuntimeError \u2013 If the specified event does not exist in reserve_put_queue or reservations_put . Source code in src/factorysimpy/base/fleet_store.py 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 def reserve_put_cancel ( self , put_event_to_cancel ): \"\"\" Cancel a previously made `reserve_put` request. This method allows a process to cancel its reservation for putting an item into the store. If the reservation exists in the `reserve_put_queue`, it is removed before triggering `_trigger_reserve_put` to process any pending reservations. If the reservation is already in `reservations_put`, it is also removed and `_trigger_reserve_put` is triggered. Args: put_event_to_cancel (simpy.Event): The reservation event that needs to be canceled. Returns: proceed (bool): True if the reservation was successfully canceled. Raises: RuntimeError: If the specified event does not exist in `reserve_put_queue` or `reservations_put`. \"\"\" #checking and removing the event if it is not yielded and is present in the reserve_put_queue proceed = False if put_event_to_cancel in self . reserve_put_queue : self . reserve_put_queue . remove ( put_event_to_cancel ) self . _trigger_reserve_put ( None ) #if t is removed, then a waiting event can be succeeded, if any proceed = True #checking and removing the event if it is already yielded and is present in the reservations_put elif put_event_to_cancel in self . reservations_put : self . reservations_put . remove ( put_event_to_cancel ) self . _trigger_reserve_put ( None ) #if t is removed, then a waiting event can be succeeded, if any proceed = True else : raise RuntimeError ( \"No matching event in reserve_put_queue or reservations_put for this process\" ) return proceed priority_req_store \u00b6 PriorityGet ( resource , priority = 0 ) \u00b6 Bases: Get Source code in src/factorysimpy/base/priority_req_store.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def __init__ ( self , resource , priority = 0 , ): self . priority = priority \"\"\"The priority of this request. A smaller number means higher priority.\"\"\" self . time = resource . _env . now \"\"\"The time at which the request was made.\"\"\" self . key = ( self . priority , self . time ) #print(\"Resource is \", resource) super () . __init__ ( resource ) priority = priority instance-attribute \u00b6 The priority of this request. A smaller number means higher priority. time = resource . _env . now instance-attribute \u00b6 The time at which the request was made. PriorityPut ( resource , item , priority = 0 ) \u00b6 Bases: Put Source code in src/factorysimpy/base/priority_req_store.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def __init__ ( self , resource , item , priority = 0 , ): self . priority = priority \"\"\"The priority of this request. A smaller number means higher priority.\"\"\" self . time = resource . _env . now \"\"\"The time at which the request was made.\"\"\" self . key = ( self . priority , self . time ) self . item = item #print(\"Resource is \", resource) super () . __init__ ( resource ) priority = priority instance-attribute \u00b6 The priority of this request. A smaller number means higher priority. time = resource . _env . now instance-attribute \u00b6 The time at which the request was made. PriorityReqStore ( env , capacity = 1 ) \u00b6 Bases: Store This is a class derived from SimPy's Store class and has extra capabilities that makes it a priority-based store for put and get. Processes can pass a priority as argument in the put and get request. Request with lower values of priority yields first among all get(or put) requests. If two requests with same priority are placed from two processes then FIFO order is followed to yield the requests. Source code in src/factorysimpy/base/priority_req_store.py 87 88 def __init__ ( self , env , capacity = 1 ): super () . __init__ ( env , capacity ) get = BoundClass ( PriorityGet ) class-attribute instance-attribute \u00b6 yields a get request with the given priority . put = BoundClass ( PriorityPut ) class-attribute instance-attribute \u00b6 yields a put request with the given priority SortedQueue ( maxlen = None ) \u00b6 Bases: list Queue for sorting events by their :attr: ~PriorityRequest.key attribute. Source code in src/factorysimpy/base/priority_req_store.py 15 16 17 18 def __init__ ( self , maxlen = None ): super () . __init__ () self . maxlen = maxlen \"\"\"Maximum length of the queue.\"\"\" maxlen = maxlen instance-attribute \u00b6 Maximum length of the queue. append ( item ) \u00b6 Sort item into the queue. Raise a :exc: RuntimeError if the queue is full. Source code in src/factorysimpy/base/priority_req_store.py 20 21 22 23 24 25 26 27 28 29 30 def append ( self , item ) -> None : \"\"\"Sort *item* into the queue. Raise a :exc:`RuntimeError` if the queue is full. \"\"\" if self . maxlen is not None and len ( self ) >= self . maxlen : raise RuntimeError ( 'Cannot append event. Queue is full.' ) super () . append ( item ) super () . sort ( key = lambda e : e . key ) reservable_priority_req_filter_store \u00b6 ReservablePriorityReqFilterStore ( env , capacity = float ( 'inf' ), trigger_delay = 0 ) \u00b6 Bases: FilterStore This is a class that is derived from SimPy's Store class and has extra capabilities that makes it a priority-based reservable store for processes to reserve space for storing and retrieving items with priority-based access. It supports user tp only get items that match a user criteria Processes can use reserve_put() and reserve_get() methods to get notified when a space becomes available in the store or when an item gets available in the ReservablePriorityReqStore. These methods returns a unique event (SimPy.Event) to the process for every reserve requests it makes. Processes can also pass a priority as argument in the request. Lower values indicate higher priority. Filter to be used while using \"get\" can be passed in the reserve_get request. get and put are two methods that can be used for item storing and retrieval from ReservablePriorityReqStore. Process has to make a prior reservation and pass the associated reservation event as argument in the get and put requests. ReservablePriorityReqStore maintains separate queues for reserve_put and reserve_get operations to ensures that only processes with valid reservations can store or retrieve items. ReservablePriorityReqStore preserves item order by associating an unreserved item in the store with a reservation event by index when a reserve_get() request is made. As a result, it maintains a list of reserved events to preserve item order. It also allows users to cancel an already placed reserve_get or reserve_put request even if it is yielded. It also handles the dissociation of the event and item done at the time of reservation when an already yielded event is canceled. Attributes: reserved_events ( list ) \u2013 Maintains events corresponding to reserved items to preserve item order by index reserve_put_queue ( list ) \u2013 Queue for managing reserve_put reservations reservations_put ( list ) \u2013 List of successful put reservations reserve_get_queue ( list ) \u2013 Queue for managing reserve_get reservations reservations_get ( list ) \u2013 List of successful get reservations trigger_delay ( int ) \u2013 Delay time after which a trigger_reserve_get is called to allow waiting get calls to succeed. Initializes a reservable store with priority-based reservations. Args: capacity (int, optional): The maximum number of items the store can hold. Defaults to infinity. Source code in src/factorysimpy/base/reservable_priority_req_filter_store.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def __init__ ( self , env , capacity = float ( 'inf' ), trigger_delay = 0 ): \"\"\" Initializes a reservable store with priority-based reservations. Args: capacity (int, optional): The maximum number of items the store can hold. Defaults to infinity. \"\"\" super () . __init__ ( env , capacity ) self . env = env self . trigger_delay = trigger_delay self . reserve_put_queue = [] # Queue for managing reserve_put reservations self . reservations_put = [] # List of successful put reservations self . reserve_get_queue = [] # Queue for managing reserve_get reservations self . reservations_get = [] # List of successful get reservations self . reserved_events = [] # Maintains events corresponding to reserved items to preserve item order get ( get_event ) \u00b6 Retrieve an item from the store after a successful reservation. This method attempts to retrieve an item associated with a reserve_get event. If the reservation exists, it triggers _trigger_get to retrieve the item. If successful, _trigger_reserve_put is called to process any pending reserve_put requests. If the item retrieval fails, an error message is raised. Parameters: get_event ( Event ) \u2013 The reservation event associated with the request. Returns: item ( Object ) \u2013 The retrieved item if successful, otherwise raises an error Raises: RuntimeError \u2013 If no reservations are available in the reservations_get RuntimeError \u2013 If item returned is None Source code in src/factorysimpy/base/reservable_priority_req_filter_store.py 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 def get ( self , get_event ): \"\"\" Retrieve an item from the store after a successful reservation. This method attempts to retrieve an item associated with a `reserve_get` event. If the reservation exists, it triggers `_trigger_get` to retrieve the item. If successful, `_trigger_reserve_put` is called to process any pending `reserve_put` requests. If the item retrieval fails, an error message is raised. Args: get_event (simpy.Event): The reservation event associated with the request. Returns: item (Object): The retrieved item if successful, otherwise raises an error Raises: RuntimeError: If no reservations are available in the reservations_get RuntimeError: If item returned is None \"\"\" item = None #if there are reservations, then call _trigger_get if self . reservations_get : item = self . _trigger_get ( get_event ) #else raise an error else : raise RuntimeError ( \"No matching reservation found for process: reservations_get is empty\" ) #if an item is returned then call _trigger_reserve_put to process pending requests if item is not None : self . _trigger_reserve_put ( None ) if item is None : raise RuntimeError ( f \"No item found in the store for { get_event . requesting_process } and get request failed\" ) else : return item put ( put_event , item ) \u00b6 Perform a put operation on the store and trigger any pending reserve_get requests. Ensures that only processes with a valid reservation can put items into the store. If the put operation succeeds, it triggers _trigger_reserve_get to process pending get requests. Parameters: put_event ( Event ) \u2013 The event corresponding to the reservation. item ( object ) \u2013 The item to be added to the store. Returns: proceed ( bool ) \u2013 True if the put operation succeeded, False otherwise. Raises: RuntimeError \u2013 If no reservations are available in the reservations_put RuntimeError \u2013 If proceed is False after put operation Source code in src/factorysimpy/base/reservable_priority_req_filter_store.py 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 def put ( self , put_event , item ,): \"\"\" Perform a `put` operation on the store and trigger any pending `reserve_get` requests. Ensures that only processes with a valid reservation can put items into the store. If the put operation succeeds, it triggers `_trigger_reserve_get` to process pending get requests. Args: put_event (simpy.Event): The event corresponding to the reservation. item (object): The item to be added to the store. Returns: proceed (bool): True if the put operation succeeded, False otherwise. Raises: RuntimeError: If no reservations are available in the reservations_put RuntimeError: If proceed is False after put operation \"\"\" proceed = False if self . reservations_put : proceed = self . _trigger_put ( put_event , item ) else : raise RuntimeError ( \"No matching reservation found for process: reservations_put is empty\" ) if proceed : #print(f\"{self.env.now} proceed\") #self._trigger_get(None) self . _trigger_reserve_get ( None ) if not proceed : raise RuntimeError ( f \"No matching put_event found in the reservations and put failed for { item } \" ) else : return proceed reserve_get ( priority = 0 , filter = None ) \u00b6 Create a reservation request to retrieve an item from the store. This method generates a SimPy event representing a request to reserve an item for retrieval ( get ). The event is assigned attributes such as priority, the resource it belongs to, and the process making the request. The event is then added to reserve_get_queue , which is maintained in priority order, and _trigger_reserve_get() is called to process pending reservations if items are available. Parameters: priority ( int , default: 0 ) \u2013 The priority level of the reservation request. Lower values indicate higher priority. Defaults to 0. filter ( filter=lambdaitem=True , default: None ) \u2013 Filter to be used while using \"reserve_get Returns: event ( Event ) \u2013 A reservation event that will succeed when an item becomes available. Source code in src/factorysimpy/base/reservable_priority_req_filter_store.py 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 def reserve_get ( self , priority = 0 , filter = None ): \"\"\" Create a reservation request to retrieve an item from the store. This method generates a SimPy event representing a request to reserve an item for retrieval (`get`). The event is assigned attributes such as priority, the resource it belongs to, and the process making the request. The event is then added to `reserve_get_queue`, which is maintained in priority order, and `_trigger_reserve_get()` is called to process pending reservations if items are available. Args: priority (int, optional): The priority level of the reservation request. Lower values indicate higher priority. Defaults to 0. filter (filter=lambdaitem=True, optional): Filter to be used while using \"reserve_get Returns: event (simpy.Event): A reservation event that will succeed when an item becomes available. \"\"\" #adding attributes to the newly created event for reserve_get event = self . env . event () event . resourcename = self event . requesting_process = self . env . active_process # Associate event with the current process #event.priority_to_get = (priority, self._env.now) event . priority_to_get = priority # Check if 'filter' is provided, if not, assign a default filter if filter is None : #print(f\"T={self.env.now} filter is None so making it true for all items\") #filter = lambda item: True # Default filter that accepts all items filter = lambda x : self . env . now >= x . put_time + self . trigger_delay event . filter = filter else : #print(f\"T={self.env.now} filter is not None \") event . filter = filter #sorting the list based on priority after appending the new event self . reserve_get_queue . append ( event ) self . reserve_get_queue . sort ( key = lambda e : e . priority_to_get ) self . _trigger_reserve_get ( event ) return event reserve_get_cancel ( get_event_to_cancel ) \u00b6 Cancel a previously made reserve_get request. This method allows a process to cancel its reservation for retrieving an item from the store. If the reservation exists in the reserve_get_queue , it is removed, and _trigger_reserve_get() is called to process any remaining reservations. If the reservation is already in reservations_get , it is removed, and the corresponding item is repositioned in the store to maintain order. _trigger_reserve_get() is then triggered to handle pending reservations. Parameters: get_event_to_cancel ( Event ) \u2013 The reservation event that needs to be canceled. Returns: proceed ( bool ) \u2013 True if the reservation was successfully canceled. Raises: RuntimeError \u2013 If the specified event does not exist in reserve_get_queue or reservations_get . Source code in src/factorysimpy/base/reservable_priority_req_filter_store.py 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 def reserve_get_cancel ( self , get_event_to_cancel ): \"\"\" Cancel a previously made `reserve_get` request. This method allows a process to cancel its reservation for retrieving an item from the store. If the reservation exists in the `reserve_get_queue`, it is removed, and `_trigger_reserve_get()` is called to process any remaining reservations. If the reservation is already in `reservations_get`, it is removed, and the corresponding item is repositioned in the store to maintain order. `_trigger_reserve_get()` is then triggered to handle pending reservations. Args: get_event_to_cancel (simpy.Event): The reservation event that needs to be canceled. Returns: proceed (bool): True if the reservation was successfully canceled. Raises: RuntimeError: If the specified event does not exist in `reserve_get_queue` or `reservations_get`. \"\"\" #checking and removing the event if it is not yielded and is present in the reserve_get_queue proceed = False if get_event_to_cancel in self . reserve_get_queue : self . reserve_get_queue . remove ( get_event_to_cancel ) self . _trigger_reserve_get ( None ) #if t is removed, then a waiting event can be succeeded, if any return True #checking and removing the event if it is already yielded and is present in the reservations_queue. # 1-to-1 association with items done to preserve item order should also be removed. elif get_event_to_cancel in self . reservations_get : self . reservations_get . remove ( get_event_to_cancel ) #deleting the associated event in the reserved_events list to preserve the order of the items #finding index of the item event_in_index = self . reserved_events . index ( get_event_to_cancel ) delta_position = len ( self . reserved_events ) #shifting the item item_to_shift = self . items . pop ( event_in_index ) self . items . insert ( delta_position - 1 , item_to_shift ) #deleting the event self . reserved_events . pop ( event_in_index ) #if t is removed, then a waiting event can be succeeded, if any self . _trigger_reserve_get ( None ) proceed = True else : raise RuntimeError ( \"No matching event in reserve_get_queue or reservations_get for this process\" ) return proceed reserve_put ( priority = 0 ) \u00b6 Create a reservation request to put an item into the store. This function generates a SimPy event representing a reservation request. The event is assigned attributes such as priority, resource name, and the process making the request. The event is then added to reserve_put_queue , which is maintained in priority order. After adding the event to the queue, _trigger_reserve_put is called to process any pending reservations. Parameters: priority ( int , default: 0 ) \u2013 The priority level of the reservation request. Lower values indicate higher priority. Defaults to 0. Returns: event ( Event ) \u2013 A reservation event that will succeed when space is available. Source code in src/factorysimpy/base/reservable_priority_req_filter_store.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def reserve_put ( self , priority = 0 ): \"\"\" Create a reservation request to put an item into the store. This function generates a SimPy event representing a reservation request. The event is assigned attributes such as priority, resource name, and the process making the request. The event is then added to `reserve_put_queue`, which is maintained in priority order. After adding the event to the queue, `_trigger_reserve_put` is called to process any pending reservations. Args: priority (int, optional): The priority level of the reservation request. Lower values indicate higher priority. Defaults to 0. Returns: event (simpy.Event): A reservation event that will succeed when space is available. \"\"\" event = self . env . event () event . resourcename = self # Store reference event . requesting_process = self . env . active_process # Process making the reservation event . priority_to_put = priority # Priority for sorting reservations # Add the event to the reservation queue and sort by priority self . reserve_put_queue . append ( event ) self . reserve_put_queue . sort ( key = lambda e : e . priority_to_put ) # Attempt to process reservations self . _trigger_reserve_put ( event ) return event reserve_put_cancel ( put_event_to_cancel ) \u00b6 Cancel a previously made reserve_put request. This method allows a process to cancel its reservation for putting an item into the store. If the reservation exists in the reserve_put_queue , it is removed before triggering _trigger_reserve_put to process any pending reservations. If the reservation is already in reservations_put , it is also removed and _trigger_reserve_put is triggered. Parameters: put_event_to_cancel ( Event ) \u2013 The reservation event that needs to be canceled. Returns: proceed ( bool ) \u2013 True if the reservation was successfully canceled. Raises: RuntimeError \u2013 If the specified event does not exist in reserve_put_queue or reservations_put . Source code in src/factorysimpy/base/reservable_priority_req_filter_store.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 def reserve_put_cancel ( self , put_event_to_cancel ): \"\"\" Cancel a previously made `reserve_put` request. This method allows a process to cancel its reservation for putting an item into the store. If the reservation exists in the `reserve_put_queue`, it is removed before triggering `_trigger_reserve_put` to process any pending reservations. If the reservation is already in `reservations_put`, it is also removed and `_trigger_reserve_put` is triggered. Args: put_event_to_cancel (simpy.Event): The reservation event that needs to be canceled. Returns: proceed (bool): True if the reservation was successfully canceled. Raises: RuntimeError: If the specified event does not exist in `reserve_put_queue` or `reservations_put`. \"\"\" #checking and removing the event if it is not yielded and is present in the reserve_put_queue proceed = False if put_event_to_cancel in self . reserve_put_queue : self . reserve_put_queue . remove ( put_event_to_cancel ) self . _trigger_reserve_put ( None ) #if t is removed, then a waiting event can be succeeded, if any proceed = True #checking and removing the event if it is already yielded and is present in the reservations_put elif put_event_to_cancel in self . reservations_put : self . reservations_put . remove ( put_event_to_cancel ) self . _trigger_reserve_put ( None ) #if t is removed, then a waiting event can be succeeded, if any proceed = True else : raise RuntimeError ( \"No matching event in reserve_put_queue or reservations_put for this process\" ) return proceed reservable_priority_req_store \u00b6 ReservablePriorityReqStore ( env , capacity = float ( 'inf' )) \u00b6 Bases: Store This is a class that is derived from SimPy's Store class and has extra capabilities that makes it a priority-based reservable store for processes to reserve space for storing and retrieving items with priority-based access. Processes can use reserve_put() and reserve_get() methods to get notified when a space becomes available in the store or when an item gets available in the ReservablePriorityReqStore. These methods returns a unique event (SimPy.Event) to the process for every reserve requests it makes. Processes can also pass a priority as argument in the request. Lower values indicate higher priority. get and put are two methods that can be used for item storing and retrieval from ReservablePriorityReqStore. Process has to make a prior reservation and pass the associated reservation event as argument in the get and put requests. ReservablePriorityReqStore maintains separate queues for reserve_put and reserve_get operations to ensures that only processes with valid reservations can store or retrieve items. ReservablePriorityReqStore preserves item order by associating an unreserved item in the store with a reservation event by index when a reserve_get() request is made. As a result, it maintains a list of reserved events to preserve item order. It also allows users to cancel an already placed reserve_get or reserve_put request even if it is yielded. It also handles the dissociation of the event and item done at the time of reservation when an already yielded event is canceled. Attributes: reserved_events ( list ) \u2013 Maintains events corresponding to reserved items to preserve item order by index reserve_put_queue ( list ) \u2013 Queue for managing reserve_put reservations reservations_put ( list ) \u2013 List of successful put reservations reserve_get_queue ( list ) \u2013 Queue for managing reserve_get reservations reservations_get ( list ) \u2013 List of successful get reservations Initializes a reservable store with priority-based reservations. Args: capacity (int, optional): The maximum number of items the store can hold. Defaults to infinity. Source code in src/factorysimpy/base/reservable_priority_req_store.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def __init__ ( self , env , capacity = float ( 'inf' )): \"\"\" Initializes a reservable store with priority-based reservations. Args: capacity (int, optional): The maximum number of items the store can hold. Defaults to infinity. \"\"\" super () . __init__ ( env , capacity ) self . env = env self . reserve_put_queue = [] # Queue for managing reserve_put reservations self . reservations_put = [] # List of successful put reservations self . reserve_get_queue = [] # Queue for managing reserve_get reservations self . reservations_get = [] # List of successful get reservations self . reserved_events = [] # Maintains events corresponding to reserved items to preserve item order self . _last_level_change_time = self . env . now self . _last_num_items = 0 self . _weighted_sum = 0.0 self . time_averaged_num_of_items_in_store = 0.0 # Time-averaged number of items in the store get ( get_event ) \u00b6 Retrieve an item from the store after a successful reservation. This method attempts to retrieve an item associated with a reserve_get event. If the reservation exists, it triggers _trigger_get to retrieve the item. If successful, _trigger_reserve_put is called to process any pending reserve_put requests. If the item retrieval fails, an error message is raised. Parameters: get_event ( Event ) \u2013 The reservation event associated with the request. Returns: item ( Object ) \u2013 The retrieved item if successful, otherwise raises an error Raises: RuntimeError \u2013 If no reservations are available in the reservations_get RuntimeError \u2013 If item returned is None Source code in src/factorysimpy/base/reservable_priority_req_store.py 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 def get ( self , get_event ): \"\"\" Retrieve an item from the store after a successful reservation. This method attempts to retrieve an item associated with a `reserve_get` event. If the reservation exists, it triggers `_trigger_get` to retrieve the item. If successful, `_trigger_reserve_put` is called to process any pending `reserve_put` requests. If the item retrieval fails, an error message is raised. Args: get_event (simpy.Event): The reservation event associated with the request. Returns: item (Object): The retrieved item if successful, otherwise raises an error Raises: RuntimeError: If no reservations are available in the reservations_get RuntimeError: If item returned is None \"\"\" item = None #if there are reservations, then call _trigger_get if self . reservations_get : item = self . _trigger_get ( get_event ) #else raise an error else : raise RuntimeError ( \"No matching reservation found for process: reservations_get is empty\" ) #if an item is returned then call _trigger_reserve_put to process pending requests if item is not None : self . _trigger_reserve_put ( None ) if item is None : raise RuntimeError ( f \"No item found in the store for { get_event . requesting_process } and get request failed\" ) else : self . _update_time_averaged_level () return item put ( put_event , item ) \u00b6 Perform a put operation on the store and trigger any pending reserve_get requests. Ensures that only processes with a valid reservation can put items into the store. If the put operation succeeds, it triggers _trigger_reserve_get to process pending get requests. Parameters: put_event ( Event ) \u2013 The event corresponding to the reservation. item ( object ) \u2013 The item to be added to the store. Returns: proceed ( bool ) \u2013 True if the put operation succeeded, False otherwise. Raises: RuntimeError \u2013 If no reservations are available in the reservations_put RuntimeError \u2013 If proceed is False after put operation Source code in src/factorysimpy/base/reservable_priority_req_store.py 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 def put ( self , put_event , item ): \"\"\" Perform a `put` operation on the store and trigger any pending `reserve_get` requests. Ensures that only processes with a valid reservation can put items into the store. If the put operation succeeds, it triggers `_trigger_reserve_get` to process pending get requests. Args: put_event (simpy.Event): The event corresponding to the reservation. item (object): The item to be added to the store. Returns: proceed (bool): True if the put operation succeeded, False otherwise. Raises: RuntimeError: If no reservations are available in the reservations_put RuntimeError: If proceed is False after put operation \"\"\" proceed = False if self . reservations_put : proceed = self . _trigger_put ( put_event , item ) else : raise RuntimeError ( \"No matching reservation found for process: reservations_put is empty\" ) if proceed : #print(f\"{self.env.now} proceed\") #self._trigger_get(None) self . _trigger_reserve_get ( None ) #if the put operation is not successful, then raise an erro if not proceed : raise RuntimeError ( f \"No matching put_event found in the reservations and put failed for { item } \" ) else : self . _update_time_averaged_level () return proceed reserve_get ( priority = 0 ) \u00b6 Create a reservation request to retrieve an item from the store. This method generates a SimPy event representing a request to reserve an item for retrieval ( get ). The event is assigned attributes such as priority, the resource it belongs to, and the process making the request. The event is then added to reserve_get_queue , which is maintained in priority order, and _trigger_reserve_get() is called to process pending reservations if items are available. Parameters: priority ( int , default: 0 ) \u2013 The priority level of the reservation request. Lower values indicate higher priority. Defaults to 0. Returns: event ( Event ) \u2013 A reservation event that will succeed when an item becomes available. Source code in src/factorysimpy/base/reservable_priority_req_store.py 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 def reserve_get ( self , priority = 0 ): \"\"\" Create a reservation request to retrieve an item from the store. This method generates a SimPy event representing a request to reserve an item for retrieval (`get`). The event is assigned attributes such as priority, the resource it belongs to, and the process making the request. The event is then added to `reserve_get_queue`, which is maintained in priority order, and `_trigger_reserve_get()` is called to process pending reservations if items are available. Args: priority (int, optional): The priority level of the reservation request. Lower values indicate higher priority. Defaults to 0. Returns: event (simpy.Event): A reservation event that will succeed when an item becomes available. \"\"\" #adding attributes to the newly created event for reserve_get event = self . env . event () event . resourcename = self event . requesting_process = self . env . active_process # Associate event with the current process #event.priority_to_get = (priority, self._env.now) event . priority_to_get = priority #sorting the list based on priority after appending the new event self . reserve_get_queue . append ( event ) self . reserve_get_queue . sort ( key = lambda e : e . priority_to_get ) self . _trigger_reserve_get ( event ) return event reserve_get_cancel ( get_event_to_cancel ) \u00b6 Cancel a previously made reserve_get request. This method allows a process to cancel its reservation for retrieving an item from the store. If the reservation exists in the reserve_get_queue , it is removed, and _trigger_reserve_get() is called to process any remaining reservations. If the reservation is already in reservations_get , it is removed, and the corresponding item is repositioned in the store to maintain order. _trigger_reserve_get() is then triggered to handle pending reservations. Parameters: get_event_to_cancel ( Event ) \u2013 The reservation event that needs to be canceled. Returns: proceed ( bool ) \u2013 True if the reservation was successfully canceled. Raises: RuntimeError \u2013 If the specified event does not exist in reserve_get_queue or reservations_get . Source code in src/factorysimpy/base/reservable_priority_req_store.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 def reserve_get_cancel ( self , get_event_to_cancel ): \"\"\" Cancel a previously made `reserve_get` request. This method allows a process to cancel its reservation for retrieving an item from the store. If the reservation exists in the `reserve_get_queue`, it is removed, and `_trigger_reserve_get()` is called to process any remaining reservations. If the reservation is already in `reservations_get`, it is removed, and the corresponding item is repositioned in the store to maintain order. `_trigger_reserve_get()` is then triggered to handle pending reservations. Args: get_event_to_cancel (simpy.Event): The reservation event that needs to be canceled. Returns: proceed (bool): True if the reservation was successfully canceled. Raises: RuntimeError: If the specified event does not exist in `reserve_get_queue` or `reservations_get`. \"\"\" proceed = False #checking and removing the event if it is not yielded and is present in the reserve_get_queue if get_event_to_cancel in self . reserve_get_queue : self . reserve_get_queue . remove ( get_event_to_cancel ) self . _trigger_reserve_get ( None ) #if t is removed, then a waiting event can be succeeded, if any proceed = True #checking and removing the event if it is already yielded and is present in the reservations_queue. # 1-to-1 association with items done to preserve item order should also be removed. elif get_event_to_cancel in self . reservations_get : self . reservations_get . remove ( get_event_to_cancel ) #deleting the associated event in the reserved_events list to preserve the order of the items #finding index of the item event_in_index = self . reserved_events . index ( get_event_to_cancel ) delta_position = len ( self . reserved_events ) #shifting the item item_to_shift = self . items . pop ( event_in_index ) self . items . insert ( delta_position - 1 , item_to_shift ) #deleting the event self . reserved_events . pop ( event_in_index ) #if t is removed, then a waiting event can be succeeded, if any self . _trigger_reserve_get ( None ) proceed = True else : raise RuntimeError ( \"No matching event in reserve_get_queue or reservations_get for this process\" ) return proceed reserve_put ( priority = 0 ) \u00b6 Create a reservation request to put an item into the store. This function generates a SimPy event representing a reservation request. The event is assigned attributes such as priority, resource name, and the process making the request. The event is then added to reserve_put_queue , which is maintained in priority order. After adding the event to the queue, _trigger_reserve_put is called to process any pending reservations. Parameters: priority ( int , default: 0 ) \u2013 The priority level of the reservation request. Lower values indicate higher priority. Defaults to 0. Returns: event ( Event ) \u2013 A reservation event that will succeed when space is available. Source code in src/factorysimpy/base/reservable_priority_req_store.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def reserve_put ( self , priority = 0 ): \"\"\" Create a reservation request to put an item into the store. This function generates a SimPy event representing a reservation request. The event is assigned attributes such as priority, resource name, and the process making the request. The event is then added to `reserve_put_queue`, which is maintained in priority order. After adding the event to the queue, `_trigger_reserve_put` is called to process any pending reservations. Args: priority (int, optional): The priority level of the reservation request. Lower values indicate higher priority. Defaults to 0. Returns: event (simpy.Event): A reservation event that will succeed when space is available. \"\"\" event = self . env . event () event . resourcename = self # Store reference event . requesting_process = self . env . active_process # Process making the reservation event . priority_to_put = priority # Priority for sorting reservations # Add the event to the reservation queue and sort by priority self . reserve_put_queue . append ( event ) self . reserve_put_queue . sort ( key = lambda e : e . priority_to_put ) # Attempt to process reservations self . _trigger_reserve_put ( event ) return event reserve_put_cancel ( put_event_to_cancel ) \u00b6 Cancel a previously made reserve_put request. This method allows a process to cancel its reservation for putting an item into the store. If the reservation exists in the reserve_put_queue , it is removed before triggering _trigger_reserve_put to process any pending reservations. If the reservation is already in reservations_put , it is also removed and _trigger_reserve_put is triggered. Parameters: put_event_to_cancel ( Event ) \u2013 The reservation event that needs to be canceled. Returns: proceed ( bool ) \u2013 True if the reservation was successfully canceled. Raises: RuntimeError \u2013 If the specified event does not exist in reserve_put_queue or reservations_put . Source code in src/factorysimpy/base/reservable_priority_req_store.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 def reserve_put_cancel ( self , put_event_to_cancel ): \"\"\" Cancel a previously made `reserve_put` request. This method allows a process to cancel its reservation for putting an item into the store. If the reservation exists in the `reserve_put_queue`, it is removed before triggering `_trigger_reserve_put` to process any pending reservations. If the reservation is already in `reservations_put`, it is also removed and `_trigger_reserve_put` is triggered. Args: put_event_to_cancel (simpy.Event): The reservation event that needs to be canceled. Returns: proceed (bool): True if the reservation was successfully canceled. Raises: RuntimeError: If the specified event does not exist in `reserve_put_queue` or `reservations_put`. \"\"\" #checking and removing the event if it is not yielded and is present in the reserve_put_queue proceed = False if put_event_to_cancel in self . reserve_put_queue : self . reserve_put_queue . remove ( put_event_to_cancel ) self . _trigger_reserve_put ( None ) #if t is removed, then a waiting event can be succeeded, if any proceed = True #checking and removing the event if it is already yielded and is present in the reservations_put elif put_event_to_cancel in self . reservations_put : self . reservations_put . remove ( put_event_to_cancel ) self . _trigger_reserve_put ( None ) #if t is removed, then a waiting event can be succeeded, if any proceed = True else : raise RuntimeError ( \"No matching event in reserve_put_queue or reservations_put for this process\" ) return proceed reservable_req_store \u00b6 ReservableReqStore ( env , capacity = float ( 'inf' )) \u00b6 Bases: Store This is a class that is derived from SimPy's Store class and has extra capabilities that makes it a reservable store for processes to reserve space for storing and retrieving items. Processes can use reserve_put() and reserve_get() methods to get notified when a space becomes available in the store or when an item gets available in the ReservableReqStore. These methods returns a unique event (SimPy.Event) to the process for every reserve requests it makes. get and put are two methods that can be used for item storing and retrieval from ReservableReqStore. Process has to make a prior reservation and pass the associated reservation event as argument in the get and put requests. ReservableReqStore maintains separate queues for reserve_put and reserve_get operations to ensures that only processes with valid reservations can store or retrieve items. ReservableReqStore preserves item order by associating an unreserved item in the store with a reservation event by index when a reserve_get() request is made. As a result, it maintains a list of reserved events to preserve item order. It also allows users to cancel an already placed reserve_get or reserve_put request even if it is yielded. It also handles the dissociation of the event and item done at the time of reservation when an already yielded event is canceled. Attributes: reserved_events ( list ) \u2013 Maintains events corresponding to reserved items to preserve item order by index reserve_put_queue ( list ) \u2013 Queue for managing reserve_put reservations reservations_put ( list ) \u2013 List of successful put reservations reserve_get_queue ( list ) \u2013 Queue for managing reserve_get reservations reservations_get ( list ) \u2013 List of successful get reservations Initializes a reservable store with reservations. Args: capacity (int, optional): The maximum number of items the store can hold. Defaults to infinity. Source code in src/factorysimpy/base/reservable_req_store.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 def __init__ ( self , env , capacity = float ( 'inf' )): \"\"\" Initializes a reservable store with reservations. Args: capacity (int, optional): The maximum number of items the store can hold. Defaults to infinity. \"\"\" super () . __init__ ( env , capacity ) self . env = env self . reserve_put_queue = [] # Queue for managing reserve_put reservations self . reservations_put = [] # List of successful put reservations self . reserve_get_queue = [] # Queue for managing reserve_get reservations self . reservations_get = [] # List of successful get reservations self . reserved_events = [] # Maintains events corresponding to reserved items to preserve item order self . _last_level_change_time = self . env . now self . _last_num_items = 0 self . _weighted_sum = 0.0 self . time_averaged_num_of_items_in_store = 0.0 # Time-averaged number of items in the store get ( get_event ) \u00b6 Retrieve an item from the store after a successful reservation. This method attempts to retrieve an item associated with a reserve_get event. If the reservation exists, it triggers _trigger_get to retrieve the item. If successful, _trigger_reserve_put is called to process any pending reserve_put requests. If the item retrieval fails, an error message is raised. Parameters: get_event ( Event ) \u2013 The reservation event associated with the request. Returns: item ( Object ) \u2013 The retrieved item if successful, otherwise raises an error Raises: RuntimeError \u2013 If no reservations are available in the reservations_get RuntimeError \u2013 If item returned is None Source code in src/factorysimpy/base/reservable_req_store.py 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 def get ( self , get_event ): \"\"\" Retrieve an item from the store after a successful reservation. This method attempts to retrieve an item associated with a `reserve_get` event. If the reservation exists, it triggers `_trigger_get` to retrieve the item. If successful, `_trigger_reserve_put` is called to process any pending `reserve_put` requests. If the item retrieval fails, an error message is raised. Args: get_event (simpy.Event): The reservation event associated with the request. Returns: item (Object): The retrieved item if successful, otherwise raises an error Raises: RuntimeError: If no reservations are available in the reservations_get RuntimeError: If item returned is None \"\"\" item = None #if there are reservations, then call _trigger_get if self . reservations_get : item = self . _trigger_get ( get_event ) #else raise an error else : raise RuntimeError ( \"No matching reservation found for process: reservations_get is empty\" ) #if an item is returned then call _trigger_reserve_put to process pending requests if item is not None : self . _trigger_reserve_put ( None ) if item is None : raise RuntimeError ( f \"No item found in the store for { get_event . requesting_process } and get request failed\" ) else : self . _update_time_averaged_level () return item put ( put_event , item ) \u00b6 Perform a put operation on the store and trigger any pending reserve_get requests. Ensures that only processes with a valid reservation can put items into the store. If the put operation succeeds, it triggers _trigger_reserve_get to process pending get requests. Parameters: put_event ( Event ) \u2013 The event corresponding to the reservation. item ( object ) \u2013 The item to be added to the store. Returns: proceed ( bool ) \u2013 True if the put operation succeeded, False otherwise. Raises: RuntimeError \u2013 If no reservations are available in the reservations_put RuntimeError \u2013 If proceed is False after put operation Source code in src/factorysimpy/base/reservable_req_store.py 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 def put ( self , put_event , item ): \"\"\" Perform a `put` operation on the store and trigger any pending `reserve_get` requests. Ensures that only processes with a valid reservation can put items into the store. If the put operation succeeds, it triggers `_trigger_reserve_get` to process pending get requests. Args: put_event (simpy.Event): The event corresponding to the reservation. item (object): The item to be added to the store. Returns: proceed (bool): True if the put operation succeeded, False otherwise. Raises: RuntimeError: If no reservations are available in the reservations_put RuntimeError: If proceed is False after put operation \"\"\" proceed = False if self . reservations_put : proceed = self . _trigger_put ( put_event , item ) else : raise RuntimeError ( \"No matching reservation found for process: reservations_put is empty\" ) if proceed : #print(f\"{self.env.now} proceed\") #self._trigger_get(None) self . _trigger_reserve_get ( None ) #if the put operation is not successful, then raise an erro if not proceed : raise RuntimeError ( f \"No matching put_event found in the reservations and put failed for { item } \" ) else : self . _update_time_averaged_level () return proceed reserve_get () \u00b6 Create a reservation request to retrieve an item from the store. This method generates a SimPy event representing a request to reserve an item for retrieval ( get ). The event is assigned attributes such as the resource it belongs to, and the process making the request. The event is then added to reserve_get_queue , which is maintained in the order in which it has added, and _trigger_reserve_get() is called to process pending reservations if items are available. Returns: event ( Event ) \u2013 A reservation event that will succeed when an item becomes available. Source code in src/factorysimpy/base/reservable_req_store.py 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 def reserve_get ( self ): \"\"\" Create a reservation request to retrieve an item from the store. This method generates a SimPy event representing a request to reserve an item for retrieval (`get`). The event is assigned attributes such as the resource it belongs to, and the process making the request. The event is then added to `reserve_get_queue`, which is maintained in the order in which it has added, and `_trigger_reserve_get()` is called to process pending reservations if items are available. Returns: event (simpy.Event): A reservation event that will succeed when an item becomes available. \"\"\" #adding attributes to the newly created event for reserve_get event = self . env . event () event . resourcename = self event . requesting_process = self . env . active_process # Associate event with the current process self . reserve_get_queue . append ( event ) self . _trigger_reserve_get ( event ) return event reserve_get_cancel ( get_event_to_cancel ) \u00b6 Cancel a previously made reserve_get request. This method allows a process to cancel its reservation for retrieving an item from the store. If the reservation exists in the reserve_get_queue , it is removed, and _trigger_reserve_get() is called to process any remaining reservations. If the reservation is already in reservations_get , it is removed, and the corresponding item is repositioned in the store to maintain order. _trigger_reserve_get() is then triggered to handle pending reservations. Parameters: get_event_to_cancel ( Event ) \u2013 The reservation event that needs to be canceled. Returns: proceed ( bool ) \u2013 True if the reservation was successfully canceled. Raises: RuntimeError \u2013 If the specified event does not exist in reserve_get_queue or reservations_get . Source code in src/factorysimpy/base/reservable_req_store.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 def reserve_get_cancel ( self , get_event_to_cancel ): \"\"\" Cancel a previously made `reserve_get` request. This method allows a process to cancel its reservation for retrieving an item from the store. If the reservation exists in the `reserve_get_queue`, it is removed, and `_trigger_reserve_get()` is called to process any remaining reservations. If the reservation is already in `reservations_get`, it is removed, and the corresponding item is repositioned in the store to maintain order. `_trigger_reserve_get()` is then triggered to handle pending reservations. Args: get_event_to_cancel (simpy.Event): The reservation event that needs to be canceled. Returns: proceed (bool): True if the reservation was successfully canceled. Raises: RuntimeError: If the specified event does not exist in `reserve_get_queue` or `reservations_get`. \"\"\" proceed = False #checking and removing the event if it is not yielded and is present in the reserve_get_queue if get_event_to_cancel in self . reserve_get_queue : self . reserve_get_queue . remove ( get_event_to_cancel ) self . _trigger_reserve_get ( None ) #if t is removed, then a waiting event can be succeeded, if any proceed = True #checking and removing the event if it is already yielded and is present in the reservations_queue. # 1-to-1 association with items done to preserve item order should also be removed. elif get_event_to_cancel in self . reservations_get : self . reservations_get . remove ( get_event_to_cancel ) #deleting the associated event in the reserved_events list to preserve the order of the items #finding index of the item event_in_index = self . reserved_events . index ( get_event_to_cancel ) delta_position = len ( self . reserved_events ) #shifting the item item_to_shift = self . items . pop ( event_in_index ) self . items . insert ( delta_position - 1 , item_to_shift ) #deleting the event self . reserved_events . pop ( event_in_index ) #if t is removed, then a waiting event can be succeeded, if any self . _trigger_reserve_get ( None ) proceed = True else : raise RuntimeError ( \"No matching event in reserve_get_queue or reservations_get for this process\" ) return proceed reserve_put () \u00b6 Create a reservation request to put an item into the store. This function generates a SimPy event representing a reservation request. The event is assigned attributes such as the resource name, and the process making the request. The event is then added to reserve_put_queue , which is maintained in the order in which the request has come. After adding the event to the queue, _trigger_reserve_put is called to process any pending reservations. Returns: event ( Event ) \u2013 A reservation event that will succeed when space is available. Source code in src/factorysimpy/base/reservable_req_store.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def reserve_put ( self ): \"\"\" Create a reservation request to put an item into the store. This function generates a SimPy event representing a reservation request. The event is assigned attributes such as the resource name, and the process making the request. The event is then added to `reserve_put_queue`, which is maintained in the order in which the request has come. After adding the event to the queue, `_trigger_reserve_put` is called to process any pending reservations. Returns: event (simpy.Event): A reservation event that will succeed when space is available. \"\"\" event = self . env . event () event . resourcename = self # Store reference event . requesting_process = self . env . active_process # Process making the reservation self . reserve_put_queue . append ( event ) # Attempt to process reservations self . _trigger_reserve_put ( event ) return event reserve_put_cancel ( put_event_to_cancel ) \u00b6 Cancel a previously made reserve_put request. This method allows a process to cancel its reservation for putting an item into the store. If the reservation exists in the reserve_put_queue , it is removed before triggering _trigger_reserve_put to process any pending reservations. If the reservation is already in reservations_put , it is also removed and _trigger_reserve_put is triggered. Parameters: put_event_to_cancel ( Event ) \u2013 The reservation event that needs to be canceled. Returns: proceed ( bool ) \u2013 True if the reservation was successfully canceled. Raises: RuntimeError \u2013 If the specified event does not exist in reserve_put_queue or reservations_put . Source code in src/factorysimpy/base/reservable_req_store.py 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 def reserve_put_cancel ( self , put_event_to_cancel ): \"\"\" Cancel a previously made `reserve_put` request. This method allows a process to cancel its reservation for putting an item into the store. If the reservation exists in the `reserve_put_queue`, it is removed before triggering `_trigger_reserve_put` to process any pending reservations. If the reservation is already in `reservations_put`, it is also removed and `_trigger_reserve_put` is triggered. Args: put_event_to_cancel (simpy.Event): The reservation event that needs to be canceled. Returns: proceed (bool): True if the reservation was successfully canceled. Raises: RuntimeError: If the specified event does not exist in `reserve_put_queue` or `reservations_put`. \"\"\" #checking and removing the event if it is not yielded and is present in the reserve_put_queue proceed = False if put_event_to_cancel in self . reserve_put_queue : self . reserve_put_queue . remove ( put_event_to_cancel ) self . _trigger_reserve_put ( None ) #if t is removed, then a waiting event can be succeeded, if any proceed = True #checking and removing the event if it is already yielded and is present in the reservations_put elif put_event_to_cancel in self . reservations_put : self . reservations_put . remove ( put_event_to_cancel ) self . _trigger_reserve_put ( None ) #if t is removed, then a waiting event can be succeeded, if any proceed = True else : raise RuntimeError ( \"No matching event in reserve_put_queue or reservations_put for this process\" ) return proceed slotted_belt_store \u00b6 BeltStore ( env , capacity = float ( 'inf' ), mode = 'FIFO' , delay = 1 ) \u00b6 Bases: Store This is a class that is derived from SimPy's Store class and has extra capabilities that makes it a priority-based reservable store for processes to reserve space for storing and retrieving items with priority-based access. Processes can use reserve_put() and reserve_get() methods to get notified when a space becomes available in the store or when an item gets available in the ReservablePriorityReqStore. These methods returns a unique event (SimPy.Event) to the process for every reserve requests it makes. Processes can also pass a priority as argument in the request. Lower values indicate higher priority. get and put are two methods that can be used for item storing and retrieval from ReservablePriorityReqStore. Process has to make a prior reservation and pass the associated reservation event as argument in the get and put requests. ReservablePriorityReqStore maintains separate queues for reserve_put and reserve_get operations to ensures that only processes with valid reservations can store or retrieve items. ReservablePriorityReqStore preserves item order by associating an unreserved item in the store with a reservation event by index when a reserve_get() request is made. As a result, it maintains a list of reserved events to preserve item order. It also allows users to cancel an already placed reserve_get or reserve_put request even if it is yielded. It also handles the dissociation of the event and item done at the time of reservation when an already yielded event is canceled. Attributes: reserved_events ( list ) \u2013 Maintains events corresponding to reserved items to preserve item order by index reserve_put_queue ( list ) \u2013 Queue for managing reserve_put reservations reservations_put ( list ) \u2013 List of successful put reservations reserve_get_queue ( list ) \u2013 Queue for managing reserve_get reservations reservations_get ( list ) \u2013 List of successful get reservations Initializes a reservable store with priority-based reservations. Args: capacity (int, optional): The maximum number of items the store can hold. Defaults to infinity. Source code in src/factorysimpy/base/slotted_belt_store.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def __init__ ( self , env , capacity = float ( 'inf' ), mode = 'FIFO' , delay = 1 ): \"\"\" Initializes a reservable store with priority-based reservations. Args: capacity (int, optional): The maximum number of items the store can hold. Defaults to infinity. \"\"\" super () . __init__ ( env , capacity ) self . env = env self . mode = mode self . delay = delay # Speed of the conveyor belt (units per time) self . reserve_put_queue = [] # Queue for managing reserve_put reservations self . reservations_put = [] # List of successful put reservations self . reserve_get_queue = [] # Queue for managing reserve_get reservations self . reservations_get = [] # List of successful get reservations self . reserved_events = [] # Maintains events corresponding to reserved items to preserve item order self . ready_items = [] #Maintains the items ready to be taken out self . reserved_items = [] # parallel list of the exact items reserved self . _last_level_change_time = self . env . now self . _last_num_items = 0 self . _weighted_sum = 0.0 self . time_averaged_num_of_items_in_store = 0.0 # Time-averaged number of items in the store # Process tracking for interrupt functionality self . active_move_processes = {} # Dictionary to track active move_to_ready_items processes self . resume_event = self . env . event () # Event to signal when to resume processes self . noaccumulation_mode_on = False # to control if the belt is in noaccumulation mode self . one_item_inserted = False # to control insertion of only one item in noaccumulation mode self . ready_item_event = self . env . event () get ( get_event ) \u00b6 Retrieve an item from the store after a successful reservation. This method attempts to retrieve an item associated with a reserve_get event. If the reservation exists, it triggers _trigger_get to retrieve the item. If successful, _trigger_reserve_put is called to process any pending reserve_put requests. If the item retrieval fails, an error message is raised. Parameters: get_event ( Event ) \u2013 The reservation event associated with the request. Returns: item ( Object ) \u2013 The retrieved item if successful, otherwise raises an error Raises: RuntimeError \u2013 If no reservations are available in the reservations_get RuntimeError \u2013 If item returned is None Source code in src/factorysimpy/base/slotted_belt_store.py 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 def get ( self , get_event ): \"\"\" Retrieve an item from the store after a successful reservation. This method attempts to retrieve an item associated with a `reserve_get` event. If the reservation exists, it triggers `_trigger_get` to retrieve the item. If successful, `_trigger_reserve_put` is called to process any pending `reserve_put` requests. If the item retrieval fails, an error message is raised. Args: get_event (simpy.Event): The reservation event associated with the request. Returns: item (Object): The retrieved item if successful, otherwise raises an error Raises: RuntimeError: If no reservations are available in the reservations_get RuntimeError: If item returned is None \"\"\" item = None #if there are reservations, then call _trigger_get if self . reservations_get : item = self . _trigger_get ( get_event ) #else raise an error else : raise RuntimeError ( \"No matching reservation found for process: reservations_get is empty\" ) #if an item is returned then call _trigger_reserve_put to process pending requests if item is not None : self . _trigger_reserve_put ( None ) if item is None : raise RuntimeError ( f \"No item found in the store for { get_event . requesting_process } and get request failed\" ) else : #self._update_time_averaged_level() return item handle_new_item_during_interruption ( item ) \u00b6 Handle new items arriving during selective interruption. For new items, the delay before interruption is: capacity - num_items Parameters: item \u2013 The new item being added Source code in src/factorysimpy/base/slotted_belt_store.py 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 def handle_new_item_during_interruption ( self , item ): \"\"\" Handle new items arriving during selective interruption. For new items, the delay before interruption is: capacity - num_items Args: item: The new item being added \"\"\" if self . noaccumulation_mode_on : num_items = len ( self . items ) + len ( self . ready_items ) delay_before_interrupt = max ( self . capacity - num_items , 0 ) item_id = item [ 0 ] . id if hasattr ( item [ 0 ], 'id' ) else str ( id ( item )) if delay_before_interrupt > 0 : print ( f \"T= { self . env . now : .2f } New item { item_id } will be interrupted after { delay_before_interrupt } time units\" ) self . env . process ( self . _delayed_interrupt ( item_id , delay_before_interrupt , \"New item during interruption\" )) else : print ( f \"T= { self . env . now : .2f } New item { item_id } interrupted immediately\" ) self . _interrupt_specific_item ( item_id , \"New item during interruption\" ) interrupt_all_move_processes ( reason = 'External interrupt' ) \u00b6 Interrupt all active move_to_ready_items processes. Parameters: reason ( str , default: 'External interrupt' ) \u2013 Reason for the interrupt Source code in src/factorysimpy/base/slotted_belt_store.py 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 def interrupt_all_move_processes ( self , reason = \"External interrupt\" ): \"\"\" Interrupt all active move_to_ready_items processes. Args: reason (str): Reason for the interrupt \"\"\" print ( f \"T= { self . env . now : .2f } BufferStore interrupting { len ( self . active_move_processes ) } move processes - { reason } \" ) for item_id , process_info in self . active_move_processes . items (): process = process_info [ 'process' ] if process and not process . processed : try : process . interrupt ( reason ) print ( f \"T= { self . env . now : .2f } Interrupted move process for item { item_id } \" ) except RuntimeError : # Process might already be finished pass move_to_ready_items ( item ) \u00b6 Move items from the store to the ready_items list after a put operation. This method is called as a process to ensure that items are moved asynchronously. Handles interrupts when state changes to stalled and resumes when state changes back. Movement is split into two phases: 1. First phase: item[0].length/self.speed time (time for item to fully enter belt) 2. Second phase: remaining time (time for item to reach exit) Source code in src/factorysimpy/base/slotted_belt_store.py 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 def move_to_ready_items ( self , item ): \"\"\" Move items from the store to the ready_items list after a put operation. This method is called as a process to ensure that items are moved asynchronously. Handles interrupts when state changes to stalled and resumes when state changes back. Movement is split into two phases: 1. First phase: item[0].length/self.speed time (time for item to fully enter belt) 2. Second phase: remaining time (time for item to reach exit) \"\"\" item_id = item [ 0 ] . id if hasattr ( item [ 0 ], 'id' ) else str ( id ( item )) event = self . env . event () #self.delay=self.delay #print(f\"created Added event suceeded{self.delay}\") event . callbacks . append ( self . _trigger_reserve_put ) # after putting an item, an event is created and will be triggered ater delay amount of time to allow waiting get calls to succeed in a stalled belt #event.callbacks.append(self._trigger_put)# this may not be needed #print(f\"{self.env.now}Added event suceed ed\") # Calculate the two phases of movement phase1_time = self . delay # Time for item to fully enter belt phase2_time = item [ 1 ] - phase1_time # Remaining time to reach exit try : # Move items to the ready_items list if self . items : print ( f \"T= { self . env . now : .2f } beltstore received an item { item [ 0 ] . id , item [ 1 ] } . Item started moving in belt\" ) # Phase 1: Item entering the belt (length/speed time) remaining_phase1_time = phase1_time print ( f \"T= { self . env . now : .2f } Item { item_id } starting Phase 1 (entering belt): { phase1_time : .2f } time\" ) while remaining_phase1_time > 0 : try : start_time = self . env . now yield self . env . timeout ( remaining_phase1_time ) # If we reach here, phase 1 completed without interruption event . succeed () remaining_phase1_time = 0 break except simpy . Interrupt as interrupt : # Calculate how much time has passed elapsed_time = self . env . now - start_time remaining_phase1_time -= elapsed_time print ( f \"T= { self . env . now : .2f } Move process Phase 1 for item { item_id } interrupted: { interrupt . cause } \" ) print ( f \"T= { self . env . now : .2f } Remaining Phase 1 time for item { item_id } : { remaining_phase1_time : .2f } \" ) # Wait for resume signal print ( f \"T= { self . env . now : .2f } Item { item_id } waiting for resume signal (Phase 1)...\" ) yield self . resume_event print ( f \"T= { self . env . now : .2f } Item { item_id } resuming Phase 1 movement with { remaining_phase1_time : .2f } time remaining\" ) print ( f \"T= { self . env . now : .2f } Item { item_id } completed Phase 1 (fully entered belt)\" ) # Phase 2: Item moving through the belt to exit remaining_phase2_time = phase2_time print ( f \"T= { self . env . now : .2f } Item { item_id } starting Phase 2 (moving to exit): { phase2_time : .2f } time\" ) while remaining_phase2_time > 0 : try : start_time = self . env . now yield self . env . timeout ( remaining_phase2_time ) # If we reach here, phase 2 completed without interruption remaining_phase2_time = 0 break except simpy . Interrupt as interrupt : # Calculate how much time has passed elapsed_time = self . env . now - start_time remaining_phase2_time -= elapsed_time print ( f \"T= { self . env . now : .2f } Move process Phase 2 for item { item_id } interrupted: { interrupt . cause } \" ) print ( f \"T= { self . env . now : .2f } Remaining Phase 2 time for item { item_id } : { remaining_phase2_time : .2f } \" ) # Wait for resume signal print ( f \"T= { self . env . now : .2f } Item { item_id } waiting for resume signal (Phase 2)...\" ) yield self . resume_event print ( f \"T= { self . env . now : .2f } Item { item_id } resuming Phase 2 movement with { remaining_phase2_time : .2f } time remaining\" ) print ( f \"T= { self . env . now : .2f } Item { item_id } completed Phase 2 (reached exit)\" ) print ( f \"T= { self . env . now : .2f } bufferstore finished moving item { item [ 0 ] . id , item [ 1 ] } going to ready_items\" ) item_index = self . items . index ( item ) item_to_put = self . items . pop ( item_index ) # Remove the item if len ( self . ready_items ) + len ( self . items ) < self . capacity : self . ready_items . append ( item_to_put [ 0 ]) if not self . ready_item_event . triggered : self . ready_item_event . succeed () # Notify that a new item is ready print ( f \"T= { self . env . now : .2f } bufferstore finished moving item { item [ 0 ] . id , item [ 1 ] } moved to ready_items\" ) self . _trigger_reserve_get ( None ) self . _trigger_reserve_put ( None ) else : raise RuntimeError ( \"Total number of items in the store exceeds capacity. Cannot move item to ready_items.\" ) finally : # Clean up the process tracking when done if item_id in self . active_move_processes : del self . active_move_processes [ item_id ] print ( f \"T= { self . env . now : .2f } Removed tracking for completed move process of item { item_id } \" ) put ( put_event , item ) \u00b6 Perform a put operation on the store and trigger any pending reserve_get requests. Ensures that only processes with a valid reservation can put items into the store. If the put operation succeeds, it triggers _trigger_reserve_get to process pending get requests. Parameters: put_event ( Event ) \u2013 The event corresponding to the reservation. item ( object ) \u2013 The item to be added to the store. Returns: proceed ( bool ) \u2013 True if the put operation succeeded, False otherwise. Raises: RuntimeError \u2013 If no reservations are available in the reservations_put RuntimeError \u2013 If proceed is False after put operation Source code in src/factorysimpy/base/slotted_belt_store.py 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 def put ( self , put_event , item ): \"\"\" Perform a `put` operation on the store and trigger any pending `reserve_get` requests. Ensures that only processes with a valid reservation can put items into the store. If the put operation succeeds, it triggers `_trigger_reserve_get` to process pending get requests. Args: put_event (simpy.Event): The event corresponding to the reservation. item (object): The item to be added to the store. Returns: proceed (bool): True if the put operation succeeded, False otherwise. Raises: RuntimeError: If no reservations are available in the reservations_put RuntimeError: If proceed is False after put operation \"\"\" proceed = False if self . reservations_put : proceed = self . _trigger_put ( put_event , item ) else : raise RuntimeError ( \"No matching reservation found for process: reservations_put is empty\" ) if proceed : #print(f\"{self.env.now} proceed\") #self._trigger_get(None) self . _trigger_reserve_get ( None ) if not proceed : raise RuntimeError ( f \"No matching put_event found in the reservations and put failed for { item } \" ) else : #self._update_time_averaged_level() return proceed reserve_get ( priority = 0 ) \u00b6 Create a reservation request to retrieve an item from the store. This method generates a SimPy event representing a request to reserve an item for retrieval ( get ). The event is assigned attributes such as priority, the resource it belongs to, and the process making the request. The event is then added to reserve_get_queue , which is maintained in priority order, and _trigger_reserve_get() is called to process pending reservations if items are available. Parameters: priority ( int , default: 0 ) \u2013 The priority level of the reservation request. Lower values indicate higher priority. Defaults to 0. Returns: event ( Event ) \u2013 A reservation event that will succeed when an item becomes available. Source code in src/factorysimpy/base/slotted_belt_store.py 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 def reserve_get ( self , priority = 0 ): \"\"\" Create a reservation request to retrieve an item from the store. This method generates a SimPy event representing a request to reserve an item for retrieval (`get`). The event is assigned attributes such as priority, the resource it belongs to, and the process making the request. The event is then added to `reserve_get_queue`, which is maintained in priority order, and `_trigger_reserve_get()` is called to process pending reservations if items are available. Args: priority (int, optional): The priority level of the reservation request. Lower values indicate higher priority. Defaults to 0. Returns: event (simpy.Event): A reservation event that will succeed when an item becomes available. \"\"\" #adding attributes to the newly created event for reserve_get event = self . env . event () event . resourcename = self event . requesting_process = self . env . active_process # Associate event with the current process #event.priority_to_get = (priority, self._env.now) event . priority_to_get = priority #sorting the list based on priority after appending the new event self . reserve_get_queue . append ( event ) self . reserve_get_queue . sort ( key = lambda e : e . priority_to_get ) self . _trigger_reserve_get ( event ) return event reserve_get_cancel ( get_event_to_cancel ) \u00b6 Cancel a previously made reserve_get request. Source code in src/factorysimpy/base/slotted_belt_store.py 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 def reserve_get_cancel ( self , get_event_to_cancel ): \"\"\" Cancel a previously made `reserve_get` request. \"\"\" # Case 1: still waiting if get_event_to_cancel in self . reserve_get_queue : self . reserve_get_queue . remove ( get_event_to_cancel ) self . _trigger_reserve_get ( None ) return True # Case 2: already yielded reservation if get_event_to_cancel in self . reservations_get : # 1) Remove from active reservations self . reservations_get . remove ( get_event_to_cancel ) # 2) Find its index in the parallel lists ev_idx = self . reserved_events . index ( get_event_to_cancel ) # 3) Pop out the exact item reference item = self . reserved_items . pop ( ev_idx ) # 4) Drop the event token self . reserved_events . pop ( ev_idx ) # 5) Remove it from ready_items wherever it currently is try : self . ready_items . remove ( item ) except ValueError : raise RuntimeError ( f \"Item { item !r} not found in ready_items during cancel.\" ) # 6) Compute new insertion index if self . mode == \"FIFO\" : # one slot before the remaining reserved block insert_idx = len ( self . ready_items ) - len ( self . reserved_events ) - 1 else : # LIFO # top of stack insert_idx = len ( self . ready_items ) # 7) Re\u2011insert it self . ready_items . insert ( insert_idx , item ) # 8) Trigger any other pending reservations self . _trigger_reserve_get ( None ) return True # No such reservation raise RuntimeError ( \"No matching event in reserve_get_queue or reservations_get\" ) reserve_put ( priority = 0 ) \u00b6 Create a reservation request to put an item into the store. This function generates a SimPy event representing a reservation request. The event is assigned attributes such as priority, resource name, and the process making the request. The event is then added to reserve_put_queue , which is maintained in priority order. After adding the event to the queue, _trigger_reserve_put is called to process any pending reservations. Parameters: priority ( int , default: 0 ) \u2013 The priority level of the reservation request. Lower values indicate higher priority. Defaults to 0. Returns: event ( Event ) \u2013 A reservation event that will succeed when space is available. Source code in src/factorysimpy/base/slotted_belt_store.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def reserve_put ( self , priority = 0 ): \"\"\" Create a reservation request to put an item into the store. This function generates a SimPy event representing a reservation request. The event is assigned attributes such as priority, resource name, and the process making the request. The event is then added to `reserve_put_queue`, which is maintained in priority order. After adding the event to the queue, `_trigger_reserve_put` is called to process any pending reservations. Args: priority (int, optional): The priority level of the reservation request. Lower values indicate higher priority. Defaults to 0. Returns: event (simpy.Event): A reservation event that will succeed when space is available. \"\"\" event = self . env . event () event . resourcename = self # Store reference event . requesting_process = self . env . active_process # Process making the reservation event . priority_to_put = priority # Priority for sorting reservations # Add the event to the reservation queue and sort by priority self . reserve_put_queue . append ( event ) self . reserve_put_queue . sort ( key = lambda e : e . priority_to_put ) # Attempt to process reservations self . _trigger_reserve_put ( event ) return event reserve_put_cancel ( put_event_to_cancel ) \u00b6 Cancel a previously made reserve_put request. This method allows a process to cancel its reservation for putting an item into the store. If the reservation exists in the reserve_put_queue , it is removed before triggering _trigger_reserve_put to process any pending reservations. If the reservation is already in reservations_put , it is also removed and _trigger_reserve_put is triggered. Parameters: put_event_to_cancel ( Event ) \u2013 The reservation event that needs to be canceled. Returns: proceed ( bool ) \u2013 True if the reservation was successfully canceled. Raises: RuntimeError \u2013 If the specified event does not exist in reserve_put_queue or reservations_put . Source code in src/factorysimpy/base/slotted_belt_store.py 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 def reserve_put_cancel ( self , put_event_to_cancel ): \"\"\" Cancel a previously made `reserve_put` request. This method allows a process to cancel its reservation for putting an item into the store. If the reservation exists in the `reserve_put_queue`, it is removed before triggering `_trigger_reserve_put` to process any pending reservations. If the reservation is already in `reservations_put`, it is also removed and `_trigger_reserve_put` is triggered. Args: put_event_to_cancel (simpy.Event): The reservation event that needs to be canceled. Returns: proceed (bool): True if the reservation was successfully canceled. Raises: RuntimeError: If the specified event does not exist in `reserve_put_queue` or `reservations_put`. \"\"\" #checking and removing the event if it is not yielded and is present in the reserve_put_queue proceed = False if put_event_to_cancel in self . reserve_put_queue : self . reserve_put_queue . remove ( put_event_to_cancel ) self . _trigger_reserve_put ( None ) #if t is removed, then a waiting event can be succeeded, if any proceed = True #checking and removing the event if it is already yielded and is present in the reservations_put elif put_event_to_cancel in self . reservations_put : self . reservations_put . remove ( put_event_to_cancel ) self . _trigger_reserve_put ( None ) #if t is removed, then a waiting event can be succeeded, if any proceed = True else : raise RuntimeError ( \"No matching event in reserve_put_queue or reservations_put for this process\" ) return proceed resume_all_move_processes () \u00b6 Resume all interrupted move_to_ready_items processes. Source code in src/factorysimpy/base/slotted_belt_store.py 731 732 733 734 735 736 737 738 739 740 def resume_all_move_processes ( self ): \"\"\" Resume all interrupted move_to_ready_items processes. \"\"\" print ( f \"T= { self . env . now : .2f } BufferStore resuming move processes\" ) # Create a new resume event and trigger it old_resume_event = self . resume_event self . resume_event = self . env . event () old_resume_event . succeed () selective_interrupt ( reason = 'Selective interrupt' ) \u00b6 Perform selective interruption based on belt occupancy patterns and mode. When noaccumulation_mode_on=True (STALLED_NONACCUMULATING_STATE): - Interrupt all items immediately When noaccumulation_mode_on=False (STALLED_ACCUMULATING_STATE): - Use pattern-based interruption with delays based on item positions Pattern-based rules for accumulating mode: - For patterns like '_ *', interrupt all items. - For patterns like '_ _ _', interrupt item in second last position after 1 delay, and second item after 2 delays. - For patterns like ' ___*', interrupt first item and second item after 3 delays. - For patterns like ' __*', interrupt first item, second after 2 delays, and third after 2 delays. Parameters: reason ( str , default: 'Selective interrupt' ) \u2013 Reason for the interrupt Source code in src/factorysimpy/base/slotted_belt_store.py 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 def selective_interrupt ( self , reason = \"Selective interrupt\" ): \"\"\" Perform selective interruption based on belt occupancy patterns and mode. When noaccumulation_mode_on=True (STALLED_NONACCUMULATING_STATE): - Interrupt all items immediately When noaccumulation_mode_on=False (STALLED_ACCUMULATING_STATE): - Use pattern-based interruption with delays based on item positions Pattern-based rules for accumulating mode: - For patterns like '_****', interrupt all items. - For patterns like '_*_*_', interrupt item in second last position after 1 delay, and second item after 2 delays. - For patterns like '*___*', interrupt first item and second item after 3 delays. - For patterns like '**__*', interrupt first item, second after 2 delays, and third after 2 delays. Args: reason (str): Reason for the interrupt \"\"\" if not self . items : print ( f \"T= { self . env . now : .2f } No items on belt to interrupt\" ) return # If noaccumulation_mode_on is True (STALLED_NONACCUMULATING_STATE), interrupt all items immediately if self . noaccumulation_mode_on : print ( f \"T= { self . env . now : .2f } No accumulation mode: interrupting all items immediately\" ) for i , item in enumerate ( self . items ): item_id = item [ 0 ] . id if hasattr ( item [ 0 ], 'id' ) else str ( id ( item )) self . _interrupt_specific_item ( item_id , f \" { reason } - immediate (no accumulation)\" ) return # For accumulating mode (STALLED_ACCUMULATING_STATE), use pattern-based interruption print ( f \"T= { self . env . now : .2f } Accumulating mode: using pattern-based interruption\" ) # Get current belt pattern pattern = self . _get_belt_pattern () print ( f \"T= { self . env . now : .2f } Current belt pattern: { pattern } \" ) # Analyze pattern and determine interruption strategy interruption_plan = self . _analyze_pattern_for_interruption ( pattern ) if not interruption_plan : print ( f \"T= { self . env . now : .2f } No interruption needed for current pattern\" ) return print ( f \"T= { self . env . now : .2f } Executing selective interruption plan: { interruption_plan } \" ) # Execute the interruption plan self . _execute_interruption_plan ( interruption_plan , reason ) constructs \u00b6 chain \u00b6 connect_nodes_with_buffers ( machines , buffers , src , sink ) \u00b6 Connects source, machines, buffers, and optionally a sink in the following order: src -> buffer1 -> machine1 -> buffer2 -> machine2 -> ... -> bufferN -> sink Parameters: src \u2013 Source node machines \u2013 List of machine nodes buffers \u2013 List of buffer edges (should be len(machines) - 1) inlcuding source and sink sink \u2013 Optional sink node Returns: \u2013 List of all nodes and buffers in connection order Source code in src/factorysimpy/constructs/chain.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def connect_nodes_with_buffers ( machines , buffers , src , sink ): \"\"\" Connects source, machines, buffers, and optionally a sink in the following order: src -> buffer1 -> machine1 -> buffer2 -> machine2 -> ... -> bufferN -> sink Args: src: Source node machines: List of machine nodes buffers: List of buffer edges (should be len(machines) - 1) inlcuding source and sink sink: Optional sink node Returns: List of all nodes and buffers in connection order \"\"\" assert len ( buffers ) == len ( machines ) - 1 , \"Number of buffers must be one more than number of machines\" # Connect intermediate machines and buffers for i in range ( 1 , len ( machines )): buffers [ i - 1 ] . connect ( machines [ i - 1 ], machines [ i ]) # Return all nodes and buffers for reference return machines , buffers mesh \u00b6 connect_mesh ( env , rows , cols , node_cls , edge_cls , node_kwargs = None , edge_kwargs = None , node_kwargs_grid = None , edge_kwargs_grid = None , prefix = 'M' , edge_prefix = 'B' , source_cls = None , sink_cls = None , source_kwargs = None , sink_kwargs = None ) \u00b6 Builds a mesh/grid of nodes connected with buffers. Each node is connected to its right and down neighbor. Returns: mesh_nodes \u2013 2D list of nodes (rows x cols) edge_dict \u2013 dict of buffers by (from_node.id, to_node.id) Source code in src/factorysimpy/constructs/mesh.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def connect_mesh ( env , rows , cols , node_cls , edge_cls , node_kwargs = None , edge_kwargs = None , node_kwargs_grid = None , edge_kwargs_grid = None , prefix = \"M\" , edge_prefix = \"B\" , source_cls = None , sink_cls = None , source_kwargs = None , sink_kwargs = None ): \"\"\" Builds a mesh/grid of nodes connected with buffers. Each node is connected to its right and down neighbor. Returns: mesh_nodes: 2D list of nodes (rows x cols) edge_dict: dict of buffers by (from_node.id, to_node.id) \"\"\" node_kwargs = node_kwargs or {} edge_kwargs = edge_kwargs or {} mesh_nodes = [] edge_dict = {} def get_kwargs ( grid , r , c , default ): if grid and r < len ( grid ) and c < len ( grid [ r ]): return grid [ r ][ c ] return default # Create nodes (machines) for r in range ( rows ): row = [] for c in range ( cols ): kwargs = get_kwargs ( node_kwargs_grid , r , c , node_kwargs ) node_id = f \" { prefix } _ { r + 1 } _ { c + 1 } \" node = node_cls ( env = env , id = node_id , ** kwargs ) row . append ( node ) mesh_nodes . append ( row ) # Helper to create and connect edges def create_edge ( from_node , to_node , r , c ): kwargs = get_kwargs ( edge_kwargs_grid , r , c , edge_kwargs ) edge_id = f \" { edge_prefix } _ { from_node . id } _ { to_node . id } \" edge = edge_cls ( env = env , id = edge_id , ** kwargs ) edge . connect ( from_node , to_node ) edge_dict [( from_node . id , to_node . id )] = edge # Create buffers (edges) to right and down for r in range ( rows ): for c in range ( cols ): from_node = mesh_nodes [ r ][ c ] if c + 1 < cols : create_edge ( from_node , mesh_nodes [ r ][ c + 1 ], r , c ) if r + 1 < rows : create_edge ( from_node , mesh_nodes [ r + 1 ][ c ], r , c ) return mesh_nodes , edge_dict connect_mesh_with_source_sink ( env , rows , cols , node_cls , edge_cls , node_kwargs = None , edge_kwargs = None , node_kwargs_grid = None , edge_kwargs_grid = None , prefix = 'M' , edge_prefix = 'B' , source_cls = None , sink_cls = None , source_kwargs = None , sink_kwargs = None ) \u00b6 Builds a mesh/grid of nodes connected with buffers. Source sends to first row, Sink collects from last row. Returns: mesh_nodes \u2013 2D list of nodes (rows x cols) edge_dict \u2013 dict of buffers by (from_node.id, to_node.id) \u2013 source, sink: optional Source code in src/factorysimpy/constructs/mesh.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 def connect_mesh_with_source_sink ( env , rows , cols , node_cls , edge_cls , node_kwargs = None , edge_kwargs = None , node_kwargs_grid = None , edge_kwargs_grid = None , prefix = \"M\" , edge_prefix = \"B\" , source_cls = None , sink_cls = None , source_kwargs = None , sink_kwargs = None ): \"\"\" Builds a mesh/grid of nodes connected with buffers. Source sends to first row, Sink collects from last row. Returns: mesh_nodes: 2D list of nodes (rows x cols) edge_dict: dict of buffers by (from_node.id, to_node.id) source, sink: optional \"\"\" node_kwargs = node_kwargs or {} edge_kwargs = edge_kwargs or {} source_kwargs = source_kwargs or {} sink_kwargs = sink_kwargs or {} mesh_nodes = [] edge_dict = {} # Create nodes (machines) for r in range ( rows ): row = [] for c in range ( cols ): kwargs = node_kwargs_grid [ r ][ c ] if node_kwargs_grid else node_kwargs node_id = f \" { prefix } _ { r + 1 } _ { c + 1 } \" node = node_cls ( env = env , id = node_id , ** kwargs ) row . append ( node ) mesh_nodes . append ( row ) # Create buffers (edges) to right and down for r in range ( rows ): for c in range ( cols ): from_node = mesh_nodes [ r ][ c ] # Connect right if c + 1 < cols : to_node = mesh_nodes [ r ][ c + 1 ] edge_id = f \" { edge_prefix } _ { from_node . id } _ { to_node . id } \" kwargs = edge_kwargs_grid [ r ][ c ] if edge_kwargs_grid else edge_kwargs edge = edge_cls ( env = env , id = edge_id , ** kwargs ) edge . connect ( from_node , to_node ) edge_dict [( from_node . id , to_node . id )] = edge # Connect down if r + 1 < rows : to_node = mesh_nodes [ r + 1 ][ c ] edge_id = f \" { edge_prefix } _ { from_node . id } _ { to_node . id } \" kwargs = edge_kwargs_grid [ r ][ c ] if edge_kwargs_grid else edge_kwargs edge = edge_cls ( env = env , id = edge_id , ** kwargs ) edge . connect ( from_node , to_node ) edge_dict [( from_node . id , to_node . id )] = edge # Optional source source = None if source_cls : source = source_cls ( env = env , id = \"Source\" , ** source_kwargs ) for c in range ( cols ): to_node = mesh_nodes [ 0 ][ c ] edge_id = f \" { edge_prefix } _SRC_ { to_node . id } \" edge = edge_cls ( env = env , id = edge_id , ** edge_kwargs ) edge . connect ( source , to_node ) edge_dict [( source . id , to_node . id )] = edge # Optional sink sink = None if sink_cls : sink = sink_cls ( env = env , id = \"Sink\" , ** sink_kwargs ) for c in range ( cols ): from_node = mesh_nodes [ rows - 1 ][ c ] edge_id = f \" { edge_prefix } _ { from_node . id } _SINK\" edge = edge_cls ( env = env , id = edge_id , ** edge_kwargs ) edge . connect ( from_node , sink ) edge_dict [( from_node . id , sink . id )] = edge return mesh_nodes , edge_dict , source , sink edges \u00b6 buffer \u00b6 Buffer ( env , id , capacity = 1 , delay = 0 , mode = 'FIFO' ) \u00b6 Bases: Edge Buffer class representing a FIFO queue. Inherits from the Edge class. This buffer can have a single input edge and a single output edge. Attributes: state ( str ) \u2013 The current state of the buffer. capacity ( int ) \u2013 The capacity of the buffer's internal storage. mode ( str ) \u2013 Mode of operation for the buffer, It can be - \"FIFO\" (First In First Out) - \"LIFO\" (Last In First Out). delay ( ( int , float ) ) \u2013 Delay after which the item becomes available. It Can be int or float: Used as a constant delay. Behavior: The Buffer is a type of edge represents components that holds the items that are waiting to be accepted by the destination node. Items that are added in buffer becomes available for use after delay amount of time. It operates in two modes- 1. FIFO : It prioritizes items in the order they were added, with the oldest items being available for the destination node first. 2. LIFO : It prioritizes items in the reverse order of their arrival, items that newly added are available to use by the destination node first Incoming edges can use reserve_get and reserve_put calls on the store in the buffer to reserve an item or space and after yielding the requests, an item can be put and obtained by using put and get methods. Raises: AssertionError \u2013 If the buffer does not have at least one source node or one destination node. Output performance metrics The key performance metrics of the buffer edge are captured in the stats attribute (dict) during a simulation run. last_state_change_time : Time when the state was last changed . time_averaged_num_of_items_in_buffer : Time - averaged number of items available in the buffer . total_time_spent_in_states : Dictionary with total time spent in each state . Source code in src/factorysimpy/edges/buffer.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def __init__ ( self , env , id , capacity = 1 , delay = 0 , mode = \"FIFO\" ): super () . __init__ ( env , id , capacity ) self . state = \"IDLE_STATE\" self . mode = mode self . delay = delay self . capacity = capacity self . stats = { \"last_state_change_time\" : None , \"time_averaged_num_of_items_in_buffer\" : 0 , \"total_time_spent_in_states\" :{ \"IDLE_STATE\" : 0.0 , \"RELEASING_STATE\" : 0.0 , \"BLOCKED_STATE\" : 0.0 } } if self . mode not in [ \"FIFO\" , \"LIFO\" ]: raise ValueError ( \"Invalid mode. Choose either 'FIFO' or 'LIFO'.\" ) # Initialize the buffer store self . inbuiltstore = BufferStore ( env , capacity = self . capacity , mode = self . mode ) if callable ( delay ) or hasattr ( delay , '__next__' ) or isinstance ( delay , ( int , float )) or delay is None : self . delay = delay else : raise ValueError ( \"delay must be None, int, float, generator, or callable.\" ) can_get () \u00b6 Check if the buffer can accept an item. Returns \u00b6 bool True if the buffer can give an item, False otherwise. Source code in src/factorysimpy/edges/buffer.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 def can_get ( self ): \"\"\" Check if the buffer can accept an item. Returns ------- bool True if the buffer can give an item, False otherwise. \"\"\" if not self . inbuiltstore . ready_items : return False #only return items that are older than the delay. Count such items #count = sum(1 for item in self.inbuiltstore.items if item.time_stamp_creation + self.delay <= self.env.now) # count should be greater than the number of reservations that are already there return len ( self . inbuiltstore . ready_items ) > len ( self . inbuiltstore . reservations_get ) can_put () \u00b6 Check if the buffer can accept an item. Returns \u00b6 bool True if the buffer can accept an item, False otherwise. Source code in src/factorysimpy/edges/buffer.py 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 def can_put ( self ): \"\"\" Check if the buffer can accept an item. Returns ------- bool True if the buffer can accept an item, False otherwise. \"\"\" # Check if the buffer has space for new items if len ( self . inbuiltstore . items ) + len ( self . inbuiltstore . ready_items ) == self . capacity : return False # return True if the number of items in the buffer is less than the store capacity minus the number of reservations # reservations_put is the number of items that are already reserved to be put in the buffer return ( self . capacity - len ( self . inbuiltstore . items ) - len ( self . inbuiltstore . ready_items )) > len ( self . inbuiltstore . reservations_put ) get ( event ) \u00b6 Get an item from the buffer. Parameters \u00b6 event : simpy.Event The event that was reserved for getting an item. Returns \u00b6 item : object The item retrieved from the buffer. Source code in src/factorysimpy/edges/buffer.py 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 def get ( self , event ): \"\"\" Get an item from the buffer. Parameters ---------- event : simpy.Event The event that was reserved for getting an item. Returns ------- item : object The item retrieved from the buffer. \"\"\" item = self . inbuiltstore . get ( event ) self . _buffer_stats_collector () return item reserve_get_cancel ( event ) \u00b6 Cancel a reserved get event. Parameters \u00b6 event : simpy.Event The event that was reserved for getting an item. Source code in src/factorysimpy/edges/buffer.py 182 183 184 185 186 187 188 189 190 191 def reserve_get_cancel ( self , event ): \"\"\" Cancel a reserved get event. Parameters ---------- event : simpy.Event The event that was reserved for getting an item. \"\"\" return self . inbuiltstore . reserve_get_cancel ( event ) reserve_put_cancel ( event ) \u00b6 Cancel a reserved put event. Parameters \u00b6 event : simpy.Event The event that was reserved for putting an item. Source code in src/factorysimpy/edges/buffer.py 193 194 195 196 197 198 199 200 201 202 def reserve_put_cancel ( self , event ): \"\"\" Cancel a reserved put event. Parameters ---------- event : simpy.Event The event that was reserved for putting an item. \"\"\" return self . inbuiltstore . reserve_put_cancel ( event ) continuous_conveyor \u00b6 ConveyorBelt ( env , id , conveyor_length , speed , item_length , accumulating ) \u00b6 Bases: Edge A conveyor belt system with optional accumulation. Attributes: capacity ( int ) : Maximum capacity of the belt . state ( str ) : state of the conveyor belt . length ( float ) : Length of the item . speed ( float ) : Speed of the conveyor belt . accumulating ( bool ) : Whether the belt supports accumulation ( 1 for yes , 0 for no ) . belt ( BeltStore ) : The belt store object . Source code in src/factorysimpy/edges/continuous_conveyor.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def __init__ ( self , env , id , conveyor_length , speed , item_length , accumulating ): capacity = int ( np . ceil ( conveyor_length ) / item_length ) super () . __init__ ( env , id , capacity ) self . state = \"IDLE_STATE\" self . length = item_length #length of the item self . conveyor_length = conveyor_length self . accumulating = accumulating self . speed = speed self . delay = int ( self . conveyor_length / self . speed ) * capacity #self.delay = (self.length*self.speed)/capacity self . belt = BeltStore ( env , capacity , self . speed , self . accumulating ) #self.time_per_item = self.length/self.speed #self.inp_buf=ReservablePriorityReqStore(env, capacity=1) #self.out_buf=ReservablePriorityReqStore(env, capacity=1) self . stats = { \"last_state_change_time\" : None , \"time_averaged_num_of_items_in_conveyor\" : 0 , \"total_time_spent_in_states\" :{ \"IDLE_STATE\" : 0.0 , \"MOVING_STATE\" : 0.0 , \"ACCUMULATING_STATE\" : 0.0 , \"STALLED_NONACCUMULATING_STATE\" : 0.0 } } self . item_arrival_event = self . env . event () # self.item_get_event=self.env.event() self . get_events_available = self . env . event () self . put_events_available = self . env . event () self . noaccumulation_mode_on = False # self.get_request_queue = [] # self.put_request_queue = [] # self.active_events = [] # self.get_dict = {} # self.put_dict = {} self . env . process ( self . behaviour ()) can_get () \u00b6 Check if an item can be retrieved from the belt. Source code in src/factorysimpy/edges/continuous_conveyor.py 123 124 125 126 127 128 129 def can_get ( self ): \"\"\"Check if an item can be retrieved from the belt.\"\"\" #first_item_to_go_out = self.items[0] if self.items else None if not self . out_buf . items : return False else : return True can_put () \u00b6 Check if an item can be added to the belt. Source code in src/factorysimpy/edges/continuous_conveyor.py 138 139 140 141 142 143 def can_put ( self ): \"\"\"Check if an item can be added to the belt.\"\"\" if not self . inp_buf . items : return True else : return False get ( event ) \u00b6 Get an item from the belt. Parameters \u00b6 event : simpy.Event The event that was reserved for getting an item. Returns \u00b6 Item The item retrieved from the belt. Source code in src/factorysimpy/edges/continuous_conveyor.py 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 def get ( self , event ): \"\"\" Get an item from the belt. Parameters ---------- event : simpy.Event The event that was reserved for getting an item. Returns ------- Item The item retrieved from the belt. \"\"\" print ( f \"T= { self . env . now : .2f } : { self . id } :get: getting item from belt\" ) item = self . belt . get ( event ) item . conveyor_exit_time = self . env . now self . _conveyor_stats_collector () event = self . env . event () self . get_events_available . succeed () print ( f \" { self . env . now } { item . id } time in conveyor { item . conveyor_entry_time } and { item . conveyor_exit_time } - time spend in conveyor { item . conveyor_exit_time - item . conveyor_entry_time if item . conveyor_exit_time and item . conveyor_entry_time else 'N/A' } \" ) return item is_empty () \u00b6 Check if the belt is completely empty. Source code in src/factorysimpy/edges/continuous_conveyor.py 105 106 107 108 def is_empty ( self ): \"\"\"Check if the belt is completely empty.\"\"\" return ( len ( self . belt . items ) + len ( self . belt . ready_items ) == 0 ) is_full () \u00b6 Check if the belt is full. Source code in src/factorysimpy/edges/continuous_conveyor.py 119 120 121 def is_full ( self ): \"\"\"Check if the belt is full.\"\"\" return len ( self . belt . items ) + len ( self . belt . ready_items ) == self . belt . capacity is_stalled () \u00b6 Check if the belt is stalled due to time constraints. Source code in src/factorysimpy/edges/continuous_conveyor.py 131 132 133 134 135 136 def is_stalled ( self ): \"\"\"Check if the belt is stalled due to time constraints.\"\"\" if self . belt . ready_items and len ( self . belt . reservations_get ) == 0 : return True else : return False put ( event , item ) \u00b6 Put an item into the belt. Parameters \u00b6 event : simpy.Event The event that was reserved for putting an item. item : Item The item to be put on the belt. Returns \u00b6 simpy.Event An event that will be triggered when the item is successfully put on the belt. Source code in src/factorysimpy/edges/continuous_conveyor.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 def put ( self , event , item ): \"\"\" Put an item into the belt. Parameters ---------- event : simpy.Event The event that was reserved for putting an item. item : Item The item to be put on the belt. Returns ------- simpy.Event An event that will be triggered when the item is successfully put on the belt. \"\"\" #delay=self.get_delay(self.delay) print ( f \"T= { self . env . now : .2f } : Conveyor:put: putting item { item . id } \" ) delay = self . length * self . capacity / self . speed item . conveyor_entry_time = self . env . now item_to_put = ( item , delay ) print ( f \"T= { self . env . now : .2f } : { self . id } :put: putting item { item_to_put [ 0 ] . id } on belt with delay { item_to_put [ 1 ] } { self . state } \" ) return_val = self . belt . put ( event , item_to_put ) self . _conveyor_stats_collector () if len ( self . belt . items ) == 1 and self . state == \"IDLE_STATE\" : self . item_arrival_event . succeed () print ( f \"T= { self . env . now : .2f } : { self . id } :put: item arrival event succeeded\" ) else : event = self . env . event () self . put_events_available . succeed () if self . accumulating == 0 : print ( f \"T= { self . env . now : .2f } : { self . id } : attempting to put an item while non accumulating mode on and { self . state } and { self . belt . noaccumulation_mode_on } \" ) print ( f \"T= { self . env . now : .2f } : { self . id } :put: item arrival event else succeeded\" ) if self . state == \"STALLED_ACCUMULATING_STATE\" and self . accumulating == 1 or self . state == \"STALLED_NONACCUMULATING_STATE\" and self . accumulating == 0 : print ( f \"T= { self . env . now : .2f } : { self . id } :put: handling new item during interruption { item_to_put [ 0 ] . id } on belt\" ) self . belt . handle_new_item_during_interruption ( item_to_put ) return return_val set_conveyor_state ( new_state ) \u00b6 Set the conveyor state and manage belt store interrupts/resumes. Parameters: new_state ( str ) \u2013 The new conveyor state Source code in src/factorysimpy/edges/continuous_conveyor.py 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 def set_conveyor_state ( self , new_state ): \"\"\" Set the conveyor state and manage belt store interrupts/resumes. Args: new_state (str): The new conveyor state \"\"\" old_state = self . state self . state = new_state print ( f \"T= { self . env . now : .2f } : { self . id } state changed from { old_state } to { new_state } \" ) # Control belt store based on conveyor state changes if old_state in [ \"MOVING_STATE\" , \"IDLE_STATE\" ] and new_state in [ \"STALLED_ACCUMULATING_STATE\" , \"STALLED_NONACCUMULATING_STATE\" ]: # When conveyor becomes stalled (either accumulating or non-accumulating), apply selective interruption if not self . accumulating : self . belt . noaccumulation_mode_on = True self . belt . selective_interrupt ( f \"Conveyor { self . id } selective interruption - { new_state } \" ) elif old_state in [ \"STALLED_ACCUMULATING_STATE\" , \"STALLED_NONACCUMULATING_STATE\" ] and new_state in [ \"MOVING_STATE\" , \"IDLE_STATE\" ]: # When conveyor resumes to moving or becomes idle, resume all belt store processes #self.belt.interrupt_and_resume_all_delayed_interrupt_processes() if not self . accumulating : self . belt . noaccumulation_mode_on = False self . belt . resume_all_move_processes () self . belt . interrupt_and_resume_all_delayed_interrupt_processes () else : print ( \"state changes from\" , old_state , \"to\" , new_state ) edge \u00b6 Edge ( env , id , capacity ) \u00b6 Edge represents the passive components. It used to connect two nodes and helps to move items between them. It is the base class used to model buffers, conveyors, fleets, etc in manufacturing system. Parameters: id ( str ) \u2013 unique identifier for the edge src_node ( Node ) \u2013 reference to the source node connected to this edge. dest_node ( Node ) \u2013 reference to the destination node connected to this edge. Raises: TypeError \u2013 If the type of env or id is incorrect. ValueError \u2013 If the delay parameter is not a valid type (int, float, generator, or callable). ValueError \u2013 If the edge is already connected to a source or destination node and reconnect is False. ValueError \u2013 If the source or destination nodes are not valid Node instances. Source code in src/factorysimpy/edges/edge.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def __init__ ( self , env , id , capacity ): self . env = env self . id = id self . src_node = None self . dest_node = None self . capacity = capacity # Type checks if not isinstance ( env , simpy . Environment ): raise TypeError ( \"env must be a simpy.Environment instance\" ) if not isinstance ( id , str ): raise TypeError ( \"id must be a string\" ) if not isinstance ( self . capacity , int ) or self . capacity <= 0 : raise ValueError ( \"capacity must be a positive integer\" ) assert self . src_node is None , f \"Edge ' { self . id } ' must have a source node.\" assert self . dest_node is None , f \"Edge ' { self . id } ' must have a destination node.\" assert self . id is not None , \"Edge id cannot be None.\" assert self . capacity is not None , \"Edge capacity cannot be None.\" connect ( src , dest , reconnect = False ) \u00b6 Connects this edge to a source node and a destination node. This method checks that both src and dest are valid Node objects and that the edge is not already connected, unless reconnect is set to True. It also registers this edge in the out_edges of the source node and the in_edges of the destination node. Parameters: src ( Node ) \u2013 The source node to connect. dest ( Node ) \u2013 The destination node to connect. reconnect ( bool , default: False ) \u2013 If True, allows reconnection even if the edge is already connected. Defaults to False. Raises: ValueError \u2013 If the edge is already connected and reconnect is False. ValueError \u2013 If src or dest is not a valid Node instance. Source code in src/factorysimpy/edges/edge.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 def connect ( self , src : Node , dest : Node , reconnect : bool = False ): \"\"\" Connects this edge to a source node and a destination node. This method checks that both `src` and `dest` are valid Node objects and that the edge is not already connected, unless `reconnect` is set to True. It also registers this edge in the `out_edges` of the source node and the `in_edges` of the destination node. Args: src (Node): The source node to connect. dest (Node): The destination node to connect. reconnect (bool, optional): If True, allows reconnection even if the edge is already connected. Defaults to False. Raises: ValueError: If the edge is already connected and `reconnect` is False. ValueError: If `src` or `dest` is not a valid Node instance. \"\"\" if not reconnect : if self . src_node or self . dest_node : raise ValueError ( f \"Edge ' { self . id } ' is already connected source or destination node.\" ) if not isinstance ( src , Node ): raise ValueError ( f \"Source ' { src } ' is not a valid Node.\" ) if not isinstance ( dest , Node ): raise ValueError ( f \"Destination ' { dest } ' is not a valid Node.\" ) self . src_node = src self . dest_node = dest # Register edge to nodes if src . out_edges is None : src . out_edges = [] if self not in src . out_edges : src . out_edges . append ( self ) if dest . in_edges is None : dest . in_edges = [] if self not in dest . in_edges : dest . in_edges . append ( self ) print ( f \"T= { self . env . now : .2f } : Connected edge ' { self . id } ' from ' { src . id } ' to ' { dest . id } ' \" ) get_delay ( delay ) \u00b6 Returns value based on the type of parameter delay provided. Parameters: delay ( int, float, generator, or callable ) \u2013 The delay time, which can be: int or float: Used as a constant delay. generator: A generator instance yielding delay values. callable: A function that returns a delay values. Returns: \u2013 Returns a constant delay if delay is an int or float, a value yielded if delay is a generator, or the value returned from a Callable function if delay is callable. Source code in src/factorysimpy/edges/edge.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def get_delay ( self , delay ): \"\"\" Returns value based on the type of parameter `delay` provided. Args: delay (int, float, generator, or callable): The delay time, which can be: - int or float: Used as a constant delay. - generator: A generator instance yielding delay values. - callable: A function that returns a delay values. Returns: Returns a constant delay if `delay` is an int or float, a value yielded if `delay` is a generator, or the value returned from a Callable function if `delay` is callable. \"\"\" if hasattr ( delay , '__next__' ): # Generator instance val = next ( delay ) elif callable ( delay ): # Function val = delay () else : # int or float val = delay assert val >= 0 , \"Delay must be non-negative\" return val update_state ( new_state , current_time ) \u00b6 Update node state and track the time spent in the previous state. Parameters: new_state ( str ) \u2013 The new state to transition to. Must be one of \"SETUP_STATE\", \"GENERATING_STATE\", \"BLOCKED_STATE\". current_time ( float ) \u2013 The current simulation time. Source code in src/factorysimpy/edges/edge.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def update_state ( self , new_state : str , current_time : float ): \"\"\" Update node state and track the time spent in the previous state. Args: new_state (str): The new state to transition to. Must be one of \"SETUP_STATE\", \"GENERATING_STATE\", \"BLOCKED_STATE\". current_time (float): The current simulation time. \"\"\" if self . state is not None and self . stats [ \"last_state_change_time\" ] is not None : elapsed = current_time - self . stats [ \"last_state_change_time\" ] self . stats [ \"total_time_spent_in_states\" ][ self . state ] = ( self . stats [ \"total_time_spent_in_states\" ] . get ( self . state , 0.0 ) + elapsed ) self . state = new_state self . stats [ \"last_state_change_time\" ] = current_time fleet \u00b6 Fleet ( env , id , capacity = 1 , delay = 1 , transit_delay = 0 ) \u00b6 Bases: Edge Fleet class representing an AGV (Automated Guided Vehicle) or a group of transporters. Inherits from the Edge class. This fleet can have a single input edge and a single output edge. Attributes: state ( str ) \u2013 The current state of the fleet. capacity ( int ) \u2013 The capacity of the fleet's internal storage. delay ( ( int , float ) ) \u2013 Delay after which fleet activates to move items incase the target capacity is not reached. It Can be int or float: Used as a constant delay. transit_delay ( ( int , float ) ) \u2013 It is the time taken by the fleet to transport the item from src node to destination node. (can be a constant, generator, or callable). Behavior: The Fleet is a type of edge represents components that moves multiple items simulataneaously between nodes. User can specify a parameter capacity to specify how many items can be moved at once. Incoming edges can use reserve_get and reserve_put calls on the store in the fleet to reserve an item or space and after yielding the requests, an item can be put and obtained by using put and get methods. Raises: AssertionError \u2013 If the fleet does not have at least one source node or one destination node. Output performance metrics The key performance metrics of the fleet edge are captured in the stats attribute (dict) during a simulation run. last_state_change_time : Time when the state was last changed . time_averaged_num_of_items_in_fleet : Time - averaged number of items available in the fleet . total_time_spent_in_states : Dictionary with total time spent in each state . Source code in src/factorysimpy/edges/fleet.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def __init__ ( self , env , id , capacity = 1 , delay = 1 , transit_delay = 0 ): super () . __init__ ( env , id , capacity ) self . state = \"IDLE_STATE\" self . delay = delay self . capacity = capacity self . transit_delay = transit_delay self . stats = { \"last_state_change_time\" : None , \"time_averaged_num_of_items_in_fleet\" : 0 , \"total_time_spent_in_states\" :{ \"IDLE_STATE\" : 0.0 , \"RELEASING_STATE\" : 0.0 , \"BLOCKED_STATE\" : 0.0 } } # Initialize the fleet store self . inbuiltstore = FleetStore ( env , capacity = self . capacity , delay = self . delay , transit_delay = self . transit_delay ) if callable ( delay ) or hasattr ( delay , '__next__' ) or isinstance ( delay , ( int , float )) or delay is None : self . delay = delay else : raise ValueError ( \"delay must be None, int, float, generator, or callable.\" ) can_get () \u00b6 Check if the fleet can accept an item. Returns \u00b6 bool True if the fleet can give an item, False otherwise. Source code in src/factorysimpy/edges/fleet.py 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 def can_get ( self ): \"\"\" Check if the fleet can accept an item. Returns ------- bool True if the fleet can give an item, False otherwise. \"\"\" if not self . inbuiltstore . ready_items : return False #only return items that are older than the delay. Count such items #count = sum(1 for item in self.inbuiltstore.items if item.time_stamp_creation + self.delay <= self.env.now) # count should be greater than the number of reservations that are already there return len ( self . inbuiltstore . ready_items ) > len ( self . inbuiltstore . reservations_get ) can_put () \u00b6 Check if the fleet can accept an item. Returns \u00b6 bool True if the fleet can accept an item, False otherwise. Source code in src/factorysimpy/edges/fleet.py 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 def can_put ( self ): \"\"\" Check if the fleet can accept an item. Returns ------- bool True if the fleet can accept an item, False otherwise. \"\"\" # Check if the fleet has space for new items if len ( self . inbuiltstore . items ) + len ( self . inbuiltstore . ready_items ) == self . capacity : return False # return True if the number of items in the fleet is less than the store capacity minus the number of reservations # reservations_put is the number of items that are already reserved to be put in the fleet return ( self . capacity - len ( self . inbuiltstore . items ) - len ( self . inbuiltstore . ready_items )) > len ( self . inbuiltstore . reservations_put ) get ( event ) \u00b6 Get an item from the fleet. Parameters \u00b6 event : simpy.Event The event that was reserved for getting an item. Returns \u00b6 item : object The item retrieved from the fleet. Source code in src/factorysimpy/edges/fleet.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 def get ( self , event ): \"\"\" Get an item from the fleet. Parameters ---------- event : simpy.Event The event that was reserved for getting an item. Returns ------- item : object The item retrieved from the fleet. \"\"\" #print(f\"T={self.env.now:.2f}: {self.id} is getting an item at time {self.env.now}, total item in fleet is {len(self.inbuiltstore.items)+len(self.inbuiltstore.ready_items)}\") item = self . inbuiltstore . get ( event ) self . _fleet_stats_collector () #print(f\"T={self.env.now:.2f}, got an item!!!!\") item . fleet_exit_time = self . env . now return item reserve_get_cancel ( event ) \u00b6 Cancel a reserved get event. Parameters \u00b6 event : simpy.Event The event that was reserved for getting an item. Source code in src/factorysimpy/edges/fleet.py 173 174 175 176 177 178 179 180 181 182 def reserve_get_cancel ( self , event ): \"\"\" Cancel a reserved get event. Parameters ---------- event : simpy.Event The event that was reserved for getting an item. \"\"\" return self . inbuiltstore . reserve_get_cancel ( event ) reserve_put_cancel ( event ) \u00b6 Cancel a reserved put event. Parameters \u00b6 event : simpy.Event The event that was reserved for putting an item. Source code in src/factorysimpy/edges/fleet.py 184 185 186 187 188 189 190 191 192 193 def reserve_put_cancel ( self , event ): \"\"\" Cancel a reserved put event. Parameters ---------- event : simpy.Event The event that was reserved for putting an item. \"\"\" return self . inbuiltstore . reserve_put_cancel ( event ) slotted_conveyor \u00b6 ConveyorBelt ( env , id , capacity , delay , accumulating ) \u00b6 Bases: Edge A conveyor belt system with optional accumulation. Attributes: capacity ( int ) : Maximum capacity of the belt . state ( str ) : state of the conveyor belt . delay ( float ) : Time interval between two successive movements on the belt . accumulation ( bool ) : Whether the belt supports accumulation ( 1 for yes , 0 for no ) . Source code in src/factorysimpy/edges/slotted_conveyor.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 def __init__ ( self , env , id , capacity , delay , accumulating ): super () . __init__ ( env , id , capacity ) self . state = \"IDLE_STATE\" #self.length= length #length of the item self . accumulating = accumulating self . delay = delay #self.delay = int(self.length/self.speed)*capacity self . belt = BeltStore ( env , capacity , self . delay ) #self.time_per_item = self.length/self.speed #self.inp_buf=ReservablePriorityReqStore(env, capacity=1) #self.out_buf=ReservablePriorityReqStore(env, capacity=1) self . stats = { \"last_state_change_time\" : None , \"time_averaged_num_of_items_in_conveyor\" : 0 , \"total_time_spent_in_states\" :{ \"IDLE_STATE\" : 0.0 , \"MOVING_STATE\" : 0.0 , \"ACCUMULATING_STATE\" : 0.0 , \"STALLED_NONACCUMULATING_STATE\" : 0.0 } } self . item_arrival_event = self . env . event () # self.item_get_event=self.env.event() self . get_events_available = self . env . event () self . put_events_available = self . env . event () self . noaccumulation_mode_on = False # self.get_request_queue = [] # self.put_request_queue = [] # self.active_events = [] # self.get_dict = {} # self.put_dict = {} self . env . process ( self . behaviour ()) can_get () \u00b6 Check if an item can be retrieved from the belt. Source code in src/factorysimpy/edges/slotted_conveyor.py 138 139 140 141 142 143 144 def can_get ( self ): \"\"\"Check if an item can be retrieved from the belt.\"\"\" #first_item_to_go_out = self.items[0] if self.items else None if not self . out_buf . items : return False else : return True can_put () \u00b6 Check if an item can be added to the belt. Source code in src/factorysimpy/edges/slotted_conveyor.py 153 154 155 156 157 158 def can_put ( self ): \"\"\"Check if an item can be added to the belt.\"\"\" if not self . inp_buf . items : return True else : return False get ( event ) \u00b6 Get an item from the belt. Parameters \u00b6 event : simpy.Event The event that was reserved for getting an item. Returns \u00b6 Item The item retrieved from the belt. Source code in src/factorysimpy/edges/slotted_conveyor.py 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 def get ( self , event ): \"\"\" Get an item from the belt. Parameters ---------- event : simpy.Event The event that was reserved for getting an item. Returns ------- Item The item retrieved from the belt. \"\"\" print ( f \"T= { self . env . now : .2f } : { self . id } :get: getting item from belt\" ) item = self . belt . get ( event ) item . conveyor_exit_time = self . env . now self . _conveyor_stats_collector () # event= self.env.event() # self.get_events_available.succeed() return item is_empty () \u00b6 Check if the belt is completely empty. Source code in src/factorysimpy/edges/slotted_conveyor.py 127 128 129 def is_empty ( self ): \"\"\"Check if the belt is completely empty.\"\"\" return ( len ( self . belt . items ) + len ( self . belt . ready_items ) == 0 ) is_full () \u00b6 Check if the belt is full. Source code in src/factorysimpy/edges/slotted_conveyor.py 134 135 136 def is_full ( self ): \"\"\"Check if the belt is full.\"\"\" return len ( self . belt . items ) + len ( self . belt . ready_items ) == self . belt . capacity is_stalled () \u00b6 Check if the belt is stalled due to time constraints. Source code in src/factorysimpy/edges/slotted_conveyor.py 146 147 148 149 150 151 def is_stalled ( self ): \"\"\"Check if the belt is stalled due to time constraints.\"\"\" if self . belt . ready_items and len ( self . belt . reservations_get ) == 0 : return True else : return False put ( event , item ) \u00b6 Put an item into the belt. Parameters \u00b6 event : simpy.Event The event that was reserved for putting an item. item : Item The item to be put on the belt. Returns \u00b6 simpy.Event An event that will be triggered when the item is successfully put on the belt. Source code in src/factorysimpy/edges/slotted_conveyor.py 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 def put ( self , event , item ): \"\"\" Put an item into the belt. Parameters ---------- event : simpy.Event The event that was reserved for putting an item. item : Item The item to be put on the belt. Returns ------- simpy.Event An event that will be triggered when the item is successfully put on the belt. \"\"\" #delay=self.get_delay(self.delay) print ( f \"T= { self . env . now : .2f } : Conveyor:put: putting item { item . id } \" ) delay = self . capacity * self . delay item . conveyor_entry_time = self . env . now item_to_put = ( item , delay ) print ( f \"T= { self . env . now : .2f } : { self . id } :put: putting item { item_to_put [ 0 ] . id } on belt with delay { item_to_put [ 1 ] } \" ) return_val = self . belt . put ( event , item_to_put ) self . _conveyor_stats_collector () # if len(self.belt.items)==1: # self.item_arrival_event.succeed() # print(f\"T={self.env.now:.2f}: {self.id }:put: item arrival event succeeded\") # else: # self.put_events_available.succeed() # print(f\"T={self.env.now:.2f}: {self.id }:put: item arrival event else succeeded\") return return_val set_conveyor_state ( new_state ) \u00b6 Set the conveyor state and manage belt store interrupts/resumes. Parameters: new_state ( str ) \u2013 The new conveyor state Source code in src/factorysimpy/edges/slotted_conveyor.py 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 def set_conveyor_state ( self , new_state ): \"\"\" Set the conveyor state and manage belt store interrupts/resumes. Args: new_state (str): The new conveyor state \"\"\" old_state = self . state self . state = new_state print ( f \"T= { self . env . now : .2f } : { self . id } state changed from { old_state } to { new_state } \" ) # Control belt store based on conveyor state changes if old_state in [ \"MOVING_STATE\" , \"IDLE_STATE\" ] and new_state in [ \"STALLED_ACCUMULATING_STATE\" , \"STALLED_NONACCUMULATING_STATE\" ]: # When conveyor becomes stalled (either accumulating or non-accumulating), apply selective interruption self . belt . selective_interrupt ( f \"Conveyor { self . id } selective interruption - { new_state } \" ) elif old_state in [ \"STALLED_ACCUMULATING_STATE\" , \"STALLED_NONACCUMULATING_STATE\" ] and new_state in [ \"MOVING_STATE\" , \"IDLE_STATE\" ]: # When conveyor resumes to moving or becomes idle, resume all belt store processes self . belt . resume_all_move_processes () helper \u00b6 baseflowitem \u00b6 BaseFlowItem ( id ) \u00b6 A class representing an item . Source code in src/factorysimpy/helper/baseflowitem.py 3 4 5 6 7 8 9 10 11 12 13 def __init__ ( self , id ): self . id = id self . timestamp_creation = None self . timestamp_destruction = None self . timestamp_node_entry = None self . timestamp_node_exit = None self . current_node_id = None self . source_id = None # Track the source node self . payload = None self . destructed_in_node = None # Node where item was destructed self . stats = {} # Dictionary to store time spent at each node set_creation ( source_id , env ) \u00b6 Set creation time and source node ID. Source code in src/factorysimpy/helper/baseflowitem.py 15 16 17 18 def set_creation ( self , source_id , env ): \"\"\"Set creation time and source node ID.\"\"\" self . timestamp_creation = env . now self . source_id = source_id set_destruction ( node_id , env ) \u00b6 set the destruction time and node of the item. Source code in src/factorysimpy/helper/baseflowitem.py 20 21 22 23 def set_destruction ( self , node_id , env ): \"\"\"set the destruction time and node of the item.\"\"\" self . timestamp_destruction = env . now self . destructed_in_node = node_id update_node_event ( node_id , env , event_type = 'entry' ) \u00b6 Update item details and stats when entering or exiting a node. Parameters: node_id ( str ) \u2013 The ID of the node. env ( Environment ) \u2013 The simulation environment (for current time). event_type ( str , default: 'entry' ) \u2013 \"entry\" or \"exit\" to specify the event. Source code in src/factorysimpy/helper/baseflowitem.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def update_node_event ( self , node_id , env , event_type = \"entry\" ): \"\"\" Update item details and stats when entering or exiting a node. Args: node_id (str): The ID of the node. env (simpy.Environment): The simulation environment (for current time). event_type (str): \"entry\" or \"exit\" to specify the event. \"\"\" if event_type == \"entry\" : self . timestamp_node_entry = env . now #print(f\"T={self.timestamp_node_entry:.2f}: {self.id} entered node {node_id}\") self . current_node_id = node_id elif event_type == \"exit\" : self . timestamp_node_exit = env . now # Calculate time spent at the node and update stats if self . current_node_id is not None and self . timestamp_node_entry is not None : time_spent = self . timestamp_node_exit - self . timestamp_node_entry if self . current_node_id in self . stats : self . stats [ self . current_node_id ] += time_spent else : self . stats [ self . current_node_id ] = time_spent item \u00b6 Item ( id ) \u00b6 Bases: BaseFlowItem A class representing a pallet, which can hold multiple items. Source code in src/factorysimpy/helper/item.py 5 6 7 def __init__ ( self , id ): super () . __init__ ( id ) self . flow_item_type = \"item\" pallet \u00b6 Pallet ( id ) \u00b6 Bases: BaseFlowItem A class representing a pallet, which can hold multiple items. Source code in src/factorysimpy/helper/pallet.py 5 6 7 8 def __init__ ( self , id ): super () . __init__ ( id ) self . flow_item_type = \"Pallet\" self . items = [] # List to hold contained items add_item ( item ) \u00b6 Add an item to the pallet. Source code in src/factorysimpy/helper/pallet.py 10 11 12 def add_item ( self , item ): \"\"\"Add an item to the pallet.\"\"\" self . items . append ( item ) remove_item () \u00b6 Remove an item from the pallet if present. Source code in src/factorysimpy/helper/pallet.py 14 15 16 17 18 19 def remove_item ( self ): \"\"\"Remove an item from the pallet if present.\"\"\" if self . items : item = self . items . pop ( - 1 ) # Remove the last item return item return None nodes \u00b6 combiner \u00b6 Combiner ( env , id , in_edges = None , out_edges = None , node_setup_time = 0 , target_quantity_of_each_item = [ 1 ], processing_delay = 0 , blocking = True , out_edge_selection = 'FIRST_AVAILABLE' ) \u00b6 Bases: Node Combiner class representing a processing node in a factory simulation. Inherits from the Node class.The combiner can have multiple input edges and a multiple output edges. It gets items from the input edges and packs them into a pallet or box and pushes it to the output edge. Parameters: state ( str ) \u2013 Current state of the combiner node. One of : SETUP_STATE: Initial setup phase before combiner starts to operate. IDLE_STATE: Worker threads waiting to receive items. PROCESSING_STATE: Actively processing items. BLOCKED_STATE: When all the worker threads are waiting to push the processed item but the out going edge is full. blocking ( bool , default: True ) \u2013 If True, the source waits until it can put an item into the out edge. If False, it discards the item if the out edge is full and cannot accept the item that is being pushed by the combiner. processing_delay ( (None, int , float , Generator , Callable ) , default: 0 ) \u2013 Delay for processing items. Can be: None: Used when the processing time depends on parameters of the node object (like current state of the object) or environment. int or float: Used as a constant delay. Generator: A generator function yielding delay values over time. Callable: A function that returns a delay (int or float). out_edge_selection ( None or str or callable , default: 'FIRST_AVAILABLE' ) \u2013 Criterion or function for selecting the out edge. Options include \"RANDOM\", \"ROUND_ROBIN\", \"FIRST_AVAILABLE\". None: None: Used when out edge selction depends on parameters of the node object (like current state of the object) or environment. str: A string that specifies the selection method. \"RANDOM\": Selects a random out edge in the out_edges list. \"ROUND_ROBIN\": Selects out edges in a round-robin manner. \"FIRST_AVAILABLE\": Selects the first out edge that can accept an item. callable: A function that returns an edge index. Behavior The combiner node represents components that process or modify the items that flow in the simulation model. It can have multiple incoming edges and multiple outgoing edge. Edge to which processed item is pushed is decided using the method specified in the parameter out_edge_selection . Combiner will transition through the states- SETUP_STATE , PROCESSING_STATE , IDLE_STATE and BLOCKED_STATE . The combiner has a blocking behavior if blocking = True and gets blocked when all its worker threads have processed items and the out edge is full and cannot accept the item that is being pushed by the combiner and waits until the out edge can accept the item. If blocking = False , the combiner will discard the item if the out edge is full and cannot accept the item that is being pushed by the combiner. Raises: AssertionError \u2013 If the combiner has no input or output edges. Output performance metrics: The key performance metrics of the combiner node is captured in stats attribute (dict) during a simulation run. last_state_change_time : Time when the state was last changed . num_item_processed : Total number of items generated . num_item_discarded : Total number of items discarded . total_time_spent_in_states : Dictionary with total time spent in each state . Source code in src/factorysimpy/nodes/combiner.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 def __init__ ( self , env , id , in_edges = None , out_edges = None , node_setup_time = 0 , target_quantity_of_each_item = [ 1 ], processing_delay = 0 , blocking = True , out_edge_selection = \"FIRST_AVAILABLE\" ): super () . __init__ ( env , id , in_edges , out_edges , node_setup_time ) self . state = \"SETUP_STATE\" # Initial state of the combiner self . work_capacity = 1 self . out_edge_selection = out_edge_selection self . blocking = blocking self . per_thread_total_time_in_blocked_state = 0.0 self . per_thread_total_time_in_processing_state = 0.0 self . target_quantity_of_each_item = target_quantity_of_each_item self . worker_thread_list = [] # List to keep track of worker threads self . item_in_process = None self . pallet_in_process = None self . num_workers = 0 # Number of worker threads currently processing self . time_last_occupancy_change = 0 # Time when the occupancy was last changed self . worker_thread = simpy . Resource ( env , capacity = self . work_capacity ) # Resource for worker threads self . time_per_work_occupancy = [ 0.0 for _ in range ( self . work_capacity + 1 )] # Time spent by each worker thread self . stats = { \"total_time_spent_in_states\" : { \"SETUP_STATE\" : 0.0 , \"IDLE_STATE\" : 0.0 , \"PROCESSING_STATE\" : 0.0 , \"BLOCKED_STATE\" : 0.0 }, \"last_state_change_time\" : None , \"num_item_processed\" : 0 , \"num_item_discarded\" : 0 , \"processing_delay\" :[], \"out_edge_selection\" :[]} # Initialize processing delay # If processing_delay is a generator, callable, int, float or None, it is accepted. if callable ( processing_delay ) or hasattr ( processing_delay , '__next__' ) or isinstance ( processing_delay , ( int , float )) or processing_delay is None : self . processing_delay = processing_delay else : raise ValueError ( \"processing_delay must be None, int, float, generator, or callable.\" ) self . env . process ( self . behaviour ()) # Start the combiner behavior process add_in_edges ( edge ) \u00b6 Adds an in_edge to the node. Raises an error if the edge already exists in the in_edges list. Parameters: edge (Edge Object) \u2013 The edge to be added as an in_edge. Source code in src/factorysimpy/nodes/combiner.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 def add_in_edges ( self , edge ): \"\"\" Adds an in_edge to the node. Raises an error if the edge already exists in the in_edges list. Args: edge (Edge Object) : The edge to be added as an in_edge. \"\"\" if self . in_edges is None : self . in_edges = [] # if len(self.in_edges) >= self.num_in_edges: # raise ValueError(f\"Combiner'{self.id}' already has {self.num_in_edges} in_edges. Cannot add more.\") if edge not in self . in_edges : self . in_edges . append ( edge ) else : raise ValueError ( f \"Edge already exists in Combiner ' { self . id } ' in_edges.\" ) add_out_edges ( edge ) \u00b6 Adds an out_edge to the node. Raises an error if the edge already exists in the out_edges list. Parameters: edge (Edge Object) \u2013 The edge to be added as an out_edge. Source code in src/factorysimpy/nodes/combiner.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 def add_out_edges ( self , edge ): \"\"\" Adds an out_edge to the node. Raises an error if the edge already exists in the out_edges list. Args: edge (Edge Object) : The edge to be added as an out_edge. \"\"\" if self . out_edges is None : self . out_edges = [] # if len(self.out_edges) >= 1: # raise ValueError(f\"Combiner '{self.id}' already has 1 out_edge. Cannot add more.\") if edge not in self . out_edges : self . out_edges . append ( edge ) else : raise ValueError ( f \"Edge already exists in Combiner ' { self . id } ' out_edges.\" ) update_state ( new_state , current_time ) \u00b6 Update node state and track the time spent in the previous state. Parameters: i ( int ) \u2013 The index of the worker thread to update the state for. new_state ( str ) \u2013 The new state to transition to. Must be one of \"SETUP_STATE\", \"GENERATING_STATE\", \"BLOCKED_STATE\". current_time ( float ) \u2013 The current simulation time. Source code in src/factorysimpy/nodes/combiner.py 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 def update_state ( self , new_state : str , current_time : float ): \"\"\" Update node state and track the time spent in the previous state. Args: i (int): The index of the worker thread to update the state for. new_state (str): The new state to transition to. Must be one of \"SETUP_STATE\", \"GENERATING_STATE\", \"BLOCKED_STATE\". current_time (float): The current simulation time. \"\"\" if self . state is not None and self . stats [ \"last_state_change_time\" ] is not None : elapsed = current_time - self . stats [ \"last_state_change_time\" ] self . stats [ \"total_time_spent_in_states\" ][ self . state ] = ( self . stats [ \"total_time_spent_in_states\" ] . get ( self . state , 0.0 ) + elapsed ) self . state = new_state self . stats [ \"last_state_change_time\" ] = current_time machine \u00b6 Machine ( env , id , in_edges = None , out_edges = None , node_setup_time = 0 , work_capacity = 1 , processing_delay = 0 , blocking = True , in_edge_selection = 'FIRST_AVAILABLE' , out_edge_selection = 'FIRST_AVAILABLE' ) \u00b6 Bases: Node Machine represents a processing node in a factory simulation. This Machine can have multiple input edges and output edges. Parameters: state_rep ( tuple ) \u2013 Current state of the machine node representates as a tuple based on the state of the worker threads (num_worker_threads_processing, num_worker_threads_blocked). Worker threads can be either in the processing state or in the blocked state. Based on that machine can be in one or many of the following states: SETUP_STATE: Initial setup phase before machine starts to operate. Denoted as (-1,-1) IDLE_STATE: Worker threads waiting to receive items. Denoted as (0,0) ATLEAST_ONE_PROCESSING_STATE: Active state where items are being processed. State when atleast one thread is in processing state. ALL_ACTIVE_BLOCKED_STATE: The state when all the worker_threads that are currently active are in \"BLOCKED_STATE\" as they are waiting for the out edge to be available to accept the processed item. Number of active threads can be equal to greater than work_capacity. ALL_ACTIVE_PROCESSING_STATE: The state when all the active threads are in processing state. Number of active threads can be equal to greater than work_capacity. ATLEAST_ONE_BLOCKED_STATE: The state when atleast one of the worker_threads is in \"BLOCKED_STATE\" as it is waiting for the out edge to be available to accept the processed item. blocking ( bool , default: True ) \u2013 If True, the source waits until it can put an item into the out edge. If False, it discards the item if the out edge is full and cannot accept the item that is being pushed by the machine. work_capacity ( int , default: 1 ) \u2013 Maximum no. of processing that can be performed simultaneously.1 worker thread can process one item. processing_delay ( (None, int , float , Generator , Callable ) , default: 0 ) \u2013 Delay for processing items. Can be: None: Used when the processing time depends on parameters of the node object (like current state of the object) or environment. int or float: Used as a constant delay. Generator: A generator function yielding delay values over time. Callable: A function that returns a delay (int or float). in_edge_selection ( None or str or callable , default: 'FIRST_AVAILABLE' ) \u2013 Criterion or function for selecting the edge. Options include \"RANDOM\", \"ROUND_ROBIN\", \"FIRST_AVAILABLE\". None: None: Used when edge selction depends on parameters of the node object (like current state of the object) or environment. str: A string that specifies the selection method. \"RANDOM\": Selects a random edge. \"ROUND_ROBIN\": Selects edges in a round-robin manner. \"FIRST_AVAILABLE\": Selects the first out edge that can give an item. callable: A function that returns an edge index. out_edge_selection ( None or str or callable , default: 'FIRST_AVAILABLE' ) \u2013 Criterion or function for selecting the out edge. Options include \"RANDOM\", \"ROUND_ROBIN\", \"FIRST_AVAILABLE\". None: None: Used when out edge selction depends on parameters of the node object (like current state of the object) or environment. str: A string that specifies the selection method. \"RANDOM\": Selects a random out edge in the out_edges list. \"ROUND_ROBIN\": Selects out edges in a round-robin manner. \"FIRST_AVAILABLE\": Selects the first out edge that can accept an item. callable: A function that returns an edge index. Behavior The machine node represents components that process or modify the items that flow in the simulation model. It can have multiple incoming edges and multiple outgoing edge. Edge from which the item comes in and the edge to which processed item is pushed is decided using the method specified in the parameter in_edge_selection and out_edge_selection . Machine will transition through the states- SETUP_STATE , PROCESSING_STATE , IDLE_STATE and BLOCKED_STATE . The machine has a blocking behavior if blocking = True and gets blocked when all its worker threads have processed items and the out edge is full and cannot accept the item that is being pushed by the machine and waits until the out edge can accept the item. If blocking = False , the machine will discard the item if the out edge is full and cannot accept the item that is being pushed by the machine. Raises: AssertionError \u2013 If the Machine has no input or output edges. Output performance metrics: The key performance metrics of the Machine node is captured in stats attribute (dict) during a simulation run. last_state_change_time : Time when the state was last changed . num_item_processed : Total number of items generated . num_item_discarded : Total number of items discarded . total_time_spent_in_states : Dictionary with total time spent in each state . Source code in src/factorysimpy/nodes/machine.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 def __init__ ( self , env , id , in_edges = None , out_edges = None , node_setup_time = 0 , work_capacity = 1 , processing_delay = 0 , blocking = True , in_edge_selection = \"FIRST_AVAILABLE\" , out_edge_selection = \"FIRST_AVAILABLE\" ): super () . __init__ ( env , id , in_edges , out_edges , node_setup_time ) self . work_capacity = work_capacity self . in_edge_selection = in_edge_selection self . out_edge_selection = out_edge_selection self . state_rep = None self . blocking = blocking self . per_thread_total_time_in_blocked_state = 0.0 self . per_thread_total_time_in_processing_state = 0.0 self . worker_thread_list = [] # List to keep track of worker threads self . item_in_process = None self . num_workers = 0 # Number of worker threads currently processing self . time_last_occupancy_change = 0 # Time when the occupancy was last changed self . worker_thread = simpy . Resource ( env , capacity = self . work_capacity ) # Resource for worker threads self . time_per_work_occupancy = [ 0.0 for _ in range ( work_capacity + 1 )] # Time spent by each worker thread #self.stats={\"total_time_spent_in_states\": {\"SETUP_STATE\": 0.0, \"IDLE_STATE\":0.0, \"PROCESSING_STATE\": 0.0,\"BLOCKED_STATE\":0.0 }, # \"last_state_change_time\": None, \"num_item_processed\": 0, \"num_item_discarded\": 0,\"processing_delay\":[], \"in_edge_selection\":[],\"out_edge_selection\":[]} self . total_time_all_blocked = 0.0 self . total_time_all_processing = 0.0 self . total_time_atleast_one_blocked = 0.0 self . total_time_atleast_one_processing = 0.0 self . total_time_idle = 0.0 self . total_time_setup = 0.0 self . stats = { \"total_time_spent_in_states\" : { \"SETUP_STATE\" : 0.0 , \"IDLE_STATE\" : 0.0 , \"ATLEAST_ONE_PROCESSING_STATE\" : 0.0 , \"ALL_ACTIVE_BLOCKED_STATE\" : 0.0 , \"ALL_ACTIVE_PROCESSING_STATE\" : 0.0 , \"ATLEAST_ONE_BLOCKED_STATE\" : 0.0 }, \"last_state_change_time\" : None , \"num_item_processed\" : 0 , \"num_item_discarded\" : 0 , \"processing_delay\" :[], \"in_edge_selection\" :[], \"out_edge_selection\" :[]} # Initialize processing delay # If processing_delay is a generator, callable, int, float or None, it is accepted. if callable ( processing_delay ) or hasattr ( processing_delay , '__next__' ) or isinstance ( processing_delay , ( int , float )) or processing_delay is None : self . processing_delay = processing_delay else : raise ValueError ( \"processing_delay must be None, int, float, generator, or callable.\" ) self . env . process ( self . behaviour ()) # Start the machine behavior process add_in_edges ( edge ) \u00b6 Adds an in_edge to the node. Raises an error if the edge already exists in the in_edges list. Parameters: edge (Edge Object) \u2013 The edge to be added as an in_edge. Source code in src/factorysimpy/nodes/machine.py 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 def add_in_edges ( self , edge ): \"\"\" Adds an in_edge to the node. Raises an error if the edge already exists in the in_edges list. Args: edge (Edge Object) : The edge to be added as an in_edge. \"\"\" if self . in_edges is None : self . in_edges = [] # if len(self.in_edges) >= self.num_in_edges: # raise ValueError(f\"Machine'{self.id}' already has {self.num_in_edges} in_edges. Cannot add more.\") if edge not in self . in_edges : self . in_edges . append ( edge ) else : raise ValueError ( f \"Edge already exists in Machine ' { self . id } ' in_edges.\" ) add_out_edges ( edge ) \u00b6 Adds an out_edge to the node. Raises an error if the edge already exists in the out_edges list. Parameters: edge (Edge Object) \u2013 The edge to be added as an out_edge. Source code in src/factorysimpy/nodes/machine.py 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 def add_out_edges ( self , edge ): \"\"\" Adds an out_edge to the node. Raises an error if the edge already exists in the out_edges list. Args: edge (Edge Object) : The edge to be added as an out_edge. \"\"\" if self . out_edges is None : self . out_edges = [] # if len(self.out_edges) >= 1: # raise ValueError(f\"Machine '{self.id}' already has 1 out_edge. Cannot add more.\") if edge not in self . out_edges : self . out_edges . append ( edge ) else : raise ValueError ( f \"Edge already exists in Machine ' { self . id } ' out_edges.\" ) update_state_rep ( current_time ) \u00b6 Update the state representation tuple based on the current state of worker threads. Parameters: state ( str ) \u2013 The current state of the machine. current_time ( float ) \u2013 The current simulation time. Source code in src/factorysimpy/nodes/machine.py 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 def update_state_rep ( self , current_time ): \"\"\" Update the state representation tuple based on the current state of worker threads. Args: state (str): The current state of the machine. current_time (float): The current simulation time. \"\"\" previous_state_rep = self . state_rep if self . state_rep is not None and self . stats [ \"last_state_change_time\" ] is not None : elapsed = current_time - self . stats [ \"last_state_change_time\" ] # all idle if previous_state_rep == ( 0 , 0 ): self . stats [ \"total_time_spent_in_states\" ][ \"IDLE_STATE\" ] += elapsed self . total_time_idle += elapsed # all active are blocked and none processing if previous_state_rep [ 1 ] > 0 and previous_state_rep [ 0 ] == 0 : self . stats [ \"total_time_spent_in_states\" ][ \"ALL_ACTIVE_BLOCKED_STATE\" ] += elapsed self . total_time_all_blocked += elapsed # at least one processing if previous_state_rep [ 0 ] > 0 : self . stats [ \"total_time_spent_in_states\" ][ \"ATLEAST_ONE_PROCESSING_STATE\" ] += elapsed self . total_time_atleast_one_processing += elapsed # all active are processing and none blocked if previous_state_rep [ 0 ] > 0 and previous_state_rep [ 1 ] == 0 : self . stats [ \"total_time_spent_in_states\" ][ \"ALL_ACTIVE_PROCESSING_STATE\" ] += elapsed self . total_time_all_processing += elapsed #at least one blocked if previous_state_rep [ 1 ] > 0 : self . stats [ \"total_time_spent_in_states\" ][ \"ATLEAST_ONE_BLOCKED_STATE\" ] += elapsed self . total_time_atleast_one_blocked += elapsed num_processing , num_blocked = self . _count_worker_state () self . state_rep = ( num_processing , num_blocked ) self . stats [ \"last_state_change_time\" ] = current_time node \u00b6 Node ( env , id , in_edges = None , out_edges = None , node_setup_time = 0 ) \u00b6 Base class to represent an active entity in a manufacturing system, such as machines, splits, or joints. Parameters: id ( str ) \u2013 Identifier for the node. node_setup_time ( int, or float , default: 0 ) \u2013 Initial setup time for the node. Can be: int or float: Used as a constant delay. in_edges ( list , default: None ) \u2013 List of input edges connected to the node. out_edges ( list , default: None ) \u2013 List of output edges connected to the node. Raises: TypeError \u2013 If the type of env or id is incorrect. ValueError \u2013 If node_setup_time input is invalid. Source code in src/factorysimpy/nodes/node.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def __init__ ( self , env , id , in_edges = None , out_edges = None , node_setup_time = 0 ): # Type checks if not isinstance ( env , simpy . Environment ): raise TypeError ( \"env must be a simpy.Environment instance\" ) if not isinstance ( id , str ): raise TypeError ( \"name must be a string\" ) self . env = env self . id = id # Identifier for the node. self . node_setup_time = node_setup_time # Time taken to set up the node. self . in_edges = in_edges # List of input edges connected to the node. self . out_edges = out_edges #List of output edges connected to the node. if isinstance ( node_setup_time , ( int , float )): self . node_setup_time = node_setup_time else : raise ValueError ( \"Invalid node_setup_time value. Provide constant ( int or float).\" ) get_delay ( delay ) \u00b6 Returns value based on the type of parameter delay provided. Parameters: delay ( int, float, generator, or callable ) \u2013 The delay time, which can be: int or float: Used as a constant delay. generator: A generator instance yielding delay values. callable: A function that returns a delay values. Returns: \u2013 Returns a constant delay if delay is an int or float, a value yielded if delay is a generator, or the value returned from a Callable function if delay is callable. Source code in src/factorysimpy/nodes/node.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def get_delay ( self , delay ): \"\"\" Returns value based on the type of parameter `delay` provided. Args: delay (int, float, generator, or callable): The delay time, which can be: - int or float: Used as a constant delay. - generator: A generator instance yielding delay values. - callable: A function that returns a delay values. Returns: Returns a constant delay if `delay` is an int or float, a value yielded if `delay` is a generator, or the value returned from a Callable function if `delay` is callable. \"\"\" if hasattr ( delay , '__next__' ): # Generator instance val = next ( delay ) elif callable ( delay ): # Function val = delay () else : # int or float val = delay #print(self.id) assert val >= 0 , f \" { self . id } - Delay must be non-negative\" return val update_state ( new_state , current_time ) \u00b6 Update node state and track the time spent in the previous state. Parameters: new_state ( str ) \u2013 The new state to transition to. Must be one of \"SETUP_STATE\", \"GENERATING_STATE\", \"BLOCKED_STATE\". current_time ( float ) \u2013 The current simulation time. Source code in src/factorysimpy/nodes/node.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 def update_state ( self , new_state : str , current_time : float ): \"\"\" Update node state and track the time spent in the previous state. Args: new_state (str): The new state to transition to. Must be one of \"SETUP_STATE\", \"GENERATING_STATE\", \"BLOCKED_STATE\". current_time (float): The current simulation time. \"\"\" if self . state is not None and self . stats [ \"last_state_change_time\" ] is not None : elapsed = current_time - self . stats [ \"last_state_change_time\" ] self . stats [ \"total_time_spent_in_states\" ][ self . state ] = ( self . stats [ \"total_time_spent_in_states\" ] . get ( self . state , 0.0 ) + elapsed ) self . state = new_state self . stats [ \"last_state_change_time\" ] = current_time sink \u00b6 Sink ( env , id , in_edges = None , node_setup_time = 0 ) \u00b6 Bases: Node A Sink is a terminal node that collects flow items at the end. Once an item enters the Sink, it is considered to have exited the system and cannot be retrieved or processed further This sink can have multiple input edges and no output edges. Raises AssertionError: If the sink does not have at least 1 input edge or has an output edge. Source code in src/factorysimpy/nodes/sink.py 23 24 25 26 27 28 29 30 31 32 33 def __init__ ( self , env , id , in_edges = None , node_setup_time = 0 ): super () . __init__ ( env , id , in_edges , None , node_setup_time ) self . state = \"COLLECTING_STATE\" self . in_edge_events = [] self . stats = { \"num_item_received\" : 0 , \"last_state_change_time\" : 0.0 , \"total_time_spent_in_states\" :{ \"COLLECTING_STATE\" : 0.0 }, \"total_cycle_time\" : 0.0 } self . item_in_process = None self . buffertime = 0 # Start behavior process self . env . process ( self . behaviour ()) self . item_list = {} source \u00b6 Source ( env , id , in_edges = None , out_edges = None , item_length = 1 , flow_item_type = 'item' , inter_arrival_time = 0 , blocking = False , out_edge_selection = 'FIRST_AVAILABLE' ) \u00b6 Bases: Node Parameters: state ( str ) \u2013 Current state of the source node. One of : SETUP_STATE: Initial setup phase before item generation starts. GENERATING_STATE: Actively generating and dispatching items. BLOCKED_STATE: Waiting to transfer item when edge is full (in blocking mode). inter_arrival_time ( None, int, float, generator, or callable , default: 0 ) \u2013 Time between item generations. Can be: None: Used when the setup time depends on parameters of the node object (like current state of the object) or environment. int or float: Used as a constant delay. Callable: A function that returns a delay (int or float). Generator: A generator function yielding delay values over time. flow_item_type ( str , default: 'item' ) \u2013 Type of item to be generated. Default is \"item\". Can be \"item\" : Smallest unit of discrete item and it cannot hold other items inside. \"pallet\" : Entities that can store multiple smaller units of items blocking ( bool , default: False ) \u2013 If True, the source waits until it can put an item into the out edge. out_edge_selection ( None or str or callable , default: 'FIRST_AVAILABLE' ) \u2013 Criterion or function for selecting the out edge. Options include \"RANDOM\", \"FIRST\", \"LAST\", \"ROUND_ROBIN\", \"FIRST_AVAILABLE\". None: Used when out edge selection depends on parameters of the node object (like current state of the object) or environment. str: A string that specifies the selection method. \"RANDOM\": Selects a random out edge. \"ROUND_ROBIN\": Selects out edges in a round-robin manner. \"FIRST_AVAILABLE\": Selects the first out edge that can accept an item. callable: A function that returns an edge index. Behavior: The Source node is responsible for generating items that flow in the simulation model. It operates in two modes: blocking and non-blocking. when blocking=True : - After each inter_arrival_time , the source generates an item. - If the selected out edge is full, the source waits until space is available. - Once space is available, the item is transferred to the selected edge. - inter_arrival_time must not be None . when blocking=False : - After each inter_arrival_time , the source generates an item. - If the selected out edge is full, the item is discarded immediately. - If space is available, the item is transferred without waiting. - inter_arrival_time must not be 0. Raises: ValueError \u2013 If inter_arrival_time is 0 in non-blocking mode or if out_edge_selection is not a valid type. ValueError \u2013 If out_edge_selection is not a string or callable. ValueError \u2013 If out_edges is not provided or has less than one edge. ValueError \u2013 If in_edges is provided, as Source nodes should not have input edges. ValueError \u2013 If out_edges already has an edge when trying to add a new one. Output performance metrics: The key performance metrics of the Source node is captured in stats attribute (dict) during a simulation run. last_state_change_time : Time when the state was last changed . num_item_generated : Total number of items generated . num_item_discarded : Total number of items discarded due to lack of space in out edge . total_time_spent_in_states : Dictionary with total time spent in each state . Source code in src/factorysimpy/nodes/source.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def __init__ ( self , env , id , in_edges = None , out_edges = None , item_length = 1 , flow_item_type = \"item\" , inter_arrival_time = 0 , blocking = False , out_edge_selection = \"FIRST_AVAILABLE\" ): super () . __init__ ( env , id , in_edges , out_edges ) self . state = \"SETUP_STATE\" # Initial state of the source node self . blocking = blocking self . item_length = item_length self . out_edge_selection = out_edge_selection # Selection strategy for out edges self . flow_item_type = flow_item_type # Type of item to be generated, default is \"item\" self . stats = { \"last_state_change_time\" : None , \"num_item_generated\" : 0 , \"num_item_discarded\" : 0 , \"total_time_spent_in_states\" :{ \"SETUP_STATE\" : 0.0 , \"GENERATING_STATE\" : 0.0 , \"BLOCKED_STATE\" : 0.0 } } if inter_arrival_time == 0 and not self . blocking : raise ValueError ( \"Non-blocking source must have a non-zero inter_arrival_time.\" ) elif callable ( inter_arrival_time ): self . inter_arrival_time = inter_arrival_time elif hasattr ( inter_arrival_time , '__next__' ): self . inter_arrival_time = inter_arrival_time elif isinstance ( inter_arrival_time , ( int , float )): self . inter_arrival_time = inter_arrival_time # interarrival_time is None and will be initialized later by the user elif inter_arrival_time is None : self . inter_arrival_time = inter_arrival_time else : #print(\"GGG\",inter_arrival_time) raise ValueError ( \"inter_arrival_time must be a None, int, float, generator, or callable.\" ) # Start behavior process self . env . process ( self . behaviour ()) add_out_edges ( edge ) \u00b6 Adds an out_edge to the source node. Raises an error if the source already has an out_edge or if the edge already exists in the out_edges list. Parameters: edge ( Edge Object ) \u2013 The edge to be added as an out_edge. Source code in src/factorysimpy/nodes/source.py 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 def add_out_edges ( self , edge ): \"\"\" Adds an out_edge to the source node. Raises an error if the source already has an out_edge or if the edge already exists in the out_edges list. Args: edge (Edge Object): The edge to be added as an out_edge. \"\"\" if self . out_edges is None : self . out_edges = [] if len ( self . out_edges ) >= 1 : raise ValueError ( f \"Source ' { self . id } ' already has 1 out_edge. Cannot add more.\" ) if edge not in self . out_edges : self . out_edges . append ( edge ) else : raise ValueError ( f \"Edge already exists in Source ' { self . id } ' out_edges.\" ) update_state ( new_state , current_time ) \u00b6 Update node state and track the time spent in the previous state. Parameters: i ( int ) \u2013 The index of the worker thread to update the state for. new_state ( str ) \u2013 The new state to transition to. Must be one of \"SETUP_STATE\", \"GENERATING_STATE\", \"BLOCKED_STATE\". current_time ( float ) \u2013 The current simulation time. Source code in src/factorysimpy/nodes/source.py 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 def update_state ( self , new_state : str , current_time : float ): \"\"\" Update node state and track the time spent in the previous state. Args: i (int): The index of the worker thread to update the state for. new_state (str): The new state to transition to. Must be one of \"SETUP_STATE\", \"GENERATING_STATE\", \"BLOCKED_STATE\". current_time (float): The current simulation time. \"\"\" if self . state is not None and self . stats [ \"last_state_change_time\" ] is not None : elapsed = current_time - self . stats [ \"last_state_change_time\" ] self . stats [ \"total_time_spent_in_states\" ][ self . state ] = ( self . stats [ \"total_time_spent_in_states\" ] . get ( self . state , 0.0 ) + elapsed ) self . state = new_state self . stats [ \"last_state_change_time\" ] = current_time splitter \u00b6 Splitter ( env , id , in_edges = None , out_edges = None , node_setup_time = 0 , processing_delay = 0 , blocking = True , mode = 'UNPACK' , split_quantity = None , in_edge_selection = 'FIRST_AVAILABLE' , out_edge_selection = 'FIRST_AVAILABLE' ) \u00b6 Bases: Node Splitter class representing a processing node that can unpack an incoming item and send it to multiple outgoing edges in a factory simulation. Parameters: state ( str ) \u2013 Current state of the splitter node. One of : SETUP_STATE: Initial setup phase before splitter starts to operate. IDLE_STATE: Worker threads waiting to receive items. PROCESSING_STATE: Actively processing items. BLOCKED_STATE: When all the worker threads are waiting to push the processed item but the out going edge is full. blocking ( bool , default: True ) \u2013 If True, the node waits until it can put an item into the out edge. If False, it discards the item if the out edge is full and cannot accept the item that is being pushed by the splitter. mode ( str , default: 'UNPACK' ) \u2013 Mode of operation of the splitter. Either \"UNPACK\" or \"SPLIT\". - \"UNPACK\": The splitter unpacks all items from a packed item (like a pallet) and pushes each item to an output edge, one by one. After all items are pushed, the empty container itself is pushed to an output edge. - \"SPLIT\": The splitter splits the incoming item into a target quantity of items, specified by split_quantity and pushes each item to an output edge, one by one. split_quantity ( int , default: None ) \u2013 Target quantity of items to split the input flow item into. This parameter is required if mode is \"SPLIT\". If mode is \"UNPACK\", this parameter is ignored. processing_delay ( (None, int , float , Generator , Callable ) , default: 0 ) \u2013 Delay for processing items. Can be: None: Used when the processing time depends on parameters of the node object (like current state of the object) or environment. int or float: Used as a constant delay. Generator: A generator function yielding delay values over time. Callable: A function that returns a delay (int or float). in_edge_selection ( None or str or callable , default: 'FIRST_AVAILABLE' ) \u2013 Criterion or function for selecting the edge. Options include \"RANDOM\", \"ROUND_ROBIN\", \"FIRST_AVAILABLE\". None: Used when edge selction depends on parameters of the node object (like current state of the object) or environment. str: A string that specifies the selection method. \"RANDOM\": Selects a random edge. \"ROUND_ROBIN\": Selects edges in a round-robin manner. \"FIRST_AVAILABLE\": Selects the first out edge that can give an item. callable: A function that returns an edge index. out_edge_selection ( None or str or callable , default: 'FIRST_AVAILABLE' ) \u2013 Criterion or function for selecting the out edge. Options include \"RANDOM\", \"ROUND_ROBIN\", \"FIRST_AVAILABLE\". None: None: Used when out edge selction depends on parameters of the node object (like current state of the object) or environment. str: A string that specifies the selection method. \"RANDOM\": Selects a random out edge in the out_edges list. \"ROUND_ROBIN\": Selects out edges in a round-robin manner. \"FIRST_AVAILABLE\": Selects the first out edge that can accept an item. callable: A function that returns an edge index. Behavior The Splitter node represents components that process or modify the items that flow in the simulation model. It can have multiple incoming edges and multiple outgoing edge. Edge from which the item comes in and the edge to which processed item is pushed is decided using the method specified in the parameter in_edge_selection and out_edge_selection . Splitter will transition through the states- SETUP_STATE , PROCESSING_STATE , IDLE_STATE and BLOCKED_STATE . The Splitter has a blocking behavior if blocking = True and gets blocked when all its worker threads have processed items and the out edge is full and cannot accept the item that is being pushed by the Splitter and waits until the out edge can accept the item. If blocking = False , the Splitter will discard the item if the out edge is full and cannot accept the item that is being pushed by the Splitter. Raises: AssertionError \u2013 If the Splitter has no input or output edges. Output performance metrics: The key performance metrics of the Splitter node is captured in stats attribute (dict) during a simulation run. last_state_change_time : Time when the state was last changed . num_item_processed : Total number of items generated . num_item_discarded : Total number of items discarded . total_time_spent_in_states : Dictionary with total time spent in each state . Source code in src/factorysimpy/nodes/splitter.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def __init__ ( self , env , id , in_edges = None , out_edges = None , node_setup_time = 0 , processing_delay = 0 , blocking = True , mode = \"UNPACK\" , split_quantity = None , in_edge_selection = \"FIRST_AVAILABLE\" , out_edge_selection = \"FIRST_AVAILABLE\" ): super () . __init__ ( env , id , in_edges , out_edges , node_setup_time ) self . state = \"SETUP_STATE\" # Initial state of the Splitter self . work_capacity = 1 self . in_edge_selection = in_edge_selection self . out_edge_selection = out_edge_selection self . blocking = blocking self . mode = mode self . split_quantity = split_quantity self . per_thread_total_time_in_blocked_state = 0.0 self . per_thread_total_time_in_processing_state = 0.0 self . worker_thread_list = [] # List to keep track of worker threads self . item_in_process = None self . pallet_in_process = None self . num_workers = 0 # Number of worker threads currently processing self . time_last_occupancy_change = 0 # Time when the occupancy was last changed self . worker_thread = simpy . Resource ( env , capacity = self . work_capacity ) # Resource for worker threads self . time_per_work_occupancy = [ 0.0 for _ in range ( self . work_capacity + 1 )] # Time spent by each worker thread self . stats = { \"total_time_spent_in_states\" : { \"SETUP_STATE\" : 0.0 , \"IDLE_STATE\" : 0.0 , \"PROCESSING_STATE\" : 0.0 , \"BLOCKED_STATE\" : 0.0 }, \"last_state_change_time\" : None , \"num_item_processed\" : 0 , \"num_item_discarded\" : 0 , \"processing_delay\" :[], \"in_edge_selection\" :[], \"out_edge_selection\" :[]} # Initialize processing delay # If processing_delay is a generator, callable, int, float or None, it is accepted. if callable ( processing_delay ) or hasattr ( processing_delay , '__next__' ) or isinstance ( processing_delay , ( int , float )) or processing_delay is None : self . processing_delay = processing_delay else : raise ValueError ( \"processing_delay must be None, int, float, generator, or callable.\" ) self . env . process ( self . behaviour ()) # Start the Splitter behavior process add_in_edges ( edge ) \u00b6 Adds an in_edge to the node. Raises an error if the edge already exists in the in_edges list. Parameters: edge (Edge Object) \u2013 The edge to be added as an in_edge. Source code in src/factorysimpy/nodes/splitter.py 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 def add_in_edges ( self , edge ): \"\"\" Adds an in_edge to the node. Raises an error if the edge already exists in the in_edges list. Args: edge (Edge Object) : The edge to be added as an in_edge. \"\"\" if self . in_edges is None : self . in_edges = [] # if len(self.in_edges) >= self.num_in_edges: # raise ValueError(f\"Splitter'{self.id}' already has {self.num_in_edges} in_edges. Cannot add more.\") if edge not in self . in_edges : self . in_edges . append ( edge ) else : raise ValueError ( f \"Edge already exists in Splitter ' { self . id } ' in_edges.\" ) add_out_edges ( edge ) \u00b6 Adds an out_edge to the node. Raises an error if the edge already exists in the out_edges list. Parameters: edge (Edge Object) \u2013 The edge to be added as an out_edge. Source code in src/factorysimpy/nodes/splitter.py 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 def add_out_edges ( self , edge ): \"\"\" Adds an out_edge to the node. Raises an error if the edge already exists in the out_edges list. Args: edge (Edge Object) : The edge to be added as an out_edge. \"\"\" if self . out_edges is None : self . out_edges = [] # if len(self.out_edges) >= 1: # raise ValueError(f\"Splitter '{self.id}' already has 1 out_edge. Cannot add more.\") if edge not in self . out_edges : self . out_edges . append ( edge ) else : raise ValueError ( f \"Edge already exists in Splitter ' { self . id } ' out_edges.\" ) update_state ( new_state , current_time ) \u00b6 Update node state and track the time spent in the previous state. Parameters: i ( int ) \u2013 The index of the worker thread to update the state for. new_state ( str ) \u2013 The new state to transition to. Must be one of \"SETUP_STATE\", \"GENERATING_STATE\", \"BLOCKED_STATE\". current_time ( float ) \u2013 The current simulation time. Source code in src/factorysimpy/nodes/splitter.py 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 def update_state ( self , new_state : str , current_time : float ): \"\"\" Update node state and track the time spent in the previous state. Args: i (int): The index of the worker thread to update the state for. new_state (str): The new state to transition to. Must be one of \"SETUP_STATE\", \"GENERATING_STATE\", \"BLOCKED_STATE\". current_time (float): The current simulation time. \"\"\" if self . state is not None and self . stats [ \"last_state_change_time\" ] is not None : elapsed = current_time - self . stats [ \"last_state_change_time\" ] self . stats [ \"total_time_spent_in_states\" ][ self . state ] = ( self . stats [ \"total_time_spent_in_states\" ] . get ( self . state , 0.0 ) + elapsed ) self . state = new_state self . stats [ \"last_state_change_time\" ] = current_time utils \u00b6 stats_summary \u00b6 compute_performance_metrics ( stats , sim_time ) \u00b6 Compute cycle time, resource utilization, throughput, and % time spent in each state for each worker. Parameters: stats ( dict ) \u2013 The stats dictionary from the component (key: worker id, value: stats dict). sim_time ( float ) \u2013 The total simulation time. Returns: dict \u2013 A dictionary with metrics for each worker. Source code in src/factorysimpy/utils/stats_summary.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def compute_performance_metrics ( stats , sim_time ): \"\"\" Compute cycle time, resource utilization, throughput, and % time spent in each state for each worker. Args: stats (dict): The stats dictionary from the component (key: worker id, value: stats dict). sim_time (float): The total simulation time. Returns: dict: A dictionary with metrics for each worker. \"\"\" results = {} for worker_id , s in stats . items (): total_time = sum ( s [ \"total_time_spent_in_states\" ] . values ()) # Defensive: If sim_time is 0, avoid division by zero sim_time = max ( sim_time , 1e-8 ) # Utilization: % time in PROCESSING_STATE util = s [ \"total_time_spent_in_states\" ] . get ( \"PROCESSING_STATE\" , 0.0 ) / sim_time # Throughput: items processed per unit time num_processed = s . get ( \"num_item_processed\" , 0 ) + s . get ( \"num_pallet_processed\" , 0 ) throughput = num_processed / sim_time # Cycle time: average time per processed item cycle_time = ( s [ \"total_time_spent_in_states\" ] . get ( \"PROCESSING_STATE\" , 0.0 ) / num_processed ) if num_processed > 0 else None # % time in each state pct_time_states = { state : ( t / sim_time ) * 100 for state , t in s [ \"total_time_spent_in_states\" ] . items ()} # Discarded num_discarded = s . get ( \"num_item_discarded\" , 0 ) + s . get ( \"num_pallet_discarded\" , 0 ) results [ worker_id ] = { \"utilization\" : util , \"throughput\" : throughput , \"cycle_time\" : cycle_time , \"percent_time_in_states\" : pct_time_states , \"num_processed\" : num_processed , \"num_discarded\" : num_discarded , } return results utils \u00b6 get_edge_selector ( sel_type , node , env , edge_type = None ) \u00b6 Returns a generator that yields selected indices from the node's edge list. Args: sel_type ( str ): The selection strategy . One of : ' RANDOM ' , ' ROUND_ROBIN ' . node ( object ): The node object containing in_edges or out_edges . env ( simpy . Environment ): The simulation environment . edge_type ( str , optional ): Whether to select from ' out_edges ' or ' in_edges ' . Default is ' OUT ' . Returns: generator : A generator yielding selected indices from the specified edge list . Raises: ValueError : If sel_type is not a valid selection strategy . Source code in src/factorysimpy/utils/utils.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def get_edge_selector ( sel_type , node , env , edge_type = None ): \"\"\" Returns a generator that yields selected indices from the node's edge list. Args: sel_type (str): The selection strategy. One of: 'RANDOM', 'ROUND_ROBIN'. node (object): The node object containing in_edges or out_edges. env (simpy.Environment): The simulation environment. edge_type (str, optional): Whether to select from 'out_edges' or 'in_edges'. Default is 'OUT'. Returns: generator: A generator yielding selected indices from the specified edge list. Raises: ValueError: If sel_type is not a valid selection strategy. \"\"\" edge_type = edge_type . lower () assert edge_type in [ \"in\" , \"out\" ], \"edge_type must be either 'in' or 'out'.\" strategies = { \"RANDOM\" : Random_edge_selector , \"ROUND_ROBIN\" : RoundRobin_edge_selector , } if sel_type not in strategies : raise ValueError ( f \"Invalid selection type: { sel_type } . Must be one of: { ', ' . join ( strategies . keys ()) } .\" ) #print(edge_type) return strategies [ sel_type ]( node , env , edge_type )","title":"API Reference"},{"location":"api_ref_main_page_2/#api-reference","text":"","title":"API Reference"},{"location":"api_ref_main_page_2/#factorysimpy","text":"","title":"factorysimpy"},{"location":"api_ref_main_page_2/#factorysimpy.base","text":"","title":"base"},{"location":"api_ref_main_page_2/#factorysimpy.base.belt_store","text":"","title":"belt_store"},{"location":"api_ref_main_page_2/#factorysimpy.base.belt_store.BeltStore","text":"Bases: Store This is a class that is derived from SimPy's Store class and has extra capabilities that makes it a reservable store for processes to reserve space for storing and retrieving items. Processes can use reserve_put() and reserve_get() methods to get notified when a space becomes available in the store or when an item gets available in the ReservableReqStore. These methods returns a unique event (SimPy.Event) to the process for every reserve requests it makes. get and put are two methods that can be used for item storing and retrieval from ReservableReqStore. Process has to make a prior reservation and pass the associated reservation event as argument in the get and put requests. ReservableReqStore maintains separate queues for reserve_put and reserve_get operations to ensures that only processes with valid reservations can store or retrieve items. ReservableReqStore preserves item order by associating an unreserved item in the store with a reservation event by index when a reserve_get() request is made. As a result, it maintains a list of reserved events to preserve item order. It also allows users to cancel an already placed reserve_get or reserve_put request even if it is yielded. It also handles the dissociation of the event and item done at the time of reservation when an already yielded event is canceled. When an item is added into the BeltStore using put(), it is associated with a delay representing the time it takes for the item to move through the belt. The item is not immediately available for retrieval after being put into the store. Instead, it becomes available only after the specified delay has elapsed, simulating the movement of items on a conveyor belt. Attributes: reserved_events ( list ) \u2013 Maintains events corresponding to reserved items to preserve item order by index reserve_put_queue ( list ) \u2013 Queue for managing reserve_put reservations reservations_put ( list ) \u2013 List of successful put reservations reserve_get_queue ( list ) \u2013 Queue for managing reserve_get reservations reservations_get ( list ) \u2013 List of successful get reservations Initializes a reservable store with reservations. Args: capacity (int, optional): The maximum number of items the store can hold. Defaults to infinity. mode (str, optional): The mode of the store ('FIFO' or 'LIFO'). Defaults to 'FIFO'. speed (float, optional): The speed of the conveyor belt. Defaults to 1. accumulation_mode_indicator (bool, optional): Indicates if the belt is in accumulation mode. Defaults to True. capacity (int, optional): The maximum number of items the store can hold. Defaults to infinity. Source code in src/factorysimpy/base/belt_store.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 def __init__ ( self , env , capacity = float ( 'inf' ), speed = 1 , accumulation_mode_indicator = True ): \"\"\" Initializes a reservable store with reservations. Args: capacity (int, optional): The maximum number of items the store can hold. Defaults to infinity. mode (str, optional): The mode of the store ('FIFO' or 'LIFO'). Defaults to 'FIFO'. speed (float, optional): The speed of the conveyor belt. Defaults to 1. accumulation_mode_indicator (bool, optional): Indicates if the belt is in accumulation mode. Defaults to True. capacity (int, optional): The maximum number of items the store can hold. Defaults to infinity. \"\"\" super () . __init__ ( env , capacity ) self . env = env self . speed = speed # Speed of the conveyor belt (units per time) self . reserve_put_queue = [] # Queue for managing reserve_put reservations self . reservations_put = [] # List of successful put reservations self . reserve_get_queue = [] # Queue for managing reserve_get reservations self . reservations_get = [] # List of successful get reservations self . reserved_events = [] # Maintains events corresponding to reserved items to preserve item order self . ready_items = [] #Maintains the items ready to be taken out self . reserved_items = [] # parallel list of the exact items reserved self . _last_level_change_time = self . env . now self . _last_num_items = 0 self . _weighted_sum = 0.0 self . time_averaged_num_of_items_in_store = 0.0 # Time-averaged number of items in the store # Process tracking for interrupt functionality self . active_move_processes = {} # Dictionary to track active move_to_ready_items processes self . active_delayed_interrupt_processes = {} # Dictionary to track active delayed interrupt processes self . resume_event = self . env . event () # Event to signal when to resume processes self . noaccumulation_mode_on = False # to control if the belt is in noaccumulation mode self . accumulation_mode_indicator = accumulation_mode_indicator # to indicate if the belt is in accumulation mode or not self . one_item_inserted = False # to control insertion of only one item in noaccumulation mode self . ready_item_event = self . env . event ()","title":"BeltStore"},{"location":"api_ref_main_page_2/#factorysimpy.base.belt_store.BeltStore.get","text":"Retrieve an item from the store after a successful reservation. This method attempts to retrieve an item associated with a reserve_get event. If the reservation exists, it triggers _trigger_get to retrieve the item. If successful, _trigger_reserve_put is called to process any pending reserve_put requests. If the item retrieval fails, an error message is raised. Parameters: get_event ( Event ) \u2013 The reservation event associated with the request. Returns: item ( Object ) \u2013 The retrieved item if successful, otherwise raises an error Raises: RuntimeError \u2013 If no reservations are available in the reservations_get RuntimeError \u2013 If item returned is None Source code in src/factorysimpy/base/belt_store.py 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 def get ( self , get_event ): \"\"\" Retrieve an item from the store after a successful reservation. This method attempts to retrieve an item associated with a `reserve_get` event. If the reservation exists, it triggers `_trigger_get` to retrieve the item. If successful, `_trigger_reserve_put` is called to process any pending `reserve_put` requests. If the item retrieval fails, an error message is raised. Args: get_event (simpy.Event): The reservation event associated with the request. Returns: item (Object): The retrieved item if successful, otherwise raises an error Raises: RuntimeError: If no reservations are available in the reservations_get RuntimeError: If item returned is None \"\"\" item = None #if there are reservations, then call _trigger_get if self . reservations_get : item = self . _trigger_get ( get_event ) #else raise an error else : raise RuntimeError ( \"No matching reservation found for process: reservations_get is empty\" ) #if an item is returned then call _trigger_reserve_put to process pending requests if item is not None : self . _trigger_reserve_put ( None ) if item is None : raise RuntimeError ( f \"No item found in the store for { get_event . requesting_process } and get request failed\" ) else : #self._update_time_averaged_level() return item","title":"get"},{"location":"api_ref_main_page_2/#factorysimpy.base.belt_store.BeltStore.handle_new_item_during_interruption","text":"Handle new item added during STALLED_ACCUMULATING_STATE with accumulation=1. Computes delay using same logic as for existing items. Source code in src/factorysimpy/base/belt_store.py 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 def handle_new_item_during_interruption ( self , item ): \"\"\" Handle new item added during STALLED_ACCUMULATING_STATE with accumulation=1. Computes delay using same logic as for existing items. \"\"\" # Build the updated belt pattern with new item current_pattern = self . _get_belt_pattern () print ( f \"T= { self . env . now : .2f } Current belt pattern after adding new item: { current_pattern [ 0 ] } and items { current_pattern [ 1 ] } \" ) updated_pattern = list ( current_pattern [ 0 ]) # Recompute item positions item_positions = [ i for i , c in enumerate ( updated_pattern ) if c == '*' ] print ( \"item_positions with new item\" , item_positions ) # Get interruption plan interruption_plan = self . _calculate_gap_based_interruptions ( '' . join ( updated_pattern ), item_positions , current_pattern [ 1 ]) print ( f \"T= { self . env . now : .2f } Interruption plan with new item: { interruption_plan } \" ) # The new item is the last one added in pattern delay_for_new_item = interruption_plan [ 0 ][ 'delay' ] item_id = item [ 0 ] . id if hasattr ( item [ 0 ], 'id' ) else str ( id ( item )) item_id = item [ 0 ] . id if hasattr ( item [ 0 ], 'id' ) else str ( id ( item )) item_length = item [ 0 ] . length if hasattr ( item [ 0 ], 'length' ) else 1.0 delay_for_new_item = delay_for_new_item * ( item_length / self . speed ) if delay_for_new_item > 0 : print ( f \"T= { self . env . now : .2f } New item { item_id } will be interrupted after { delay_for_new_item } time units\" ) interrupt_process = self . env . process ( self . _delayed_interrupt ( item_id , delay_for_new_item , \"New item during interruption\" )) item_id = item [ 0 ] . id if hasattr ( item [ 0 ], 'id' ) else str ( id ( item )) self . active_delayed_interrupt_processes [ item_id ] = interrupt_process else : print ( f \"T= { self . env . now : .2f } New item { item_id } { interruption_plan [ 0 ][ 'item_index' ] } { interruption_plan [ - 1 ][ 'delay' ] } interrupted immediately\" ) self . _interrupt_specific_item ( item_id , \"New item during interruption\" )","title":"handle_new_item_during_interruption"},{"location":"api_ref_main_page_2/#factorysimpy.base.belt_store.BeltStore.interrupt_all_move_processes","text":"Interrupt all active move_to_ready_items processes. Parameters: reason ( str , default: 'External interrupt' ) \u2013 Reason for the interrupt Source code in src/factorysimpy/base/belt_store.py 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 def interrupt_all_move_processes ( self , reason = \"External interrupt\" ): \"\"\" Interrupt all active move_to_ready_items processes. Args: reason (str): Reason for the interrupt \"\"\" print ( f \"T= { self . env . now : .2f } Belt_Store interrupting { len ( self . active_move_processes ) } move processes - { reason } \" ) for item_id , process_info in self . active_move_processes . items (): process = process_info [ 'process' ] if process and not process . processed : try : process . interrupt ( reason ) print ( f \"T= { self . env . now : .2f } Interrupted move process for item { item_id } \" ) except RuntimeError : # Process might already be finished pass","title":"interrupt_all_move_processes"},{"location":"api_ref_main_page_2/#factorysimpy.base.belt_store.BeltStore.interrupt_and_resume_all_delayed_interrupt_processes","text":"Interrupt all active delayed interrupt processes and clear them. Parameters: reason ( str , default: 'State change interrupt' ) \u2013 Reason for the interrupt Source code in src/factorysimpy/base/belt_store.py 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 def interrupt_and_resume_all_delayed_interrupt_processes ( self , reason = \"State change interrupt\" ): \"\"\" Interrupt all active delayed interrupt processes and clear them. Args: reason (str): Reason for the interrupt \"\"\" print ( f \"T= { self . env . now : .2f } Belt_Store interrupting { len ( self . active_delayed_interrupt_processes ) } delayed interrupt processes - { reason } \" ) for item_id , process in list ( self . active_delayed_interrupt_processes . items ()): if process and not process . processed : try : process . interrupt ( reason ) print ( f \"T= { self . env . now : .2f } Interrupted delayed interrupt process for item { item_id } \" ) except RuntimeError : # Process might already be finished pass # Remove from tracking regardless self . active_delayed_interrupt_processes . pop ( item_id , None )","title":"interrupt_and_resume_all_delayed_interrupt_processes"},{"location":"api_ref_main_page_2/#factorysimpy.base.belt_store.BeltStore.move_to_ready_items","text":"Move items from the store to the ready_items list after a put operation. This method is called as a process to ensure that items are moved asynchronously. Handles interrupts when state changes to stalled and resumes when state changes back. Movement is split into two phases: 1. First phase: item[0].length/self.speed time (time for item to fully enter belt) 2. Second phase: remaining time (time for item to reach exit) Source code in src/factorysimpy/base/belt_store.py 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 def move_to_ready_items ( self , item ): \"\"\" Move items from the store to the ready_items list after a put operation. This method is called as a process to ensure that items are moved asynchronously. Handles interrupts when state changes to stalled and resumes when state changes back. Movement is split into two phases: 1. First phase: item[0].length/self.speed time (time for item to fully enter belt) 2. Second phase: remaining time (time for item to reach exit) \"\"\" item_id = item [ 0 ] . id if hasattr ( item [ 0 ], 'id' ) else str ( id ( item )) event = self . env . event () total_interruption_time = 0 #self.delay=item[0].length/self.speed #print(f\"created Added event suceeded{self.delay}\") event . callbacks . append ( self . _trigger_reserve_put ) # after putting an item, an event is created and will be triggered ater delay amount of time to allow waiting get calls to succeed in a stalled belt #event.callbacks.append(self._trigger_put)# this may not be needed #print(f\"{self.env.now}Added event suceed ed\") # Calculate the two phases of movement phase1_time = item [ 0 ] . length / self . speed # Time for item to fully enter belt phase2_time = item [ 1 ] - phase1_time # Remaining time to reach exit item [ 0 ] . total_interruption_time = total_interruption_time item [ 0 ] . interruption_start_time = None try : # Move items to the ready_items list if self . items : print ( f \"T= { self . env . now : .2f } beltstore received an item { item [ 0 ] . id , item [ 1 ] } . Item started moving in belt\" ) # Phase 1: Item entering the belt (length/speed time) remaining_phase1_time = phase1_time print ( f \"T= { self . env . now : .2f } Item { item_id } starting Phase 1 (entering belt): { phase1_time : .2f } time\" ) while remaining_phase1_time > 0 : try : start_time = self . env . now yield self . env . timeout ( remaining_phase1_time ) # If we reach here, phase 1 completed without interruption event . succeed () remaining_phase1_time = 0 break except simpy . Interrupt as interrupt : # Calculate how much time has passed interruption_start_time_phase1 = self . env . now item [ 0 ] . interruption_start_time = interruption_start_time_phase1 print ( f \" { self . env . now } for item { item_id } Phase 1 started interruption at { interruption_start_time_phase1 } \" ) elapsed_time = self . env . now - start_time remaining_phase1_time -= elapsed_time print ( f \"T= { self . env . now : .2f } Move process Phase 1 for item { item_id } interrupted: { interrupt . cause } \" ) print ( f \"T= { self . env . now : .2f } Remaining Phase 1 time for item { item_id } : { remaining_phase1_time : .2f } \" ) # Wait for resume signal print ( f \"T= { self . env . now : .2f } Item { item_id } waiting for resume signal with { remaining_phase1_time : .2f } time left to complete(Phase 1)...\" ) yield self . resume_event total_interruption_time += self . env . now - interruption_start_time_phase1 item [ 0 ] . interruption_start_time = None item [ 0 ] . total_interruption_time = total_interruption_time print ( f \"T= { self . env . now : .2f } Item { item_id } resuming Phase 1 movement with { remaining_phase1_time : .2f } time remaining\" ) print ( f \"T= { self . env . now : .2f } Item { item_id } completed Phase 1 (fully entered belt)\" ) # Phase 2: Item moving through the belt to exit remaining_phase2_time = phase2_time print ( f \"T= { self . env . now : .2f } Item { item_id } starting Phase 2 (moving to exit): { phase2_time : .2f } time\" ) while remaining_phase2_time > 0 : try : start_time = self . env . now yield self . env . timeout ( remaining_phase2_time ) # If we reach here, phase 2 completed without interruption remaining_phase2_time = 0 break except simpy . Interrupt as interrupt : # Calculate how much time has passed interruption_start_time_phase2 = self . env . now item [ 0 ] . interruption_start_time = interruption_start_time_phase2 print ( f \" { self . env . now } for item { item_id } Phase 2 started interruption at { interruption_start_time_phase2 } \" ) elapsed_time = self . env . now - start_time remaining_phase2_time -= elapsed_time print ( f \"T= { self . env . now : .2f } Move process Phase 2 for item { item_id } interrupted: { interrupt . cause } \" ) print ( f \"T= { self . env . now : .2f } Remaining Phase 2 time for item { item_id } : { remaining_phase2_time : .2f } \" ) # Wait for resume signal print ( f \"T= { self . env . now : .2f } Item { item_id } waiting for resume signal (Phase 2) time left- { remaining_phase2_time : .2f } ...\" ) yield self . resume_event item [ 0 ] . interruption_start_time = None total_interruption_time += self . env . now - interruption_start_time_phase2 item [ 0 ] . total_interruption_time = total_interruption_time print ( f \"T= { self . env . now : .2f } Item { item_id } resuming Phase 2 movement with { remaining_phase2_time : .2f } time remaining\" ) print ( f \"T= { self . env . now : .2f } Item { item_id } completed Phase 2 (reached exit)\" ) #print(f\"T={self.env.now:.2f} bufferstore finished moving item {item[0].id, item[1]} going to ready_items\") item_index = self . items . index ( item ) item_to_put = self . items . pop ( item_index ) # Remove the item if len ( self . ready_items ) + len ( self . items ) < self . capacity : self . ready_items . append ( item_to_put [ 0 ]) item_to_put [ 0 ] . conveyor_ready_item_entry_time = self . env . now print ( \"Total items on belt\" , len ( self . ready_items ) + len ( self . items )) if not self . ready_item_event . triggered : self . ready_item_event . succeed () print ( f \"T= { self . env . now : .2f } bufferstore finished moving item { item [ 0 ] . id , item [ 1 ] } moved to ready_items\" ) self . _trigger_reserve_get ( None ) self . _trigger_reserve_put ( None ) else : raise RuntimeError ( \"Total number of items in the store exceeds capacity. Cannot move item to ready_items.\" ) except simpy . Interrupt as interrupt : # Handle any uncaught interrupts print ( f \"T= { self . env . now : .2f } Item { item_id } move process was interrupted: { interrupt . cause } \" ) finally : # Clean up the process tracking when done if item_id in self . active_move_processes : del self . active_move_processes [ item_id ] print ( f \"T= { self . env . now : .2f } Removed tracking for completed move process of item { item_id } \" )","title":"move_to_ready_items"},{"location":"api_ref_main_page_2/#factorysimpy.base.belt_store.BeltStore.put","text":"Perform a put operation on the store and trigger any pending reserve_get requests. Ensures that only processes with a valid reservation can put items into the store. If the put operation succeeds, it triggers _trigger_reserve_get to process pending get requests. Parameters: put_event ( Event ) \u2013 The event corresponding to the reservation. item ( object ) \u2013 The item to be added to the store. Returns: proceed ( bool ) \u2013 True if the put operation succeeded, False otherwise. Raises: RuntimeError \u2013 If no reservations are available in the reservations_put RuntimeError \u2013 If proceed is False after put operation Source code in src/factorysimpy/base/belt_store.py 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 def put ( self , put_event , item ): \"\"\" Perform a `put` operation on the store and trigger any pending `reserve_get` requests. Ensures that only processes with a valid reservation can put items into the store. If the put operation succeeds, it triggers `_trigger_reserve_get` to process pending get requests. Args: put_event (simpy.Event): The event corresponding to the reservation. item (object): The item to be added to the store. Returns: proceed (bool): True if the put operation succeeded, False otherwise. Raises: RuntimeError: If no reservations are available in the reservations_put RuntimeError: If proceed is False after put operation \"\"\" proceed = False if self . reservations_put : proceed = self . _trigger_put ( put_event , item ) else : raise RuntimeError ( \"No matching reservation found for process: reservations_put is empty\" ) if proceed : #print(f\"{self.env.now} proceed\") #self._trigger_get(None) self . _trigger_reserve_get ( None ) if not proceed : raise RuntimeError ( f \"No matching put_event found in the reservations and put failed for { item } \" ) else : #self._update_time_averaged_level() return proceed","title":"put"},{"location":"api_ref_main_page_2/#factorysimpy.base.belt_store.BeltStore.reserve_get","text":"Create a reservation request to retrieve an item from the store. This method generates a SimPy event representing a request to reserve an item for retrieval ( get ). The event is assigned attributes such as the resource it belongs to, and the process making the request. The event is then added to reserve_get_queue , which is maintained in the order in which the requests are made, and _trigger_reserve_get() is called to process pending reservations if items are available. Returns: event ( Event ) \u2013 A reservation event that will succeed when an item becomes available. Source code in src/factorysimpy/base/belt_store.py 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 def reserve_get ( self ): \"\"\" Create a reservation request to retrieve an item from the store. This method generates a SimPy event representing a request to reserve an item for retrieval (`get`). The event is assigned attributes such as the resource it belongs to, and the process making the request. The event is then added to `reserve_get_queue`, which is maintained in the order in which the requests are made, and `_trigger_reserve_get()` is called to process pending reservations if items are available. Returns: event (simpy.Event): A reservation event that will succeed when an item becomes available. \"\"\" #adding attributes to the newly created event for reserve_get event = self . env . event () event . resourcename = self event . requesting_process = self . env . active_process # Associate event with the current process self . reserve_get_queue . append ( event ) self . _trigger_reserve_get ( event ) return event","title":"reserve_get"},{"location":"api_ref_main_page_2/#factorysimpy.base.belt_store.BeltStore.reserve_get_cancel","text":"Cancel a previously made reserve_get request. Source code in src/factorysimpy/base/belt_store.py 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 def reserve_get_cancel ( self , get_event_to_cancel ): \"\"\" Cancel a previously made `reserve_get` request. \"\"\" # Case 1: still waiting if get_event_to_cancel in self . reserve_get_queue : self . reserve_get_queue . remove ( get_event_to_cancel ) self . _trigger_reserve_get ( None ) return True # Case 2: already yielded reservation if get_event_to_cancel in self . reservations_get : # 1) Remove from active reservations self . reservations_get . remove ( get_event_to_cancel ) # 2) Find its index in the parallel lists ev_idx = self . reserved_events . index ( get_event_to_cancel ) # 3) Pop out the exact item reference item = self . reserved_items . pop ( ev_idx ) # 4) Drop the event token self . reserved_events . pop ( ev_idx ) # 5) Remove it from ready_items wherever it currently is try : self . ready_items . remove ( item ) except ValueError : raise RuntimeError ( f \"Item { item !r} not found in ready_items during cancel.\" ) # 6) Compute new insertion index insert_idx = len ( self . ready_items ) - len ( self . reserved_events ) - 1 # 7) Re\u2011insert it self . ready_items . insert ( insert_idx , item ) # 8) Trigger any other pending reservations self . _trigger_reserve_get ( None ) return True # No such reservation raise RuntimeError ( \"No matching event in reserve_get_queue or reservations_get\" )","title":"reserve_get_cancel"},{"location":"api_ref_main_page_2/#factorysimpy.base.belt_store.BeltStore.reserve_put","text":"Create a reservation request to put an item into the store. This function generates a SimPy event representing a reservation request. The event is assigned attributes such as resource name, and the process making the request. The event is then added to reserve_put_queue , which is maintained in the order in which the request is made. After adding the event to the queue, _trigger_reserve_put is called to process any pending reservations. Returns: event ( Event ) \u2013 A reservation event that will succeed when space is available. Source code in src/factorysimpy/base/belt_store.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def reserve_put ( self ): \"\"\" Create a reservation request to put an item into the store. This function generates a SimPy event representing a reservation request. The event is assigned attributes such as resource name, and the process making the request. The event is then added to `reserve_put_queue`, which is maintained in the order in which the request is made. After adding the event to the queue, `_trigger_reserve_put` is called to process any pending reservations. Returns: event (simpy.Event): A reservation event that will succeed when space is available. \"\"\" event = self . env . event () event . resourcename = self # Store reference event . requesting_process = self . env . active_process # Process making the reservation self . reserve_put_queue . append ( event ) # Attempt to process reservations self . _trigger_reserve_put ( event ) return event","title":"reserve_put"},{"location":"api_ref_main_page_2/#factorysimpy.base.belt_store.BeltStore.reserve_put_cancel","text":"Cancel a previously made reserve_put request. This method allows a process to cancel its reservation for putting an item into the store. If the reservation exists in the reserve_put_queue , it is removed before triggering _trigger_reserve_put to process any pending reservations. If the reservation is already in reservations_put , it is also removed and _trigger_reserve_put is triggered. Parameters: put_event_to_cancel ( Event ) \u2013 The reservation event that needs to be canceled. Returns: proceed ( bool ) \u2013 True if the reservation was successfully canceled. Raises: RuntimeError \u2013 If the specified event does not exist in reserve_put_queue or reservations_put . Source code in src/factorysimpy/base/belt_store.py 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 def reserve_put_cancel ( self , put_event_to_cancel ): \"\"\" Cancel a previously made `reserve_put` request. This method allows a process to cancel its reservation for putting an item into the store. If the reservation exists in the `reserve_put_queue`, it is removed before triggering `_trigger_reserve_put` to process any pending reservations. If the reservation is already in `reservations_put`, it is also removed and `_trigger_reserve_put` is triggered. Args: put_event_to_cancel (simpy.Event): The reservation event that needs to be canceled. Returns: proceed (bool): True if the reservation was successfully canceled. Raises: RuntimeError: If the specified event does not exist in `reserve_put_queue` or `reservations_put`. \"\"\" #checking and removing the event if it is not yielded and is present in the reserve_put_queue proceed = False if put_event_to_cancel in self . reserve_put_queue : self . reserve_put_queue . remove ( put_event_to_cancel ) self . _trigger_reserve_put ( None ) #if t is removed, then a waiting event can be succeeded, if any proceed = True #checking and removing the event if it is already yielded and is present in the reservations_put elif put_event_to_cancel in self . reservations_put : self . reservations_put . remove ( put_event_to_cancel ) self . _trigger_reserve_put ( None ) #if t is removed, then a waiting event can be succeeded, if any proceed = True else : raise RuntimeError ( \"No matching event in reserve_put_queue or reservations_put for this process\" ) return proceed","title":"reserve_put_cancel"},{"location":"api_ref_main_page_2/#factorysimpy.base.belt_store.BeltStore.resume_all_move_processes","text":"Resume all interrupted move_to_ready_items processes. Source code in src/factorysimpy/base/belt_store.py 774 775 776 777 778 779 780 781 782 783 def resume_all_move_processes ( self ): \"\"\" Resume all interrupted move_to_ready_items processes. \"\"\" print ( f \"T= { self . env . now : .2f } Belt_Store resuming move processes\" ) # Create a new resume event and trigger it old_resume_event = self . resume_event self . resume_event = self . env . event () old_resume_event . succeed ()","title":"resume_all_move_processes"},{"location":"api_ref_main_page_2/#factorysimpy.base.belt_store.BeltStore.selective_interrupt","text":"Perform selective interruption based on belt occupancy patterns and mode. When noaccumulation_mode_on=True (STALLED_NONACCUMULATING_STATE): - Interrupt all items immediately When noaccumulation_mode_on=False (STALLED_ACCUMULATING_STATE): - Use pattern-based interruption with delays based on item positions Pattern-based rules for accumulating mode: - For patterns like '_ *', interrupt all items. - For patterns like '_ _ _', interrupt item in second last position after 1 delay, and second item after 2 delays. - For patterns like ' ___*', interrupt first item and second item after 3 delays. - For patterns like ' __*', interrupt first item, second after 2 delays, and third after 2 delays. Parameters: reason ( str , default: 'Selective interrupt' ) \u2013 Reason for the interrupt Source code in src/factorysimpy/base/belt_store.py 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 def selective_interrupt ( self , reason = \"Selective interrupt\" ): \"\"\" Perform selective interruption based on belt occupancy patterns and mode. When noaccumulation_mode_on=True (STALLED_NONACCUMULATING_STATE): - Interrupt all items immediately When noaccumulation_mode_on=False (STALLED_ACCUMULATING_STATE): - Use pattern-based interruption with delays based on item positions Pattern-based rules for accumulating mode: - For patterns like '_****', interrupt all items. - For patterns like '_*_*_', interrupt item in second last position after 1 delay, and second item after 2 delays. - For patterns like '*___*', interrupt first item and second item after 3 delays. - For patterns like '**__*', interrupt first item, second after 2 delays, and third after 2 delays. Args: reason (str): Reason for the interrupt \"\"\" if not self . items : print ( f \"T= { self . env . now : .2f } No items on belt to interrupt\" ) return # If noaccumulation_mode_on is True (STALLED_NONACCUMULATING_STATE), interrupt all items immediately if self . noaccumulation_mode_on == True : print ( f \"T= { self . env . now : .2f } Noaccumulation_mode_on: interrupting all items immediately\" ) for i , item in enumerate ( self . items ): item_id = item [ 0 ] . id if hasattr ( item [ 0 ], 'id' ) else str ( id ( item )) self . _interrupt_specific_item ( item_id , f \" { reason } - immediate (no accumulation)\" ) return # For accumulating mode (STALLED_ACCUMULATING_STATE), use pattern-based interruption if self . accumulation_mode_indicator == True : #if self.noaccumulation_mode_on == False: print ( f \"T= { self . env . now : .2f } Accumulating mode: using pattern-based interruption\" ) # Get current belt pattern all_patterns = self . _get_belt_pattern () pattern = all_patterns [ 0 ] beltitems = all_patterns [ 1 ] print ( f \"T= { self . env . now : .2f } Current belt pattern: { pattern } and items { beltitems } \" ) # Analyze pattern and determine interruption strategy interruption_plan = self . _analyze_pattern_for_interruption ( all_patterns ) if not interruption_plan : print ( f \"T= { self . env . now : .2f } No interruption needed for current pattern\" ) return print ( f \"T= { self . env . now : .2f } Executing selective interruption plan: { interruption_plan } \" ) # Execute the interruption plan self . _execute_interruption_plan ( interruption_plan , reason )","title":"selective_interrupt"},{"location":"api_ref_main_page_2/#factorysimpy.base.buffer_store","text":"","title":"buffer_store"},{"location":"api_ref_main_page_2/#factorysimpy.base.buffer_store.BufferStore","text":"Bases: Store This is a class that is derived from SimPy's Store class and has extra capabilities that makes it a reservable store for processes to reserve space for storing and retrieving items. Processes can use reserve_put() and reserve_get() methods to get notified when a space becomes available in the store or when an item gets available in the ReservableReqStore. These methods returns a unique event (SimPy.Event) to the process for every reserve requests it makes. get and put are two methods that can be used for item storing and retrieval from ReservableReqStore. Process has to make a prior reservation and pass the associated reservation event as argument in the get and put requests. ReservableReqStore maintains separate queues for reserve_put and reserve_get operations to ensures that only processes with valid reservations can store or retrieve items. ReservableReqStore preserves item order by associating an unreserved item in the store with a reservation event by index when a reserve_get() request is made. As a result, it maintains a list of reserved events to preserve item order. It also allows users to cancel an already placed reserve_get or reserve_put request even if it is yielded. It also handles the dissociation of the event and item done at the time of reservation when an already yielded event is canceled. An item that is added into the BufferStore using put(), it is associated with a delay representing the time it takes for the item to be available for retrieval. The delay can also be 0. The items can be retrieved in FIFO or LIFO manner based on the mode of operation of the BufferStore. Attributes: reserved_events ( list ) \u2013 Maintains events corresponding to reserved items to preserve item order by index reserve_put_queue ( list ) \u2013 Queue for managing reserve_put reservations reservations_put ( list ) \u2013 List of successful put reservations reserve_get_queue ( list ) \u2013 Queue for managing reserve_get reservations reservations_get ( list ) \u2013 List of successful get reservations Args: capacity (int, optional): The maximum number of items the store can hold. Defaults to infinity. mode (str, optional): The mode of the store ('FIFO' or 'LIFO'). Defaults to 'FIFO'. Source code in src/factorysimpy/base/buffer_store.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def __init__ ( self , env , capacity = float ( 'inf' ), mode = 'FIFO' ): \"\"\" Args: capacity (int, optional): The maximum number of items the store can hold. Defaults to infinity. mode (str, optional): The mode of the store ('FIFO' or 'LIFO'). Defaults to 'FIFO'. \"\"\" super () . __init__ ( env , capacity ) self . env = env self . mode = mode self . reserve_put_queue = [] # Queue for managing reserve_put reservations self . reservations_put = [] # List of successful put reservations self . reserve_get_queue = [] # Queue for managing reserve_get reservations self . reservations_get = [] # List of successful get reservations self . reserved_events = [] # Maintains events corresponding to reserved items to preserve item order self . ready_items = [] #Maintains the items ready to be taken out self . reserved_items = [] # parallel list of the exact items reserved self . _last_level_change_time = self . env . now self . _last_num_items = 0 self . _weighted_sum = 0.0 self . time_averaged_num_of_items_in_store = 0.0 # Time-averaged number of items in the store","title":"BufferStore"},{"location":"api_ref_main_page_2/#factorysimpy.base.buffer_store.BufferStore.get","text":"Retrieve an item from the store after a successful reservation. This method attempts to retrieve an item associated with a reserve_get event. If the reservation exists, it triggers _trigger_get to retrieve the item. If successful, _trigger_reserve_put is called to process any pending reserve_put requests. If the item retrieval fails, an error message is raised. Parameters: get_event ( Event ) \u2013 The reservation event associated with the request. Returns: item ( Object ) \u2013 The retrieved item if successful, otherwise raises an error Raises: RuntimeError \u2013 If no reservations are available in the reservations_get RuntimeError \u2013 If item returned is None Source code in src/factorysimpy/base/buffer_store.py 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 def get ( self , get_event ): \"\"\" Retrieve an item from the store after a successful reservation. This method attempts to retrieve an item associated with a `reserve_get` event. If the reservation exists, it triggers `_trigger_get` to retrieve the item. If successful, `_trigger_reserve_put` is called to process any pending `reserve_put` requests. If the item retrieval fails, an error message is raised. Args: get_event (simpy.Event): The reservation event associated with the request. Returns: item (Object): The retrieved item if successful, otherwise raises an error Raises: RuntimeError: If no reservations are available in the reservations_get RuntimeError: If item returned is None \"\"\" item = None #if there are reservations, then call _trigger_get if self . reservations_get : item = self . _trigger_get ( get_event ) #else raise an error else : raise RuntimeError ( \"No matching reservation found for process: reservations_get is empty\" ) #if an item is returned then call _trigger_reserve_put to process pending requests if item is not None : self . _trigger_reserve_put ( None ) if item is None : raise RuntimeError ( f \"No item found in the store for { get_event . requesting_process } and get request failed\" ) else : #self._update_time_averaged_level() return item","title":"get"},{"location":"api_ref_main_page_2/#factorysimpy.base.buffer_store.BufferStore.move_to_ready_items","text":"Move items from the store to the ready_items list after a put operation. This method is called as a process to ensure that items are moved asynchronously. Source code in src/factorysimpy/base/buffer_store.py 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 def move_to_ready_items ( self , item ): \"\"\" Move items from the store to the ready_items list after a put operation. This method is called as a process to ensure that items are moved asynchronously. \"\"\" # Move items to the ready_items list if self . items : #print(f\"T={self.env.now:.2f} beltstore received an item {item[0].id, item[1]} . Item started moving in belt\") yield self . env . timeout ( item [ 1 ]) #print(f\"T={self.env.now:.2f} bufferstore finished moving item {item[0].id, item[1]} going to ready_items\") item_index = self . items . index ( item ) item_to_put = self . items . pop ( item_index ) # Remove the first item #print(item_to_put, item) if len ( self . ready_items ) + len ( self . items ) < self . capacity : self . ready_items . append ( item_to_put [ 0 ]) #print(f\"T={self.env.now:.2f} bufferstore finished moving item {item[0].id, item[1]} moved to ready_items\") self . _trigger_reserve_get ( None ) self . _trigger_reserve_put ( None ) #print(f\"T={self.env.now:.2f} bufferstore is moving item {item[0].id, item[1]} to ready_items. Total items in buffer is {len(self.items)+len(self.ready_items)}\" ) else : raise RuntimeError ( \"Total number of items in the store exceeds capacity. Cannot move item to ready_items.\" )","title":"move_to_ready_items"},{"location":"api_ref_main_page_2/#factorysimpy.base.buffer_store.BufferStore.put","text":"Perform a put operation on the store and trigger any pending reserve_get requests. Ensures that only processes with a valid reservation can put items into the store. If the put operation succeeds, it triggers _trigger_reserve_get to process pending get requests. Parameters: put_event ( Event ) \u2013 The event corresponding to the reservation. item ( object ) \u2013 The item to be added to the store. Returns: proceed ( bool ) \u2013 True if the put operation succeeded, False otherwise. Raises: RuntimeError \u2013 If no reservations are available in the reservations_put RuntimeError \u2013 If proceed is False after put operation Source code in src/factorysimpy/base/buffer_store.py 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 def put ( self , put_event , item ): \"\"\" Perform a `put` operation on the store and trigger any pending `reserve_get` requests. Ensures that only processes with a valid reservation can put items into the store. If the put operation succeeds, it triggers `_trigger_reserve_get` to process pending get requests. Args: put_event (simpy.Event): The event corresponding to the reservation. item (object): The item to be added to the store. Returns: proceed (bool): True if the put operation succeeded, False otherwise. Raises: RuntimeError: If no reservations are available in the reservations_put RuntimeError: If proceed is False after put operation \"\"\" proceed = False if self . reservations_put : proceed = self . _trigger_put ( put_event , item ) else : raise RuntimeError ( \"No matching reservation found for process: reservations_put is empty\" ) if proceed : #print(f\"{self.env.now} proceed\") #self._trigger_get(None) self . _trigger_reserve_get ( None ) if not proceed : raise RuntimeError ( f \"No matching put_event found in the reservations and put failed for { item } \" ) else : #self._update_time_averaged_level() return proceed","title":"put"},{"location":"api_ref_main_page_2/#factorysimpy.base.buffer_store.BufferStore.reserve_get","text":"Create a reservation request to retrieve an item from the store. This method generates a SimPy event representing a request to reserve an item for retrieval ( get ). The event is assigned attributes such as the resource it belongs to, and the process making the request. The event is then added to reserve_get_queue , which is maintained in the order in which the requests are made, and _trigger_reserve_get() is called to process pending reservations if items are available. Returns: event ( Event ) \u2013 A reservation event that will succeed when an item becomes available. Source code in src/factorysimpy/base/buffer_store.py 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 def reserve_get ( self ): \"\"\" Create a reservation request to retrieve an item from the store. This method generates a SimPy event representing a request to reserve an item for retrieval (`get`). The event is assigned attributes such as the resource it belongs to, and the process making the request. The event is then added to `reserve_get_queue`, which is maintained in the order in which the requests are made, and `_trigger_reserve_get()` is called to process pending reservations if items are available. Returns: event (simpy.Event): A reservation event that will succeed when an item becomes available. \"\"\" #adding attributes to the newly created event for reserve_get event = self . env . event () event . resourcename = self event . requesting_process = self . env . active_process # Associate event with the current process self . reserve_get_queue . append ( event ) self . _trigger_reserve_get ( event ) return event","title":"reserve_get"},{"location":"api_ref_main_page_2/#factorysimpy.base.buffer_store.BufferStore.reserve_get_cancel","text":"Cancel a previously made reserve_get request. Source code in src/factorysimpy/base/buffer_store.py 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 def reserve_get_cancel ( self , get_event_to_cancel ): \"\"\" Cancel a previously made `reserve_get` request. \"\"\" # Case 1: still waiting if get_event_to_cancel in self . reserve_get_queue : self . reserve_get_queue . remove ( get_event_to_cancel ) self . _trigger_reserve_get ( None ) return True # Case 2: already yielded reservation if get_event_to_cancel in self . reservations_get : # 1) Remove from active reservations self . reservations_get . remove ( get_event_to_cancel ) # 2) Find its index in the parallel lists ev_idx = self . reserved_events . index ( get_event_to_cancel ) # 3) Pop out the exact item reference item = self . reserved_items . pop ( ev_idx ) # 4) Drop the event token self . reserved_events . pop ( ev_idx ) # 5) Remove it from ready_items wherever it currently is try : self . ready_items . remove ( item ) except ValueError : raise RuntimeError ( f \"Item { item } not found in ready_items during cancel.\" ) # 6) Compute new insertion index as a get call is cancelled and item that is reserved and associated to an event is now freely available to be assigned to a new incoming event if self . mode == \"FIFO\" : # one slot before the remaining reserved block insert_idx = len ( self . ready_items ) - len ( self . reserved_events ) - 1 else : # LIFO # top of stack insert_idx = len ( self . ready_items ) # 7) Re\u2011insert it self . ready_items . insert ( insert_idx , item ) # 8) Trigger any other pending reservations self . _trigger_reserve_get ( None ) return True # No such reservation raise RuntimeError ( \"No matching event in reserve_get_queue or reservations_get\" )","title":"reserve_get_cancel"},{"location":"api_ref_main_page_2/#factorysimpy.base.buffer_store.BufferStore.reserve_put","text":"Create a reservation request to put an item into the store. This function generates a SimPy event representing a reservation request. The event is assigned attributes such as resource name, and the process making the request. The event is then added to reserve_put_queue , which is maintained in the order in which the requests are made. After adding the event to the queue, _trigger_reserve_put is called to process any pending reservations. Returns: event ( Event ) \u2013 A reservation event that will succeed when space is available. Source code in src/factorysimpy/base/buffer_store.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 def reserve_put ( self ): \"\"\" Create a reservation request to put an item into the store. This function generates a SimPy event representing a reservation request. The event is assigned attributes such as resource name, and the process making the request. The event is then added to `reserve_put_queue`, which is maintained in the order in which the requests are made. After adding the event to the queue, `_trigger_reserve_put` is called to process any pending reservations. Returns: event (simpy.Event): A reservation event that will succeed when space is available. \"\"\" event = self . env . event () event . resourcename = self # Store reference event . requesting_process = self . env . active_process # Process making the reservation self . reserve_put_queue . append ( event ) # Attempt to process reservations self . _trigger_reserve_put ( event ) return event","title":"reserve_put"},{"location":"api_ref_main_page_2/#factorysimpy.base.buffer_store.BufferStore.reserve_put_cancel","text":"Cancel a previously made reserve_put request. This method allows a process to cancel its reservation for putting an item into the store. If the reservation exists in the reserve_put_queue , it is removed before triggering _trigger_reserve_put to process any pending reservations. If the reservation is already in reservations_put , it is also removed and _trigger_reserve_put is triggered. Parameters: put_event_to_cancel ( Event ) \u2013 The reservation event that needs to be canceled. Returns: proceed ( bool ) \u2013 True if the reservation was successfully canceled. Raises: RuntimeError \u2013 If the specified event does not exist in reserve_put_queue or reservations_put . Source code in src/factorysimpy/base/buffer_store.py 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 def reserve_put_cancel ( self , put_event_to_cancel ): \"\"\" Cancel a previously made `reserve_put` request. This method allows a process to cancel its reservation for putting an item into the store. If the reservation exists in the `reserve_put_queue`, it is removed before triggering `_trigger_reserve_put` to process any pending reservations. If the reservation is already in `reservations_put`, it is also removed and `_trigger_reserve_put` is triggered. Args: put_event_to_cancel (simpy.Event): The reservation event that needs to be canceled. Returns: proceed (bool): True if the reservation was successfully canceled. Raises: RuntimeError: If the specified event does not exist in `reserve_put_queue` or `reservations_put`. \"\"\" #checking and removing the event if it is not yielded and is present in the reserve_put_queue proceed = False if put_event_to_cancel in self . reserve_put_queue : self . reserve_put_queue . remove ( put_event_to_cancel ) self . _trigger_reserve_put ( None ) #if t is removed, then a waiting event can be succeeded, if any proceed = True #checking and removing the event if it is already yielded and is present in the reservations_put elif put_event_to_cancel in self . reservations_put : self . reservations_put . remove ( put_event_to_cancel ) self . _trigger_reserve_put ( None ) #if t is removed, then a waiting event can be succeeded, if any proceed = True else : raise RuntimeError ( \"No matching event in reserve_put_queue or reservations_put for this process\" ) return proceed","title":"reserve_put_cancel"},{"location":"api_ref_main_page_2/#factorysimpy.base.fleet_store","text":"","title":"fleet_store"},{"location":"api_ref_main_page_2/#factorysimpy.base.fleet_store.FleetStore","text":"Bases: Store This is a class that is derived from SimPy's Store class and has extra capabilities that makes it a priority-based reservable store for processes to reserve space for storing and retrieving items with priority-based access. Processes can use reserve_put() and reserve_get() methods to get notified when a space becomes available in the store or when an item gets available in the ReservablePriorityReqStore. These methods returns a unique event (SimPy.Event) to the process for every reserve requests it makes. Processes can also pass a priority as argument in the request. Lower values indicate higher priority. get and put are two methods that can be used for item storing and retrieval from ReservablePriorityReqStore. Process has to make a prior reservation and pass the associated reservation event as argument in the get and put requests. ReservablePriorityReqStore maintains separate queues for reserve_put and reserve_get operations to ensures that only processes with valid reservations can store or retrieve items. ReservablePriorityReqStore preserves item order by associating an unreserved item in the store with a reservation event by index when a reserve_get() request is made. As a result, it maintains a list of reserved events to preserve item order. It also allows users to cancel an already placed reserve_get or reserve_put request even if it is yielded. It also handles the dissociation of the event and item done at the time of reservation when an already yielded event is canceled. Attributes: reserved_events ( list ) \u2013 Maintains events corresponding to reserved items to preserve item order by index reserve_put_queue ( list ) \u2013 Queue for managing reserve_put reservations reservations_put ( list ) \u2013 List of successful put reservations reserve_get_queue ( list ) \u2013 Queue for managing reserve_get reservations reservations_get ( list ) \u2013 List of successful get reservations Initializes a reservable store with priority-based reservations. Parameters: env ( Environment ) \u2013 The simulation environment. capacity ( int , default: float ('inf') ) \u2013 target quantity of items after which the fleet will be activated Defaults to infinity. delay ( ( int , float ) , default: 1 ) \u2013 Delay after which fleet activates to move items incase the target capacity is not reached. transit_delay ( ( int , float ) , default: 0 ) \u2013 Time to move the items after which the item becomes available. Can be a constant, generator, or callable. Defaults to 0. Source code in src/factorysimpy/base/fleet_store.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def __init__ ( self , env , capacity = float ( 'inf' ), delay = 1 , transit_delay = 0 ): \"\"\" Initializes a reservable store with priority-based reservations. Args: env (simpy.Environment): The simulation environment. capacity (int, optional): target quantity of items after which the fleet will be activated Defaults to infinity. delay (int, float, optional): Delay after which fleet activates to move items incase the target capacity is not reached. transit_delay (int, float, optional): Time to move the items after which the item becomes available. Can be a constant, generator, or callable. Defaults to 0. \"\"\" super () . __init__ ( env , capacity ) self . env = env self . delay = delay self . transit_delay = transit_delay self . reserve_put_queue = [] # Queue for managing reserve_put reservations self . reservations_put = [] # List of successful put reservations self . reserve_get_queue = [] # Queue for managing reserve_get reservations self . reservations_get = [] # List of successful get reservations self . reserved_events = [] # Maintains events corresponding to reserved items to preserve item order self . ready_items = [] #Maintains the items ready to be taken out self . reserved_items = [] # parallel list of the exact items reserved self . _last_level_change_time = self . env . now self . _last_num_items = 0 self . _weighted_sum = 0.0 self . time_averaged_num_of_items_in_store = 0.0 # Time-averaged number of items in the store self . activate_fleet = self . env . event () # Event to activate the fleet when items are available self . env . process ( self . fleet_activation_process ()) # Start the fleet activation process","title":"FleetStore"},{"location":"api_ref_main_page_2/#factorysimpy.base.fleet_store.FleetStore.fleet_activation_process","text":"Process to activate the fleet when items are available but not equivalent to self.capacity(level not achieved). This process waits for the activate_fleet event to be triggered. Source code in src/factorysimpy/base/fleet_store.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 def fleet_activation_process ( self ,): \"\"\" Process to activate the fleet when items are available but not equivalent to self.capacity(level not achieved). This process waits for the activate_fleet event to be triggered. \"\"\" while True : timeout_event = self . env . timeout ( self . delay ) event_list = [ timeout_event , self . activate_fleet ] yield self . env . any_of ( event_list ) print ( f \"T= { self . env . now : .2f } : Fleet activation process triggered.\" ) if self . items : print ( f \"T= { self . env . now : .2f } : Fleet activated with { len ( self . items ) } items ready.\" ) self . env . process ( self . move_to_ready_items ( self . items )) #self.env.process(self.move_to_ready_items(self.items)) if self . activate_fleet . triggered : #print(\"yes\") self . activate_fleet = self . env . event () # Reset the event for next activation","title":"fleet_activation_process"},{"location":"api_ref_main_page_2/#factorysimpy.base.fleet_store.FleetStore.get","text":"Retrieve an item from the store after a successful reservation. This method attempts to retrieve an item associated with a reserve_get event. If the reservation exists, it triggers _trigger_get to retrieve the item. If successful, _trigger_reserve_put is called to process any pending reserve_put requests. If the item retrieval fails, an error message is raised. Parameters: get_event ( Event ) \u2013 The reservation event associated with the request. Returns: item ( Object ) \u2013 The retrieved item if successful, otherwise raises an error Raises: RuntimeError \u2013 If no reservations are available in the reservations_get RuntimeError \u2013 If item returned is None Source code in src/factorysimpy/base/fleet_store.py 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 def get ( self , get_event ): \"\"\" Retrieve an item from the store after a successful reservation. This method attempts to retrieve an item associated with a `reserve_get` event. If the reservation exists, it triggers `_trigger_get` to retrieve the item. If successful, `_trigger_reserve_put` is called to process any pending `reserve_put` requests. If the item retrieval fails, an error message is raised. Args: get_event (simpy.Event): The reservation event associated with the request. Returns: item (Object): The retrieved item if successful, otherwise raises an error Raises: RuntimeError: If no reservations are available in the reservations_get RuntimeError: If item returned is None \"\"\" item = None #if there are reservations, then call _trigger_get if self . reservations_get : item = self . _trigger_get ( get_event ) #else raise an error else : raise RuntimeError ( \"No matching reservation found for process: reservations_get is empty\" ) #if an item is returned then call _trigger_reserve_put to process pending requests if item is not None : self . _trigger_reserve_put ( None ) if item is None : raise RuntimeError ( f \"No item found in the store for { get_event . requesting_process } and get request failed\" ) else : #self._update_time_averaged_level() return item","title":"get"},{"location":"api_ref_main_page_2/#factorysimpy.base.fleet_store.FleetStore.move_to_ready_items","text":"Move items from the store to the ready_items list after a put operation. This method is called as a process to ensure that items are moved asynchronously. Source code in src/factorysimpy/base/fleet_store.py 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 def move_to_ready_items ( self , items ): \"\"\" Move items from the store to the ready_items list after a put operation. This method is called as a process to ensure that items are moved asynchronously. \"\"\" # Move items to the ready_items list if items : print ( f \"T= { self . env . now : .2f } : Moving items to ready_items.\" ) #START=self.env.now yield self . env . timeout ( self . transit_delay ) #print(\"WAITED FOR TRANSIT_DELAY BEFORE MOVING\", self.env.now-START) yield self . env . timeout ( self . transit_delay ) for item in items : item_index = self . items . index ( item ) item_to_put = self . items . pop ( item_index ) # Remove the first item if len ( self . ready_items ) < self . capacity : self . ready_items . append ( item_to_put ) #print(f\"T={self.env.now:.2f}: {self.id} moved item {item_to_put.id} to ready_items.\") self . _trigger_reserve_get ( None ) self . _trigger_reserve_put ( None ) #print(f\"T={self.env.now:.2f} bufferstore is moving item {item[0].id, item[1]} to ready_items. Total items in buffer is {len(self.items)+len(self.ready_items)}\" ) else : raise RuntimeError ( \"Total number of items in the store exceeds capacity. Cannot move item to ready_items.\" ) print ( f \"T= { self . env . now : .2f } : Fleetstore moved items to ready_items.\" )","title":"move_to_ready_items"},{"location":"api_ref_main_page_2/#factorysimpy.base.fleet_store.FleetStore.put","text":"Perform a put operation on the store and trigger any pending reserve_get requests. Ensures that only processes with a valid reservation can put items into the store. If the put operation succeeds, it triggers _trigger_reserve_get to process pending get requests. Parameters: put_event ( Event ) \u2013 The event corresponding to the reservation. item ( object ) \u2013 The item to be added to the store. Returns: proceed ( bool ) \u2013 True if the put operation succeeded, False otherwise. Raises: RuntimeError \u2013 If no reservations are available in the reservations_put RuntimeError \u2013 If proceed is False after put operation Source code in src/factorysimpy/base/fleet_store.py 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 def put ( self , put_event , item ): \"\"\" Perform a `put` operation on the store and trigger any pending `reserve_get` requests. Ensures that only processes with a valid reservation can put items into the store. If the put operation succeeds, it triggers `_trigger_reserve_get` to process pending get requests. Args: put_event (simpy.Event): The event corresponding to the reservation. item (object): The item to be added to the store. Returns: proceed (bool): True if the put operation succeeded, False otherwise. Raises: RuntimeError: If no reservations are available in the reservations_put RuntimeError: If proceed is False after put operation \"\"\" proceed = False if self . reservations_put : proceed = self . _trigger_put ( put_event , item ) else : raise RuntimeError ( \"No matching reservation found for process: reservations_put is empty\" ) if proceed : #print(f\"{self.env.now} proceed\") #self._trigger_get(None) self . _trigger_reserve_get ( None ) if not proceed : raise RuntimeError ( f \"No matching put_event found in the reservations and put failed for { item } \" ) else : #self._update_time_averaged_level() return proceed","title":"put"},{"location":"api_ref_main_page_2/#factorysimpy.base.fleet_store.FleetStore.reserve_get","text":"Create a reservation request to retrieve an item from the store. This method generates a SimPy event representing a request to reserve an item for retrieval ( get ). The event is assigned attributes such as priority, the resource it belongs to, and the process making the request. The event is then added to reserve_get_queue , which is maintained in priority order, and _trigger_reserve_get() is called to process pending reservations if items are available. Parameters: priority ( int , default: 0 ) \u2013 The priority level of the reservation request. Lower values indicate higher priority. Defaults to 0. Returns: event ( Event ) \u2013 A reservation event that will succeed when an item becomes available. Source code in src/factorysimpy/base/fleet_store.py 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 def reserve_get ( self , priority = 0 ): \"\"\" Create a reservation request to retrieve an item from the store. This method generates a SimPy event representing a request to reserve an item for retrieval (`get`). The event is assigned attributes such as priority, the resource it belongs to, and the process making the request. The event is then added to `reserve_get_queue`, which is maintained in priority order, and `_trigger_reserve_get()` is called to process pending reservations if items are available. Args: priority (int, optional): The priority level of the reservation request. Lower values indicate higher priority. Defaults to 0. Returns: event (simpy.Event): A reservation event that will succeed when an item becomes available. \"\"\" #adding attributes to the newly created event for reserve_get event = self . env . event () event . resourcename = self event . requesting_process = self . env . active_process # Associate event with the current process #event.priority_to_get = (priority, self._env.now) event . priority_to_get = priority #sorting the list based on priority after appending the new event self . reserve_get_queue . append ( event ) self . reserve_get_queue . sort ( key = lambda e : e . priority_to_get ) self . _trigger_reserve_get ( event ) return event","title":"reserve_get"},{"location":"api_ref_main_page_2/#factorysimpy.base.fleet_store.FleetStore.reserve_get_cancel","text":"Cancel a previously made reserve_get request. Source code in src/factorysimpy/base/fleet_store.py 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 def reserve_get_cancel ( self , get_event_to_cancel ): \"\"\" Cancel a previously made `reserve_get` request. \"\"\" # Case 1: still waiting if get_event_to_cancel in self . reserve_get_queue : self . reserve_get_queue . remove ( get_event_to_cancel ) self . _trigger_reserve_get ( None ) return True # Case 2: already yielded reservation if get_event_to_cancel in self . reservations_get : # 1) Remove from active reservations self . reservations_get . remove ( get_event_to_cancel ) # 2) Find its index in the parallel lists ev_idx = self . reserved_events . index ( get_event_to_cancel ) # 3) Pop out the exact item reference item = self . reserved_items . pop ( ev_idx ) # 4) Drop the event token self . reserved_events . pop ( ev_idx ) # 5) Remove it from ready_items wherever it currently is try : self . ready_items . remove ( item ) except ValueError : raise RuntimeError ( f \"Item { item !r} not found in ready_items during cancel.\" ) # 6) Compute new insertion index # \"FIFO\": # one slot before the remaining reserved block insert_idx = len ( self . ready_items ) - len ( self . reserved_events ) - 1 # 7) Re\u2011insert it self . ready_items . insert ( insert_idx , item ) # 8) Trigger any other pending reservations self . _trigger_reserve_get ( None ) return True # No such reservation raise RuntimeError ( \"No matching event in reserve_get_queue or reservations_get\" )","title":"reserve_get_cancel"},{"location":"api_ref_main_page_2/#factorysimpy.base.fleet_store.FleetStore.reserve_get_cancel1","text":"Cancel a previously made reserve_get request. This method allows a process to cancel its reservation for retrieving an item from the store. If the reservation exists in the reserve_get_queue , it is removed, and _trigger_reserve_get() is called to process any remaining reservations. If the reservation is already in reservations_get , it is removed, and the corresponding item is repositioned in the store to maintain order. _trigger_reserve_get() is then triggered to handle pending reservations. Parameters: get_event_to_cancel ( Event ) \u2013 The reservation event that needs to be canceled. Returns: proceed ( bool ) \u2013 True if the reservation was successfully canceled. Raises: RuntimeError \u2013 If the specified event does not exist in reserve_get_queue or reservations_get . Source code in src/factorysimpy/base/fleet_store.py 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 def reserve_get_cancel1 ( self , get_event_to_cancel ): \"\"\" Cancel a previously made `reserve_get` request. This method allows a process to cancel its reservation for retrieving an item from the store. If the reservation exists in the `reserve_get_queue`, it is removed, and `_trigger_reserve_get()` is called to process any remaining reservations. If the reservation is already in `reservations_get`, it is removed, and the corresponding item is repositioned in the store to maintain order. `_trigger_reserve_get()` is then triggered to handle pending reservations. Args: get_event_to_cancel (simpy.Event): The reservation event that needs to be canceled. Returns: proceed (bool): True if the reservation was successfully canceled. Raises: RuntimeError: If the specified event does not exist in `reserve_get_queue` or `reservations_get`. \"\"\" proceed = False #checking and removing the event if it is not yielded and is present in the reserve_get_queue if get_event_to_cancel in self . reserve_get_queue : self . reserve_get_queue . remove ( get_event_to_cancel ) self . _trigger_reserve_get ( None ) #if t is removed, then a waiting event can be succeeded, if any proceed = True #checking and removing the event if it is already yielded and is present in the reservations_queue. # 1-to-1 association with items done to preserve item order should also be removed. elif get_event_to_cancel in self . reservations_get : self . reservations_get . remove ( get_event_to_cancel ) #deleting the associated event in the reserved_events list to preserve the order of the items #finding index of the item event_in_index = self . reserved_events . index ( get_event_to_cancel ) delta_position = len ( self . reserved_events ) #shifting the item item_to_shift = self . items . pop ( event_in_index ) self . items . insert ( delta_position - 1 , item_to_shift ) #deleting the event self . reserved_events . pop ( event_in_index ) #if t is removed, then a waiting event can be succeeded, if any self . _trigger_reserve_get ( None ) proceed = True else : raise RuntimeError ( \"No matching event in reserve_get_queue or reservations_get for this process\" ) return proceed","title":"reserve_get_cancel1"},{"location":"api_ref_main_page_2/#factorysimpy.base.fleet_store.FleetStore.reserve_put","text":"Create a reservation request to put an item into the store. This function generates a SimPy event representing a reservation request. The event is assigned attributes such as priority, resource name, and the process making the request. The event is then added to reserve_put_queue , which is maintained in priority order. After adding the event to the queue, _trigger_reserve_put is called to process any pending reservations. Parameters: priority ( int , default: 0 ) \u2013 The priority level of the reservation request. Lower values indicate higher priority. Defaults to 0. Returns: event ( Event ) \u2013 A reservation event that will succeed when space is available. Source code in src/factorysimpy/base/fleet_store.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 def reserve_put ( self , priority = 0 ): \"\"\" Create a reservation request to put an item into the store. This function generates a SimPy event representing a reservation request. The event is assigned attributes such as priority, resource name, and the process making the request. The event is then added to `reserve_put_queue`, which is maintained in priority order. After adding the event to the queue, `_trigger_reserve_put` is called to process any pending reservations. Args: priority (int, optional): The priority level of the reservation request. Lower values indicate higher priority. Defaults to 0. Returns: event (simpy.Event): A reservation event that will succeed when space is available. \"\"\" event = self . env . event () event . resourcename = self # Store reference event . requesting_process = self . env . active_process # Process making the reservation event . priority_to_put = priority # Priority for sorting reservations # Add the event to the reservation queue and sort by priority self . reserve_put_queue . append ( event ) self . reserve_put_queue . sort ( key = lambda e : e . priority_to_put ) # Attempt to process reservations self . _trigger_reserve_put ( event ) return event","title":"reserve_put"},{"location":"api_ref_main_page_2/#factorysimpy.base.fleet_store.FleetStore.reserve_put_cancel","text":"Cancel a previously made reserve_put request. This method allows a process to cancel its reservation for putting an item into the store. If the reservation exists in the reserve_put_queue , it is removed before triggering _trigger_reserve_put to process any pending reservations. If the reservation is already in reservations_put , it is also removed and _trigger_reserve_put is triggered. Parameters: put_event_to_cancel ( Event ) \u2013 The reservation event that needs to be canceled. Returns: proceed ( bool ) \u2013 True if the reservation was successfully canceled. Raises: RuntimeError \u2013 If the specified event does not exist in reserve_put_queue or reservations_put . Source code in src/factorysimpy/base/fleet_store.py 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 def reserve_put_cancel ( self , put_event_to_cancel ): \"\"\" Cancel a previously made `reserve_put` request. This method allows a process to cancel its reservation for putting an item into the store. If the reservation exists in the `reserve_put_queue`, it is removed before triggering `_trigger_reserve_put` to process any pending reservations. If the reservation is already in `reservations_put`, it is also removed and `_trigger_reserve_put` is triggered. Args: put_event_to_cancel (simpy.Event): The reservation event that needs to be canceled. Returns: proceed (bool): True if the reservation was successfully canceled. Raises: RuntimeError: If the specified event does not exist in `reserve_put_queue` or `reservations_put`. \"\"\" #checking and removing the event if it is not yielded and is present in the reserve_put_queue proceed = False if put_event_to_cancel in self . reserve_put_queue : self . reserve_put_queue . remove ( put_event_to_cancel ) self . _trigger_reserve_put ( None ) #if t is removed, then a waiting event can be succeeded, if any proceed = True #checking and removing the event if it is already yielded and is present in the reservations_put elif put_event_to_cancel in self . reservations_put : self . reservations_put . remove ( put_event_to_cancel ) self . _trigger_reserve_put ( None ) #if t is removed, then a waiting event can be succeeded, if any proceed = True else : raise RuntimeError ( \"No matching event in reserve_put_queue or reservations_put for this process\" ) return proceed","title":"reserve_put_cancel"},{"location":"api_ref_main_page_2/#factorysimpy.base.priority_req_store","text":"","title":"priority_req_store"},{"location":"api_ref_main_page_2/#factorysimpy.base.priority_req_store.PriorityGet","text":"Bases: Get Source code in src/factorysimpy/base/priority_req_store.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def __init__ ( self , resource , priority = 0 , ): self . priority = priority \"\"\"The priority of this request. A smaller number means higher priority.\"\"\" self . time = resource . _env . now \"\"\"The time at which the request was made.\"\"\" self . key = ( self . priority , self . time ) #print(\"Resource is \", resource) super () . __init__ ( resource )","title":"PriorityGet"},{"location":"api_ref_main_page_2/#factorysimpy.base.priority_req_store.PriorityGet.priority","text":"The priority of this request. A smaller number means higher priority.","title":"priority"},{"location":"api_ref_main_page_2/#factorysimpy.base.priority_req_store.PriorityGet.time","text":"The time at which the request was made.","title":"time"},{"location":"api_ref_main_page_2/#factorysimpy.base.priority_req_store.PriorityPut","text":"Bases: Put Source code in src/factorysimpy/base/priority_req_store.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def __init__ ( self , resource , item , priority = 0 , ): self . priority = priority \"\"\"The priority of this request. A smaller number means higher priority.\"\"\" self . time = resource . _env . now \"\"\"The time at which the request was made.\"\"\" self . key = ( self . priority , self . time ) self . item = item #print(\"Resource is \", resource) super () . __init__ ( resource )","title":"PriorityPut"},{"location":"api_ref_main_page_2/#factorysimpy.base.priority_req_store.PriorityPut.priority","text":"The priority of this request. A smaller number means higher priority.","title":"priority"},{"location":"api_ref_main_page_2/#factorysimpy.base.priority_req_store.PriorityPut.time","text":"The time at which the request was made.","title":"time"},{"location":"api_ref_main_page_2/#factorysimpy.base.priority_req_store.PriorityReqStore","text":"Bases: Store This is a class derived from SimPy's Store class and has extra capabilities that makes it a priority-based store for put and get. Processes can pass a priority as argument in the put and get request. Request with lower values of priority yields first among all get(or put) requests. If two requests with same priority are placed from two processes then FIFO order is followed to yield the requests. Source code in src/factorysimpy/base/priority_req_store.py 87 88 def __init__ ( self , env , capacity = 1 ): super () . __init__ ( env , capacity )","title":"PriorityReqStore"},{"location":"api_ref_main_page_2/#factorysimpy.base.priority_req_store.PriorityReqStore.get","text":"yields a get request with the given priority .","title":"get"},{"location":"api_ref_main_page_2/#factorysimpy.base.priority_req_store.PriorityReqStore.put","text":"yields a put request with the given priority","title":"put"},{"location":"api_ref_main_page_2/#factorysimpy.base.priority_req_store.SortedQueue","text":"Bases: list Queue for sorting events by their :attr: ~PriorityRequest.key attribute. Source code in src/factorysimpy/base/priority_req_store.py 15 16 17 18 def __init__ ( self , maxlen = None ): super () . __init__ () self . maxlen = maxlen \"\"\"Maximum length of the queue.\"\"\"","title":"SortedQueue"},{"location":"api_ref_main_page_2/#factorysimpy.base.priority_req_store.SortedQueue.maxlen","text":"Maximum length of the queue.","title":"maxlen"},{"location":"api_ref_main_page_2/#factorysimpy.base.priority_req_store.SortedQueue.append","text":"Sort item into the queue. Raise a :exc: RuntimeError if the queue is full. Source code in src/factorysimpy/base/priority_req_store.py 20 21 22 23 24 25 26 27 28 29 30 def append ( self , item ) -> None : \"\"\"Sort *item* into the queue. Raise a :exc:`RuntimeError` if the queue is full. \"\"\" if self . maxlen is not None and len ( self ) >= self . maxlen : raise RuntimeError ( 'Cannot append event. Queue is full.' ) super () . append ( item ) super () . sort ( key = lambda e : e . key )","title":"append"},{"location":"api_ref_main_page_2/#factorysimpy.base.reservable_priority_req_filter_store","text":"","title":"reservable_priority_req_filter_store"},{"location":"api_ref_main_page_2/#factorysimpy.base.reservable_priority_req_filter_store.ReservablePriorityReqFilterStore","text":"Bases: FilterStore This is a class that is derived from SimPy's Store class and has extra capabilities that makes it a priority-based reservable store for processes to reserve space for storing and retrieving items with priority-based access. It supports user tp only get items that match a user criteria Processes can use reserve_put() and reserve_get() methods to get notified when a space becomes available in the store or when an item gets available in the ReservablePriorityReqStore. These methods returns a unique event (SimPy.Event) to the process for every reserve requests it makes. Processes can also pass a priority as argument in the request. Lower values indicate higher priority. Filter to be used while using \"get\" can be passed in the reserve_get request. get and put are two methods that can be used for item storing and retrieval from ReservablePriorityReqStore. Process has to make a prior reservation and pass the associated reservation event as argument in the get and put requests. ReservablePriorityReqStore maintains separate queues for reserve_put and reserve_get operations to ensures that only processes with valid reservations can store or retrieve items. ReservablePriorityReqStore preserves item order by associating an unreserved item in the store with a reservation event by index when a reserve_get() request is made. As a result, it maintains a list of reserved events to preserve item order. It also allows users to cancel an already placed reserve_get or reserve_put request even if it is yielded. It also handles the dissociation of the event and item done at the time of reservation when an already yielded event is canceled. Attributes: reserved_events ( list ) \u2013 Maintains events corresponding to reserved items to preserve item order by index reserve_put_queue ( list ) \u2013 Queue for managing reserve_put reservations reservations_put ( list ) \u2013 List of successful put reservations reserve_get_queue ( list ) \u2013 Queue for managing reserve_get reservations reservations_get ( list ) \u2013 List of successful get reservations trigger_delay ( int ) \u2013 Delay time after which a trigger_reserve_get is called to allow waiting get calls to succeed. Initializes a reservable store with priority-based reservations. Args: capacity (int, optional): The maximum number of items the store can hold. Defaults to infinity. Source code in src/factorysimpy/base/reservable_priority_req_filter_store.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def __init__ ( self , env , capacity = float ( 'inf' ), trigger_delay = 0 ): \"\"\" Initializes a reservable store with priority-based reservations. Args: capacity (int, optional): The maximum number of items the store can hold. Defaults to infinity. \"\"\" super () . __init__ ( env , capacity ) self . env = env self . trigger_delay = trigger_delay self . reserve_put_queue = [] # Queue for managing reserve_put reservations self . reservations_put = [] # List of successful put reservations self . reserve_get_queue = [] # Queue for managing reserve_get reservations self . reservations_get = [] # List of successful get reservations self . reserved_events = [] # Maintains events corresponding to reserved items to preserve item order","title":"ReservablePriorityReqFilterStore"},{"location":"api_ref_main_page_2/#factorysimpy.base.reservable_priority_req_filter_store.ReservablePriorityReqFilterStore.get","text":"Retrieve an item from the store after a successful reservation. This method attempts to retrieve an item associated with a reserve_get event. If the reservation exists, it triggers _trigger_get to retrieve the item. If successful, _trigger_reserve_put is called to process any pending reserve_put requests. If the item retrieval fails, an error message is raised. Parameters: get_event ( Event ) \u2013 The reservation event associated with the request. Returns: item ( Object ) \u2013 The retrieved item if successful, otherwise raises an error Raises: RuntimeError \u2013 If no reservations are available in the reservations_get RuntimeError \u2013 If item returned is None Source code in src/factorysimpy/base/reservable_priority_req_filter_store.py 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 def get ( self , get_event ): \"\"\" Retrieve an item from the store after a successful reservation. This method attempts to retrieve an item associated with a `reserve_get` event. If the reservation exists, it triggers `_trigger_get` to retrieve the item. If successful, `_trigger_reserve_put` is called to process any pending `reserve_put` requests. If the item retrieval fails, an error message is raised. Args: get_event (simpy.Event): The reservation event associated with the request. Returns: item (Object): The retrieved item if successful, otherwise raises an error Raises: RuntimeError: If no reservations are available in the reservations_get RuntimeError: If item returned is None \"\"\" item = None #if there are reservations, then call _trigger_get if self . reservations_get : item = self . _trigger_get ( get_event ) #else raise an error else : raise RuntimeError ( \"No matching reservation found for process: reservations_get is empty\" ) #if an item is returned then call _trigger_reserve_put to process pending requests if item is not None : self . _trigger_reserve_put ( None ) if item is None : raise RuntimeError ( f \"No item found in the store for { get_event . requesting_process } and get request failed\" ) else : return item","title":"get"},{"location":"api_ref_main_page_2/#factorysimpy.base.reservable_priority_req_filter_store.ReservablePriorityReqFilterStore.put","text":"Perform a put operation on the store and trigger any pending reserve_get requests. Ensures that only processes with a valid reservation can put items into the store. If the put operation succeeds, it triggers _trigger_reserve_get to process pending get requests. Parameters: put_event ( Event ) \u2013 The event corresponding to the reservation. item ( object ) \u2013 The item to be added to the store. Returns: proceed ( bool ) \u2013 True if the put operation succeeded, False otherwise. Raises: RuntimeError \u2013 If no reservations are available in the reservations_put RuntimeError \u2013 If proceed is False after put operation Source code in src/factorysimpy/base/reservable_priority_req_filter_store.py 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 def put ( self , put_event , item ,): \"\"\" Perform a `put` operation on the store and trigger any pending `reserve_get` requests. Ensures that only processes with a valid reservation can put items into the store. If the put operation succeeds, it triggers `_trigger_reserve_get` to process pending get requests. Args: put_event (simpy.Event): The event corresponding to the reservation. item (object): The item to be added to the store. Returns: proceed (bool): True if the put operation succeeded, False otherwise. Raises: RuntimeError: If no reservations are available in the reservations_put RuntimeError: If proceed is False after put operation \"\"\" proceed = False if self . reservations_put : proceed = self . _trigger_put ( put_event , item ) else : raise RuntimeError ( \"No matching reservation found for process: reservations_put is empty\" ) if proceed : #print(f\"{self.env.now} proceed\") #self._trigger_get(None) self . _trigger_reserve_get ( None ) if not proceed : raise RuntimeError ( f \"No matching put_event found in the reservations and put failed for { item } \" ) else : return proceed","title":"put"},{"location":"api_ref_main_page_2/#factorysimpy.base.reservable_priority_req_filter_store.ReservablePriorityReqFilterStore.reserve_get","text":"Create a reservation request to retrieve an item from the store. This method generates a SimPy event representing a request to reserve an item for retrieval ( get ). The event is assigned attributes such as priority, the resource it belongs to, and the process making the request. The event is then added to reserve_get_queue , which is maintained in priority order, and _trigger_reserve_get() is called to process pending reservations if items are available. Parameters: priority ( int , default: 0 ) \u2013 The priority level of the reservation request. Lower values indicate higher priority. Defaults to 0. filter ( filter=lambdaitem=True , default: None ) \u2013 Filter to be used while using \"reserve_get Returns: event ( Event ) \u2013 A reservation event that will succeed when an item becomes available. Source code in src/factorysimpy/base/reservable_priority_req_filter_store.py 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 def reserve_get ( self , priority = 0 , filter = None ): \"\"\" Create a reservation request to retrieve an item from the store. This method generates a SimPy event representing a request to reserve an item for retrieval (`get`). The event is assigned attributes such as priority, the resource it belongs to, and the process making the request. The event is then added to `reserve_get_queue`, which is maintained in priority order, and `_trigger_reserve_get()` is called to process pending reservations if items are available. Args: priority (int, optional): The priority level of the reservation request. Lower values indicate higher priority. Defaults to 0. filter (filter=lambdaitem=True, optional): Filter to be used while using \"reserve_get Returns: event (simpy.Event): A reservation event that will succeed when an item becomes available. \"\"\" #adding attributes to the newly created event for reserve_get event = self . env . event () event . resourcename = self event . requesting_process = self . env . active_process # Associate event with the current process #event.priority_to_get = (priority, self._env.now) event . priority_to_get = priority # Check if 'filter' is provided, if not, assign a default filter if filter is None : #print(f\"T={self.env.now} filter is None so making it true for all items\") #filter = lambda item: True # Default filter that accepts all items filter = lambda x : self . env . now >= x . put_time + self . trigger_delay event . filter = filter else : #print(f\"T={self.env.now} filter is not None \") event . filter = filter #sorting the list based on priority after appending the new event self . reserve_get_queue . append ( event ) self . reserve_get_queue . sort ( key = lambda e : e . priority_to_get ) self . _trigger_reserve_get ( event ) return event","title":"reserve_get"},{"location":"api_ref_main_page_2/#factorysimpy.base.reservable_priority_req_filter_store.ReservablePriorityReqFilterStore.reserve_get_cancel","text":"Cancel a previously made reserve_get request. This method allows a process to cancel its reservation for retrieving an item from the store. If the reservation exists in the reserve_get_queue , it is removed, and _trigger_reserve_get() is called to process any remaining reservations. If the reservation is already in reservations_get , it is removed, and the corresponding item is repositioned in the store to maintain order. _trigger_reserve_get() is then triggered to handle pending reservations. Parameters: get_event_to_cancel ( Event ) \u2013 The reservation event that needs to be canceled. Returns: proceed ( bool ) \u2013 True if the reservation was successfully canceled. Raises: RuntimeError \u2013 If the specified event does not exist in reserve_get_queue or reservations_get . Source code in src/factorysimpy/base/reservable_priority_req_filter_store.py 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 def reserve_get_cancel ( self , get_event_to_cancel ): \"\"\" Cancel a previously made `reserve_get` request. This method allows a process to cancel its reservation for retrieving an item from the store. If the reservation exists in the `reserve_get_queue`, it is removed, and `_trigger_reserve_get()` is called to process any remaining reservations. If the reservation is already in `reservations_get`, it is removed, and the corresponding item is repositioned in the store to maintain order. `_trigger_reserve_get()` is then triggered to handle pending reservations. Args: get_event_to_cancel (simpy.Event): The reservation event that needs to be canceled. Returns: proceed (bool): True if the reservation was successfully canceled. Raises: RuntimeError: If the specified event does not exist in `reserve_get_queue` or `reservations_get`. \"\"\" #checking and removing the event if it is not yielded and is present in the reserve_get_queue proceed = False if get_event_to_cancel in self . reserve_get_queue : self . reserve_get_queue . remove ( get_event_to_cancel ) self . _trigger_reserve_get ( None ) #if t is removed, then a waiting event can be succeeded, if any return True #checking and removing the event if it is already yielded and is present in the reservations_queue. # 1-to-1 association with items done to preserve item order should also be removed. elif get_event_to_cancel in self . reservations_get : self . reservations_get . remove ( get_event_to_cancel ) #deleting the associated event in the reserved_events list to preserve the order of the items #finding index of the item event_in_index = self . reserved_events . index ( get_event_to_cancel ) delta_position = len ( self . reserved_events ) #shifting the item item_to_shift = self . items . pop ( event_in_index ) self . items . insert ( delta_position - 1 , item_to_shift ) #deleting the event self . reserved_events . pop ( event_in_index ) #if t is removed, then a waiting event can be succeeded, if any self . _trigger_reserve_get ( None ) proceed = True else : raise RuntimeError ( \"No matching event in reserve_get_queue or reservations_get for this process\" ) return proceed","title":"reserve_get_cancel"},{"location":"api_ref_main_page_2/#factorysimpy.base.reservable_priority_req_filter_store.ReservablePriorityReqFilterStore.reserve_put","text":"Create a reservation request to put an item into the store. This function generates a SimPy event representing a reservation request. The event is assigned attributes such as priority, resource name, and the process making the request. The event is then added to reserve_put_queue , which is maintained in priority order. After adding the event to the queue, _trigger_reserve_put is called to process any pending reservations. Parameters: priority ( int , default: 0 ) \u2013 The priority level of the reservation request. Lower values indicate higher priority. Defaults to 0. Returns: event ( Event ) \u2013 A reservation event that will succeed when space is available. Source code in src/factorysimpy/base/reservable_priority_req_filter_store.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def reserve_put ( self , priority = 0 ): \"\"\" Create a reservation request to put an item into the store. This function generates a SimPy event representing a reservation request. The event is assigned attributes such as priority, resource name, and the process making the request. The event is then added to `reserve_put_queue`, which is maintained in priority order. After adding the event to the queue, `_trigger_reserve_put` is called to process any pending reservations. Args: priority (int, optional): The priority level of the reservation request. Lower values indicate higher priority. Defaults to 0. Returns: event (simpy.Event): A reservation event that will succeed when space is available. \"\"\" event = self . env . event () event . resourcename = self # Store reference event . requesting_process = self . env . active_process # Process making the reservation event . priority_to_put = priority # Priority for sorting reservations # Add the event to the reservation queue and sort by priority self . reserve_put_queue . append ( event ) self . reserve_put_queue . sort ( key = lambda e : e . priority_to_put ) # Attempt to process reservations self . _trigger_reserve_put ( event ) return event","title":"reserve_put"},{"location":"api_ref_main_page_2/#factorysimpy.base.reservable_priority_req_filter_store.ReservablePriorityReqFilterStore.reserve_put_cancel","text":"Cancel a previously made reserve_put request. This method allows a process to cancel its reservation for putting an item into the store. If the reservation exists in the reserve_put_queue , it is removed before triggering _trigger_reserve_put to process any pending reservations. If the reservation is already in reservations_put , it is also removed and _trigger_reserve_put is triggered. Parameters: put_event_to_cancel ( Event ) \u2013 The reservation event that needs to be canceled. Returns: proceed ( bool ) \u2013 True if the reservation was successfully canceled. Raises: RuntimeError \u2013 If the specified event does not exist in reserve_put_queue or reservations_put . Source code in src/factorysimpy/base/reservable_priority_req_filter_store.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 def reserve_put_cancel ( self , put_event_to_cancel ): \"\"\" Cancel a previously made `reserve_put` request. This method allows a process to cancel its reservation for putting an item into the store. If the reservation exists in the `reserve_put_queue`, it is removed before triggering `_trigger_reserve_put` to process any pending reservations. If the reservation is already in `reservations_put`, it is also removed and `_trigger_reserve_put` is triggered. Args: put_event_to_cancel (simpy.Event): The reservation event that needs to be canceled. Returns: proceed (bool): True if the reservation was successfully canceled. Raises: RuntimeError: If the specified event does not exist in `reserve_put_queue` or `reservations_put`. \"\"\" #checking and removing the event if it is not yielded and is present in the reserve_put_queue proceed = False if put_event_to_cancel in self . reserve_put_queue : self . reserve_put_queue . remove ( put_event_to_cancel ) self . _trigger_reserve_put ( None ) #if t is removed, then a waiting event can be succeeded, if any proceed = True #checking and removing the event if it is already yielded and is present in the reservations_put elif put_event_to_cancel in self . reservations_put : self . reservations_put . remove ( put_event_to_cancel ) self . _trigger_reserve_put ( None ) #if t is removed, then a waiting event can be succeeded, if any proceed = True else : raise RuntimeError ( \"No matching event in reserve_put_queue or reservations_put for this process\" ) return proceed","title":"reserve_put_cancel"},{"location":"api_ref_main_page_2/#factorysimpy.base.reservable_priority_req_store","text":"","title":"reservable_priority_req_store"},{"location":"api_ref_main_page_2/#factorysimpy.base.reservable_priority_req_store.ReservablePriorityReqStore","text":"Bases: Store This is a class that is derived from SimPy's Store class and has extra capabilities that makes it a priority-based reservable store for processes to reserve space for storing and retrieving items with priority-based access. Processes can use reserve_put() and reserve_get() methods to get notified when a space becomes available in the store or when an item gets available in the ReservablePriorityReqStore. These methods returns a unique event (SimPy.Event) to the process for every reserve requests it makes. Processes can also pass a priority as argument in the request. Lower values indicate higher priority. get and put are two methods that can be used for item storing and retrieval from ReservablePriorityReqStore. Process has to make a prior reservation and pass the associated reservation event as argument in the get and put requests. ReservablePriorityReqStore maintains separate queues for reserve_put and reserve_get operations to ensures that only processes with valid reservations can store or retrieve items. ReservablePriorityReqStore preserves item order by associating an unreserved item in the store with a reservation event by index when a reserve_get() request is made. As a result, it maintains a list of reserved events to preserve item order. It also allows users to cancel an already placed reserve_get or reserve_put request even if it is yielded. It also handles the dissociation of the event and item done at the time of reservation when an already yielded event is canceled. Attributes: reserved_events ( list ) \u2013 Maintains events corresponding to reserved items to preserve item order by index reserve_put_queue ( list ) \u2013 Queue for managing reserve_put reservations reservations_put ( list ) \u2013 List of successful put reservations reserve_get_queue ( list ) \u2013 Queue for managing reserve_get reservations reservations_get ( list ) \u2013 List of successful get reservations Initializes a reservable store with priority-based reservations. Args: capacity (int, optional): The maximum number of items the store can hold. Defaults to infinity. Source code in src/factorysimpy/base/reservable_priority_req_store.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def __init__ ( self , env , capacity = float ( 'inf' )): \"\"\" Initializes a reservable store with priority-based reservations. Args: capacity (int, optional): The maximum number of items the store can hold. Defaults to infinity. \"\"\" super () . __init__ ( env , capacity ) self . env = env self . reserve_put_queue = [] # Queue for managing reserve_put reservations self . reservations_put = [] # List of successful put reservations self . reserve_get_queue = [] # Queue for managing reserve_get reservations self . reservations_get = [] # List of successful get reservations self . reserved_events = [] # Maintains events corresponding to reserved items to preserve item order self . _last_level_change_time = self . env . now self . _last_num_items = 0 self . _weighted_sum = 0.0 self . time_averaged_num_of_items_in_store = 0.0 # Time-averaged number of items in the store","title":"ReservablePriorityReqStore"},{"location":"api_ref_main_page_2/#factorysimpy.base.reservable_priority_req_store.ReservablePriorityReqStore.get","text":"Retrieve an item from the store after a successful reservation. This method attempts to retrieve an item associated with a reserve_get event. If the reservation exists, it triggers _trigger_get to retrieve the item. If successful, _trigger_reserve_put is called to process any pending reserve_put requests. If the item retrieval fails, an error message is raised. Parameters: get_event ( Event ) \u2013 The reservation event associated with the request. Returns: item ( Object ) \u2013 The retrieved item if successful, otherwise raises an error Raises: RuntimeError \u2013 If no reservations are available in the reservations_get RuntimeError \u2013 If item returned is None Source code in src/factorysimpy/base/reservable_priority_req_store.py 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 def get ( self , get_event ): \"\"\" Retrieve an item from the store after a successful reservation. This method attempts to retrieve an item associated with a `reserve_get` event. If the reservation exists, it triggers `_trigger_get` to retrieve the item. If successful, `_trigger_reserve_put` is called to process any pending `reserve_put` requests. If the item retrieval fails, an error message is raised. Args: get_event (simpy.Event): The reservation event associated with the request. Returns: item (Object): The retrieved item if successful, otherwise raises an error Raises: RuntimeError: If no reservations are available in the reservations_get RuntimeError: If item returned is None \"\"\" item = None #if there are reservations, then call _trigger_get if self . reservations_get : item = self . _trigger_get ( get_event ) #else raise an error else : raise RuntimeError ( \"No matching reservation found for process: reservations_get is empty\" ) #if an item is returned then call _trigger_reserve_put to process pending requests if item is not None : self . _trigger_reserve_put ( None ) if item is None : raise RuntimeError ( f \"No item found in the store for { get_event . requesting_process } and get request failed\" ) else : self . _update_time_averaged_level () return item","title":"get"},{"location":"api_ref_main_page_2/#factorysimpy.base.reservable_priority_req_store.ReservablePriorityReqStore.put","text":"Perform a put operation on the store and trigger any pending reserve_get requests. Ensures that only processes with a valid reservation can put items into the store. If the put operation succeeds, it triggers _trigger_reserve_get to process pending get requests. Parameters: put_event ( Event ) \u2013 The event corresponding to the reservation. item ( object ) \u2013 The item to be added to the store. Returns: proceed ( bool ) \u2013 True if the put operation succeeded, False otherwise. Raises: RuntimeError \u2013 If no reservations are available in the reservations_put RuntimeError \u2013 If proceed is False after put operation Source code in src/factorysimpy/base/reservable_priority_req_store.py 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 def put ( self , put_event , item ): \"\"\" Perform a `put` operation on the store and trigger any pending `reserve_get` requests. Ensures that only processes with a valid reservation can put items into the store. If the put operation succeeds, it triggers `_trigger_reserve_get` to process pending get requests. Args: put_event (simpy.Event): The event corresponding to the reservation. item (object): The item to be added to the store. Returns: proceed (bool): True if the put operation succeeded, False otherwise. Raises: RuntimeError: If no reservations are available in the reservations_put RuntimeError: If proceed is False after put operation \"\"\" proceed = False if self . reservations_put : proceed = self . _trigger_put ( put_event , item ) else : raise RuntimeError ( \"No matching reservation found for process: reservations_put is empty\" ) if proceed : #print(f\"{self.env.now} proceed\") #self._trigger_get(None) self . _trigger_reserve_get ( None ) #if the put operation is not successful, then raise an erro if not proceed : raise RuntimeError ( f \"No matching put_event found in the reservations and put failed for { item } \" ) else : self . _update_time_averaged_level () return proceed","title":"put"},{"location":"api_ref_main_page_2/#factorysimpy.base.reservable_priority_req_store.ReservablePriorityReqStore.reserve_get","text":"Create a reservation request to retrieve an item from the store. This method generates a SimPy event representing a request to reserve an item for retrieval ( get ). The event is assigned attributes such as priority, the resource it belongs to, and the process making the request. The event is then added to reserve_get_queue , which is maintained in priority order, and _trigger_reserve_get() is called to process pending reservations if items are available. Parameters: priority ( int , default: 0 ) \u2013 The priority level of the reservation request. Lower values indicate higher priority. Defaults to 0. Returns: event ( Event ) \u2013 A reservation event that will succeed when an item becomes available. Source code in src/factorysimpy/base/reservable_priority_req_store.py 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 def reserve_get ( self , priority = 0 ): \"\"\" Create a reservation request to retrieve an item from the store. This method generates a SimPy event representing a request to reserve an item for retrieval (`get`). The event is assigned attributes such as priority, the resource it belongs to, and the process making the request. The event is then added to `reserve_get_queue`, which is maintained in priority order, and `_trigger_reserve_get()` is called to process pending reservations if items are available. Args: priority (int, optional): The priority level of the reservation request. Lower values indicate higher priority. Defaults to 0. Returns: event (simpy.Event): A reservation event that will succeed when an item becomes available. \"\"\" #adding attributes to the newly created event for reserve_get event = self . env . event () event . resourcename = self event . requesting_process = self . env . active_process # Associate event with the current process #event.priority_to_get = (priority, self._env.now) event . priority_to_get = priority #sorting the list based on priority after appending the new event self . reserve_get_queue . append ( event ) self . reserve_get_queue . sort ( key = lambda e : e . priority_to_get ) self . _trigger_reserve_get ( event ) return event","title":"reserve_get"},{"location":"api_ref_main_page_2/#factorysimpy.base.reservable_priority_req_store.ReservablePriorityReqStore.reserve_get_cancel","text":"Cancel a previously made reserve_get request. This method allows a process to cancel its reservation for retrieving an item from the store. If the reservation exists in the reserve_get_queue , it is removed, and _trigger_reserve_get() is called to process any remaining reservations. If the reservation is already in reservations_get , it is removed, and the corresponding item is repositioned in the store to maintain order. _trigger_reserve_get() is then triggered to handle pending reservations. Parameters: get_event_to_cancel ( Event ) \u2013 The reservation event that needs to be canceled. Returns: proceed ( bool ) \u2013 True if the reservation was successfully canceled. Raises: RuntimeError \u2013 If the specified event does not exist in reserve_get_queue or reservations_get . Source code in src/factorysimpy/base/reservable_priority_req_store.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 def reserve_get_cancel ( self , get_event_to_cancel ): \"\"\" Cancel a previously made `reserve_get` request. This method allows a process to cancel its reservation for retrieving an item from the store. If the reservation exists in the `reserve_get_queue`, it is removed, and `_trigger_reserve_get()` is called to process any remaining reservations. If the reservation is already in `reservations_get`, it is removed, and the corresponding item is repositioned in the store to maintain order. `_trigger_reserve_get()` is then triggered to handle pending reservations. Args: get_event_to_cancel (simpy.Event): The reservation event that needs to be canceled. Returns: proceed (bool): True if the reservation was successfully canceled. Raises: RuntimeError: If the specified event does not exist in `reserve_get_queue` or `reservations_get`. \"\"\" proceed = False #checking and removing the event if it is not yielded and is present in the reserve_get_queue if get_event_to_cancel in self . reserve_get_queue : self . reserve_get_queue . remove ( get_event_to_cancel ) self . _trigger_reserve_get ( None ) #if t is removed, then a waiting event can be succeeded, if any proceed = True #checking and removing the event if it is already yielded and is present in the reservations_queue. # 1-to-1 association with items done to preserve item order should also be removed. elif get_event_to_cancel in self . reservations_get : self . reservations_get . remove ( get_event_to_cancel ) #deleting the associated event in the reserved_events list to preserve the order of the items #finding index of the item event_in_index = self . reserved_events . index ( get_event_to_cancel ) delta_position = len ( self . reserved_events ) #shifting the item item_to_shift = self . items . pop ( event_in_index ) self . items . insert ( delta_position - 1 , item_to_shift ) #deleting the event self . reserved_events . pop ( event_in_index ) #if t is removed, then a waiting event can be succeeded, if any self . _trigger_reserve_get ( None ) proceed = True else : raise RuntimeError ( \"No matching event in reserve_get_queue or reservations_get for this process\" ) return proceed","title":"reserve_get_cancel"},{"location":"api_ref_main_page_2/#factorysimpy.base.reservable_priority_req_store.ReservablePriorityReqStore.reserve_put","text":"Create a reservation request to put an item into the store. This function generates a SimPy event representing a reservation request. The event is assigned attributes such as priority, resource name, and the process making the request. The event is then added to reserve_put_queue , which is maintained in priority order. After adding the event to the queue, _trigger_reserve_put is called to process any pending reservations. Parameters: priority ( int , default: 0 ) \u2013 The priority level of the reservation request. Lower values indicate higher priority. Defaults to 0. Returns: event ( Event ) \u2013 A reservation event that will succeed when space is available. Source code in src/factorysimpy/base/reservable_priority_req_store.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def reserve_put ( self , priority = 0 ): \"\"\" Create a reservation request to put an item into the store. This function generates a SimPy event representing a reservation request. The event is assigned attributes such as priority, resource name, and the process making the request. The event is then added to `reserve_put_queue`, which is maintained in priority order. After adding the event to the queue, `_trigger_reserve_put` is called to process any pending reservations. Args: priority (int, optional): The priority level of the reservation request. Lower values indicate higher priority. Defaults to 0. Returns: event (simpy.Event): A reservation event that will succeed when space is available. \"\"\" event = self . env . event () event . resourcename = self # Store reference event . requesting_process = self . env . active_process # Process making the reservation event . priority_to_put = priority # Priority for sorting reservations # Add the event to the reservation queue and sort by priority self . reserve_put_queue . append ( event ) self . reserve_put_queue . sort ( key = lambda e : e . priority_to_put ) # Attempt to process reservations self . _trigger_reserve_put ( event ) return event","title":"reserve_put"},{"location":"api_ref_main_page_2/#factorysimpy.base.reservable_priority_req_store.ReservablePriorityReqStore.reserve_put_cancel","text":"Cancel a previously made reserve_put request. This method allows a process to cancel its reservation for putting an item into the store. If the reservation exists in the reserve_put_queue , it is removed before triggering _trigger_reserve_put to process any pending reservations. If the reservation is already in reservations_put , it is also removed and _trigger_reserve_put is triggered. Parameters: put_event_to_cancel ( Event ) \u2013 The reservation event that needs to be canceled. Returns: proceed ( bool ) \u2013 True if the reservation was successfully canceled. Raises: RuntimeError \u2013 If the specified event does not exist in reserve_put_queue or reservations_put . Source code in src/factorysimpy/base/reservable_priority_req_store.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 def reserve_put_cancel ( self , put_event_to_cancel ): \"\"\" Cancel a previously made `reserve_put` request. This method allows a process to cancel its reservation for putting an item into the store. If the reservation exists in the `reserve_put_queue`, it is removed before triggering `_trigger_reserve_put` to process any pending reservations. If the reservation is already in `reservations_put`, it is also removed and `_trigger_reserve_put` is triggered. Args: put_event_to_cancel (simpy.Event): The reservation event that needs to be canceled. Returns: proceed (bool): True if the reservation was successfully canceled. Raises: RuntimeError: If the specified event does not exist in `reserve_put_queue` or `reservations_put`. \"\"\" #checking and removing the event if it is not yielded and is present in the reserve_put_queue proceed = False if put_event_to_cancel in self . reserve_put_queue : self . reserve_put_queue . remove ( put_event_to_cancel ) self . _trigger_reserve_put ( None ) #if t is removed, then a waiting event can be succeeded, if any proceed = True #checking and removing the event if it is already yielded and is present in the reservations_put elif put_event_to_cancel in self . reservations_put : self . reservations_put . remove ( put_event_to_cancel ) self . _trigger_reserve_put ( None ) #if t is removed, then a waiting event can be succeeded, if any proceed = True else : raise RuntimeError ( \"No matching event in reserve_put_queue or reservations_put for this process\" ) return proceed","title":"reserve_put_cancel"},{"location":"api_ref_main_page_2/#factorysimpy.base.reservable_req_store","text":"","title":"reservable_req_store"},{"location":"api_ref_main_page_2/#factorysimpy.base.reservable_req_store.ReservableReqStore","text":"Bases: Store This is a class that is derived from SimPy's Store class and has extra capabilities that makes it a reservable store for processes to reserve space for storing and retrieving items. Processes can use reserve_put() and reserve_get() methods to get notified when a space becomes available in the store or when an item gets available in the ReservableReqStore. These methods returns a unique event (SimPy.Event) to the process for every reserve requests it makes. get and put are two methods that can be used for item storing and retrieval from ReservableReqStore. Process has to make a prior reservation and pass the associated reservation event as argument in the get and put requests. ReservableReqStore maintains separate queues for reserve_put and reserve_get operations to ensures that only processes with valid reservations can store or retrieve items. ReservableReqStore preserves item order by associating an unreserved item in the store with a reservation event by index when a reserve_get() request is made. As a result, it maintains a list of reserved events to preserve item order. It also allows users to cancel an already placed reserve_get or reserve_put request even if it is yielded. It also handles the dissociation of the event and item done at the time of reservation when an already yielded event is canceled. Attributes: reserved_events ( list ) \u2013 Maintains events corresponding to reserved items to preserve item order by index reserve_put_queue ( list ) \u2013 Queue for managing reserve_put reservations reservations_put ( list ) \u2013 List of successful put reservations reserve_get_queue ( list ) \u2013 Queue for managing reserve_get reservations reservations_get ( list ) \u2013 List of successful get reservations Initializes a reservable store with reservations. Args: capacity (int, optional): The maximum number of items the store can hold. Defaults to infinity. Source code in src/factorysimpy/base/reservable_req_store.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 def __init__ ( self , env , capacity = float ( 'inf' )): \"\"\" Initializes a reservable store with reservations. Args: capacity (int, optional): The maximum number of items the store can hold. Defaults to infinity. \"\"\" super () . __init__ ( env , capacity ) self . env = env self . reserve_put_queue = [] # Queue for managing reserve_put reservations self . reservations_put = [] # List of successful put reservations self . reserve_get_queue = [] # Queue for managing reserve_get reservations self . reservations_get = [] # List of successful get reservations self . reserved_events = [] # Maintains events corresponding to reserved items to preserve item order self . _last_level_change_time = self . env . now self . _last_num_items = 0 self . _weighted_sum = 0.0 self . time_averaged_num_of_items_in_store = 0.0 # Time-averaged number of items in the store","title":"ReservableReqStore"},{"location":"api_ref_main_page_2/#factorysimpy.base.reservable_req_store.ReservableReqStore.get","text":"Retrieve an item from the store after a successful reservation. This method attempts to retrieve an item associated with a reserve_get event. If the reservation exists, it triggers _trigger_get to retrieve the item. If successful, _trigger_reserve_put is called to process any pending reserve_put requests. If the item retrieval fails, an error message is raised. Parameters: get_event ( Event ) \u2013 The reservation event associated with the request. Returns: item ( Object ) \u2013 The retrieved item if successful, otherwise raises an error Raises: RuntimeError \u2013 If no reservations are available in the reservations_get RuntimeError \u2013 If item returned is None Source code in src/factorysimpy/base/reservable_req_store.py 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 def get ( self , get_event ): \"\"\" Retrieve an item from the store after a successful reservation. This method attempts to retrieve an item associated with a `reserve_get` event. If the reservation exists, it triggers `_trigger_get` to retrieve the item. If successful, `_trigger_reserve_put` is called to process any pending `reserve_put` requests. If the item retrieval fails, an error message is raised. Args: get_event (simpy.Event): The reservation event associated with the request. Returns: item (Object): The retrieved item if successful, otherwise raises an error Raises: RuntimeError: If no reservations are available in the reservations_get RuntimeError: If item returned is None \"\"\" item = None #if there are reservations, then call _trigger_get if self . reservations_get : item = self . _trigger_get ( get_event ) #else raise an error else : raise RuntimeError ( \"No matching reservation found for process: reservations_get is empty\" ) #if an item is returned then call _trigger_reserve_put to process pending requests if item is not None : self . _trigger_reserve_put ( None ) if item is None : raise RuntimeError ( f \"No item found in the store for { get_event . requesting_process } and get request failed\" ) else : self . _update_time_averaged_level () return item","title":"get"},{"location":"api_ref_main_page_2/#factorysimpy.base.reservable_req_store.ReservableReqStore.put","text":"Perform a put operation on the store and trigger any pending reserve_get requests. Ensures that only processes with a valid reservation can put items into the store. If the put operation succeeds, it triggers _trigger_reserve_get to process pending get requests. Parameters: put_event ( Event ) \u2013 The event corresponding to the reservation. item ( object ) \u2013 The item to be added to the store. Returns: proceed ( bool ) \u2013 True if the put operation succeeded, False otherwise. Raises: RuntimeError \u2013 If no reservations are available in the reservations_put RuntimeError \u2013 If proceed is False after put operation Source code in src/factorysimpy/base/reservable_req_store.py 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 def put ( self , put_event , item ): \"\"\" Perform a `put` operation on the store and trigger any pending `reserve_get` requests. Ensures that only processes with a valid reservation can put items into the store. If the put operation succeeds, it triggers `_trigger_reserve_get` to process pending get requests. Args: put_event (simpy.Event): The event corresponding to the reservation. item (object): The item to be added to the store. Returns: proceed (bool): True if the put operation succeeded, False otherwise. Raises: RuntimeError: If no reservations are available in the reservations_put RuntimeError: If proceed is False after put operation \"\"\" proceed = False if self . reservations_put : proceed = self . _trigger_put ( put_event , item ) else : raise RuntimeError ( \"No matching reservation found for process: reservations_put is empty\" ) if proceed : #print(f\"{self.env.now} proceed\") #self._trigger_get(None) self . _trigger_reserve_get ( None ) #if the put operation is not successful, then raise an erro if not proceed : raise RuntimeError ( f \"No matching put_event found in the reservations and put failed for { item } \" ) else : self . _update_time_averaged_level () return proceed","title":"put"},{"location":"api_ref_main_page_2/#factorysimpy.base.reservable_req_store.ReservableReqStore.reserve_get","text":"Create a reservation request to retrieve an item from the store. This method generates a SimPy event representing a request to reserve an item for retrieval ( get ). The event is assigned attributes such as the resource it belongs to, and the process making the request. The event is then added to reserve_get_queue , which is maintained in the order in which it has added, and _trigger_reserve_get() is called to process pending reservations if items are available. Returns: event ( Event ) \u2013 A reservation event that will succeed when an item becomes available. Source code in src/factorysimpy/base/reservable_req_store.py 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 def reserve_get ( self ): \"\"\" Create a reservation request to retrieve an item from the store. This method generates a SimPy event representing a request to reserve an item for retrieval (`get`). The event is assigned attributes such as the resource it belongs to, and the process making the request. The event is then added to `reserve_get_queue`, which is maintained in the order in which it has added, and `_trigger_reserve_get()` is called to process pending reservations if items are available. Returns: event (simpy.Event): A reservation event that will succeed when an item becomes available. \"\"\" #adding attributes to the newly created event for reserve_get event = self . env . event () event . resourcename = self event . requesting_process = self . env . active_process # Associate event with the current process self . reserve_get_queue . append ( event ) self . _trigger_reserve_get ( event ) return event","title":"reserve_get"},{"location":"api_ref_main_page_2/#factorysimpy.base.reservable_req_store.ReservableReqStore.reserve_get_cancel","text":"Cancel a previously made reserve_get request. This method allows a process to cancel its reservation for retrieving an item from the store. If the reservation exists in the reserve_get_queue , it is removed, and _trigger_reserve_get() is called to process any remaining reservations. If the reservation is already in reservations_get , it is removed, and the corresponding item is repositioned in the store to maintain order. _trigger_reserve_get() is then triggered to handle pending reservations. Parameters: get_event_to_cancel ( Event ) \u2013 The reservation event that needs to be canceled. Returns: proceed ( bool ) \u2013 True if the reservation was successfully canceled. Raises: RuntimeError \u2013 If the specified event does not exist in reserve_get_queue or reservations_get . Source code in src/factorysimpy/base/reservable_req_store.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 def reserve_get_cancel ( self , get_event_to_cancel ): \"\"\" Cancel a previously made `reserve_get` request. This method allows a process to cancel its reservation for retrieving an item from the store. If the reservation exists in the `reserve_get_queue`, it is removed, and `_trigger_reserve_get()` is called to process any remaining reservations. If the reservation is already in `reservations_get`, it is removed, and the corresponding item is repositioned in the store to maintain order. `_trigger_reserve_get()` is then triggered to handle pending reservations. Args: get_event_to_cancel (simpy.Event): The reservation event that needs to be canceled. Returns: proceed (bool): True if the reservation was successfully canceled. Raises: RuntimeError: If the specified event does not exist in `reserve_get_queue` or `reservations_get`. \"\"\" proceed = False #checking and removing the event if it is not yielded and is present in the reserve_get_queue if get_event_to_cancel in self . reserve_get_queue : self . reserve_get_queue . remove ( get_event_to_cancel ) self . _trigger_reserve_get ( None ) #if t is removed, then a waiting event can be succeeded, if any proceed = True #checking and removing the event if it is already yielded and is present in the reservations_queue. # 1-to-1 association with items done to preserve item order should also be removed. elif get_event_to_cancel in self . reservations_get : self . reservations_get . remove ( get_event_to_cancel ) #deleting the associated event in the reserved_events list to preserve the order of the items #finding index of the item event_in_index = self . reserved_events . index ( get_event_to_cancel ) delta_position = len ( self . reserved_events ) #shifting the item item_to_shift = self . items . pop ( event_in_index ) self . items . insert ( delta_position - 1 , item_to_shift ) #deleting the event self . reserved_events . pop ( event_in_index ) #if t is removed, then a waiting event can be succeeded, if any self . _trigger_reserve_get ( None ) proceed = True else : raise RuntimeError ( \"No matching event in reserve_get_queue or reservations_get for this process\" ) return proceed","title":"reserve_get_cancel"},{"location":"api_ref_main_page_2/#factorysimpy.base.reservable_req_store.ReservableReqStore.reserve_put","text":"Create a reservation request to put an item into the store. This function generates a SimPy event representing a reservation request. The event is assigned attributes such as the resource name, and the process making the request. The event is then added to reserve_put_queue , which is maintained in the order in which the request has come. After adding the event to the queue, _trigger_reserve_put is called to process any pending reservations. Returns: event ( Event ) \u2013 A reservation event that will succeed when space is available. Source code in src/factorysimpy/base/reservable_req_store.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def reserve_put ( self ): \"\"\" Create a reservation request to put an item into the store. This function generates a SimPy event representing a reservation request. The event is assigned attributes such as the resource name, and the process making the request. The event is then added to `reserve_put_queue`, which is maintained in the order in which the request has come. After adding the event to the queue, `_trigger_reserve_put` is called to process any pending reservations. Returns: event (simpy.Event): A reservation event that will succeed when space is available. \"\"\" event = self . env . event () event . resourcename = self # Store reference event . requesting_process = self . env . active_process # Process making the reservation self . reserve_put_queue . append ( event ) # Attempt to process reservations self . _trigger_reserve_put ( event ) return event","title":"reserve_put"},{"location":"api_ref_main_page_2/#factorysimpy.base.reservable_req_store.ReservableReqStore.reserve_put_cancel","text":"Cancel a previously made reserve_put request. This method allows a process to cancel its reservation for putting an item into the store. If the reservation exists in the reserve_put_queue , it is removed before triggering _trigger_reserve_put to process any pending reservations. If the reservation is already in reservations_put , it is also removed and _trigger_reserve_put is triggered. Parameters: put_event_to_cancel ( Event ) \u2013 The reservation event that needs to be canceled. Returns: proceed ( bool ) \u2013 True if the reservation was successfully canceled. Raises: RuntimeError \u2013 If the specified event does not exist in reserve_put_queue or reservations_put . Source code in src/factorysimpy/base/reservable_req_store.py 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 def reserve_put_cancel ( self , put_event_to_cancel ): \"\"\" Cancel a previously made `reserve_put` request. This method allows a process to cancel its reservation for putting an item into the store. If the reservation exists in the `reserve_put_queue`, it is removed before triggering `_trigger_reserve_put` to process any pending reservations. If the reservation is already in `reservations_put`, it is also removed and `_trigger_reserve_put` is triggered. Args: put_event_to_cancel (simpy.Event): The reservation event that needs to be canceled. Returns: proceed (bool): True if the reservation was successfully canceled. Raises: RuntimeError: If the specified event does not exist in `reserve_put_queue` or `reservations_put`. \"\"\" #checking and removing the event if it is not yielded and is present in the reserve_put_queue proceed = False if put_event_to_cancel in self . reserve_put_queue : self . reserve_put_queue . remove ( put_event_to_cancel ) self . _trigger_reserve_put ( None ) #if t is removed, then a waiting event can be succeeded, if any proceed = True #checking and removing the event if it is already yielded and is present in the reservations_put elif put_event_to_cancel in self . reservations_put : self . reservations_put . remove ( put_event_to_cancel ) self . _trigger_reserve_put ( None ) #if t is removed, then a waiting event can be succeeded, if any proceed = True else : raise RuntimeError ( \"No matching event in reserve_put_queue or reservations_put for this process\" ) return proceed","title":"reserve_put_cancel"},{"location":"api_ref_main_page_2/#factorysimpy.base.slotted_belt_store","text":"","title":"slotted_belt_store"},{"location":"api_ref_main_page_2/#factorysimpy.base.slotted_belt_store.BeltStore","text":"Bases: Store This is a class that is derived from SimPy's Store class and has extra capabilities that makes it a priority-based reservable store for processes to reserve space for storing and retrieving items with priority-based access. Processes can use reserve_put() and reserve_get() methods to get notified when a space becomes available in the store or when an item gets available in the ReservablePriorityReqStore. These methods returns a unique event (SimPy.Event) to the process for every reserve requests it makes. Processes can also pass a priority as argument in the request. Lower values indicate higher priority. get and put are two methods that can be used for item storing and retrieval from ReservablePriorityReqStore. Process has to make a prior reservation and pass the associated reservation event as argument in the get and put requests. ReservablePriorityReqStore maintains separate queues for reserve_put and reserve_get operations to ensures that only processes with valid reservations can store or retrieve items. ReservablePriorityReqStore preserves item order by associating an unreserved item in the store with a reservation event by index when a reserve_get() request is made. As a result, it maintains a list of reserved events to preserve item order. It also allows users to cancel an already placed reserve_get or reserve_put request even if it is yielded. It also handles the dissociation of the event and item done at the time of reservation when an already yielded event is canceled. Attributes: reserved_events ( list ) \u2013 Maintains events corresponding to reserved items to preserve item order by index reserve_put_queue ( list ) \u2013 Queue for managing reserve_put reservations reservations_put ( list ) \u2013 List of successful put reservations reserve_get_queue ( list ) \u2013 Queue for managing reserve_get reservations reservations_get ( list ) \u2013 List of successful get reservations Initializes a reservable store with priority-based reservations. Args: capacity (int, optional): The maximum number of items the store can hold. Defaults to infinity. Source code in src/factorysimpy/base/slotted_belt_store.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def __init__ ( self , env , capacity = float ( 'inf' ), mode = 'FIFO' , delay = 1 ): \"\"\" Initializes a reservable store with priority-based reservations. Args: capacity (int, optional): The maximum number of items the store can hold. Defaults to infinity. \"\"\" super () . __init__ ( env , capacity ) self . env = env self . mode = mode self . delay = delay # Speed of the conveyor belt (units per time) self . reserve_put_queue = [] # Queue for managing reserve_put reservations self . reservations_put = [] # List of successful put reservations self . reserve_get_queue = [] # Queue for managing reserve_get reservations self . reservations_get = [] # List of successful get reservations self . reserved_events = [] # Maintains events corresponding to reserved items to preserve item order self . ready_items = [] #Maintains the items ready to be taken out self . reserved_items = [] # parallel list of the exact items reserved self . _last_level_change_time = self . env . now self . _last_num_items = 0 self . _weighted_sum = 0.0 self . time_averaged_num_of_items_in_store = 0.0 # Time-averaged number of items in the store # Process tracking for interrupt functionality self . active_move_processes = {} # Dictionary to track active move_to_ready_items processes self . resume_event = self . env . event () # Event to signal when to resume processes self . noaccumulation_mode_on = False # to control if the belt is in noaccumulation mode self . one_item_inserted = False # to control insertion of only one item in noaccumulation mode self . ready_item_event = self . env . event ()","title":"BeltStore"},{"location":"api_ref_main_page_2/#factorysimpy.base.slotted_belt_store.BeltStore.get","text":"Retrieve an item from the store after a successful reservation. This method attempts to retrieve an item associated with a reserve_get event. If the reservation exists, it triggers _trigger_get to retrieve the item. If successful, _trigger_reserve_put is called to process any pending reserve_put requests. If the item retrieval fails, an error message is raised. Parameters: get_event ( Event ) \u2013 The reservation event associated with the request. Returns: item ( Object ) \u2013 The retrieved item if successful, otherwise raises an error Raises: RuntimeError \u2013 If no reservations are available in the reservations_get RuntimeError \u2013 If item returned is None Source code in src/factorysimpy/base/slotted_belt_store.py 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 def get ( self , get_event ): \"\"\" Retrieve an item from the store after a successful reservation. This method attempts to retrieve an item associated with a `reserve_get` event. If the reservation exists, it triggers `_trigger_get` to retrieve the item. If successful, `_trigger_reserve_put` is called to process any pending `reserve_put` requests. If the item retrieval fails, an error message is raised. Args: get_event (simpy.Event): The reservation event associated with the request. Returns: item (Object): The retrieved item if successful, otherwise raises an error Raises: RuntimeError: If no reservations are available in the reservations_get RuntimeError: If item returned is None \"\"\" item = None #if there are reservations, then call _trigger_get if self . reservations_get : item = self . _trigger_get ( get_event ) #else raise an error else : raise RuntimeError ( \"No matching reservation found for process: reservations_get is empty\" ) #if an item is returned then call _trigger_reserve_put to process pending requests if item is not None : self . _trigger_reserve_put ( None ) if item is None : raise RuntimeError ( f \"No item found in the store for { get_event . requesting_process } and get request failed\" ) else : #self._update_time_averaged_level() return item","title":"get"},{"location":"api_ref_main_page_2/#factorysimpy.base.slotted_belt_store.BeltStore.handle_new_item_during_interruption","text":"Handle new items arriving during selective interruption. For new items, the delay before interruption is: capacity - num_items Parameters: item \u2013 The new item being added Source code in src/factorysimpy/base/slotted_belt_store.py 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 def handle_new_item_during_interruption ( self , item ): \"\"\" Handle new items arriving during selective interruption. For new items, the delay before interruption is: capacity - num_items Args: item: The new item being added \"\"\" if self . noaccumulation_mode_on : num_items = len ( self . items ) + len ( self . ready_items ) delay_before_interrupt = max ( self . capacity - num_items , 0 ) item_id = item [ 0 ] . id if hasattr ( item [ 0 ], 'id' ) else str ( id ( item )) if delay_before_interrupt > 0 : print ( f \"T= { self . env . now : .2f } New item { item_id } will be interrupted after { delay_before_interrupt } time units\" ) self . env . process ( self . _delayed_interrupt ( item_id , delay_before_interrupt , \"New item during interruption\" )) else : print ( f \"T= { self . env . now : .2f } New item { item_id } interrupted immediately\" ) self . _interrupt_specific_item ( item_id , \"New item during interruption\" )","title":"handle_new_item_during_interruption"},{"location":"api_ref_main_page_2/#factorysimpy.base.slotted_belt_store.BeltStore.interrupt_all_move_processes","text":"Interrupt all active move_to_ready_items processes. Parameters: reason ( str , default: 'External interrupt' ) \u2013 Reason for the interrupt Source code in src/factorysimpy/base/slotted_belt_store.py 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 def interrupt_all_move_processes ( self , reason = \"External interrupt\" ): \"\"\" Interrupt all active move_to_ready_items processes. Args: reason (str): Reason for the interrupt \"\"\" print ( f \"T= { self . env . now : .2f } BufferStore interrupting { len ( self . active_move_processes ) } move processes - { reason } \" ) for item_id , process_info in self . active_move_processes . items (): process = process_info [ 'process' ] if process and not process . processed : try : process . interrupt ( reason ) print ( f \"T= { self . env . now : .2f } Interrupted move process for item { item_id } \" ) except RuntimeError : # Process might already be finished pass","title":"interrupt_all_move_processes"},{"location":"api_ref_main_page_2/#factorysimpy.base.slotted_belt_store.BeltStore.move_to_ready_items","text":"Move items from the store to the ready_items list after a put operation. This method is called as a process to ensure that items are moved asynchronously. Handles interrupts when state changes to stalled and resumes when state changes back. Movement is split into two phases: 1. First phase: item[0].length/self.speed time (time for item to fully enter belt) 2. Second phase: remaining time (time for item to reach exit) Source code in src/factorysimpy/base/slotted_belt_store.py 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 def move_to_ready_items ( self , item ): \"\"\" Move items from the store to the ready_items list after a put operation. This method is called as a process to ensure that items are moved asynchronously. Handles interrupts when state changes to stalled and resumes when state changes back. Movement is split into two phases: 1. First phase: item[0].length/self.speed time (time for item to fully enter belt) 2. Second phase: remaining time (time for item to reach exit) \"\"\" item_id = item [ 0 ] . id if hasattr ( item [ 0 ], 'id' ) else str ( id ( item )) event = self . env . event () #self.delay=self.delay #print(f\"created Added event suceeded{self.delay}\") event . callbacks . append ( self . _trigger_reserve_put ) # after putting an item, an event is created and will be triggered ater delay amount of time to allow waiting get calls to succeed in a stalled belt #event.callbacks.append(self._trigger_put)# this may not be needed #print(f\"{self.env.now}Added event suceed ed\") # Calculate the two phases of movement phase1_time = self . delay # Time for item to fully enter belt phase2_time = item [ 1 ] - phase1_time # Remaining time to reach exit try : # Move items to the ready_items list if self . items : print ( f \"T= { self . env . now : .2f } beltstore received an item { item [ 0 ] . id , item [ 1 ] } . Item started moving in belt\" ) # Phase 1: Item entering the belt (length/speed time) remaining_phase1_time = phase1_time print ( f \"T= { self . env . now : .2f } Item { item_id } starting Phase 1 (entering belt): { phase1_time : .2f } time\" ) while remaining_phase1_time > 0 : try : start_time = self . env . now yield self . env . timeout ( remaining_phase1_time ) # If we reach here, phase 1 completed without interruption event . succeed () remaining_phase1_time = 0 break except simpy . Interrupt as interrupt : # Calculate how much time has passed elapsed_time = self . env . now - start_time remaining_phase1_time -= elapsed_time print ( f \"T= { self . env . now : .2f } Move process Phase 1 for item { item_id } interrupted: { interrupt . cause } \" ) print ( f \"T= { self . env . now : .2f } Remaining Phase 1 time for item { item_id } : { remaining_phase1_time : .2f } \" ) # Wait for resume signal print ( f \"T= { self . env . now : .2f } Item { item_id } waiting for resume signal (Phase 1)...\" ) yield self . resume_event print ( f \"T= { self . env . now : .2f } Item { item_id } resuming Phase 1 movement with { remaining_phase1_time : .2f } time remaining\" ) print ( f \"T= { self . env . now : .2f } Item { item_id } completed Phase 1 (fully entered belt)\" ) # Phase 2: Item moving through the belt to exit remaining_phase2_time = phase2_time print ( f \"T= { self . env . now : .2f } Item { item_id } starting Phase 2 (moving to exit): { phase2_time : .2f } time\" ) while remaining_phase2_time > 0 : try : start_time = self . env . now yield self . env . timeout ( remaining_phase2_time ) # If we reach here, phase 2 completed without interruption remaining_phase2_time = 0 break except simpy . Interrupt as interrupt : # Calculate how much time has passed elapsed_time = self . env . now - start_time remaining_phase2_time -= elapsed_time print ( f \"T= { self . env . now : .2f } Move process Phase 2 for item { item_id } interrupted: { interrupt . cause } \" ) print ( f \"T= { self . env . now : .2f } Remaining Phase 2 time for item { item_id } : { remaining_phase2_time : .2f } \" ) # Wait for resume signal print ( f \"T= { self . env . now : .2f } Item { item_id } waiting for resume signal (Phase 2)...\" ) yield self . resume_event print ( f \"T= { self . env . now : .2f } Item { item_id } resuming Phase 2 movement with { remaining_phase2_time : .2f } time remaining\" ) print ( f \"T= { self . env . now : .2f } Item { item_id } completed Phase 2 (reached exit)\" ) print ( f \"T= { self . env . now : .2f } bufferstore finished moving item { item [ 0 ] . id , item [ 1 ] } going to ready_items\" ) item_index = self . items . index ( item ) item_to_put = self . items . pop ( item_index ) # Remove the item if len ( self . ready_items ) + len ( self . items ) < self . capacity : self . ready_items . append ( item_to_put [ 0 ]) if not self . ready_item_event . triggered : self . ready_item_event . succeed () # Notify that a new item is ready print ( f \"T= { self . env . now : .2f } bufferstore finished moving item { item [ 0 ] . id , item [ 1 ] } moved to ready_items\" ) self . _trigger_reserve_get ( None ) self . _trigger_reserve_put ( None ) else : raise RuntimeError ( \"Total number of items in the store exceeds capacity. Cannot move item to ready_items.\" ) finally : # Clean up the process tracking when done if item_id in self . active_move_processes : del self . active_move_processes [ item_id ] print ( f \"T= { self . env . now : .2f } Removed tracking for completed move process of item { item_id } \" )","title":"move_to_ready_items"},{"location":"api_ref_main_page_2/#factorysimpy.base.slotted_belt_store.BeltStore.put","text":"Perform a put operation on the store and trigger any pending reserve_get requests. Ensures that only processes with a valid reservation can put items into the store. If the put operation succeeds, it triggers _trigger_reserve_get to process pending get requests. Parameters: put_event ( Event ) \u2013 The event corresponding to the reservation. item ( object ) \u2013 The item to be added to the store. Returns: proceed ( bool ) \u2013 True if the put operation succeeded, False otherwise. Raises: RuntimeError \u2013 If no reservations are available in the reservations_put RuntimeError \u2013 If proceed is False after put operation Source code in src/factorysimpy/base/slotted_belt_store.py 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 def put ( self , put_event , item ): \"\"\" Perform a `put` operation on the store and trigger any pending `reserve_get` requests. Ensures that only processes with a valid reservation can put items into the store. If the put operation succeeds, it triggers `_trigger_reserve_get` to process pending get requests. Args: put_event (simpy.Event): The event corresponding to the reservation. item (object): The item to be added to the store. Returns: proceed (bool): True if the put operation succeeded, False otherwise. Raises: RuntimeError: If no reservations are available in the reservations_put RuntimeError: If proceed is False after put operation \"\"\" proceed = False if self . reservations_put : proceed = self . _trigger_put ( put_event , item ) else : raise RuntimeError ( \"No matching reservation found for process: reservations_put is empty\" ) if proceed : #print(f\"{self.env.now} proceed\") #self._trigger_get(None) self . _trigger_reserve_get ( None ) if not proceed : raise RuntimeError ( f \"No matching put_event found in the reservations and put failed for { item } \" ) else : #self._update_time_averaged_level() return proceed","title":"put"},{"location":"api_ref_main_page_2/#factorysimpy.base.slotted_belt_store.BeltStore.reserve_get","text":"Create a reservation request to retrieve an item from the store. This method generates a SimPy event representing a request to reserve an item for retrieval ( get ). The event is assigned attributes such as priority, the resource it belongs to, and the process making the request. The event is then added to reserve_get_queue , which is maintained in priority order, and _trigger_reserve_get() is called to process pending reservations if items are available. Parameters: priority ( int , default: 0 ) \u2013 The priority level of the reservation request. Lower values indicate higher priority. Defaults to 0. Returns: event ( Event ) \u2013 A reservation event that will succeed when an item becomes available. Source code in src/factorysimpy/base/slotted_belt_store.py 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 def reserve_get ( self , priority = 0 ): \"\"\" Create a reservation request to retrieve an item from the store. This method generates a SimPy event representing a request to reserve an item for retrieval (`get`). The event is assigned attributes such as priority, the resource it belongs to, and the process making the request. The event is then added to `reserve_get_queue`, which is maintained in priority order, and `_trigger_reserve_get()` is called to process pending reservations if items are available. Args: priority (int, optional): The priority level of the reservation request. Lower values indicate higher priority. Defaults to 0. Returns: event (simpy.Event): A reservation event that will succeed when an item becomes available. \"\"\" #adding attributes to the newly created event for reserve_get event = self . env . event () event . resourcename = self event . requesting_process = self . env . active_process # Associate event with the current process #event.priority_to_get = (priority, self._env.now) event . priority_to_get = priority #sorting the list based on priority after appending the new event self . reserve_get_queue . append ( event ) self . reserve_get_queue . sort ( key = lambda e : e . priority_to_get ) self . _trigger_reserve_get ( event ) return event","title":"reserve_get"},{"location":"api_ref_main_page_2/#factorysimpy.base.slotted_belt_store.BeltStore.reserve_get_cancel","text":"Cancel a previously made reserve_get request. Source code in src/factorysimpy/base/slotted_belt_store.py 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 def reserve_get_cancel ( self , get_event_to_cancel ): \"\"\" Cancel a previously made `reserve_get` request. \"\"\" # Case 1: still waiting if get_event_to_cancel in self . reserve_get_queue : self . reserve_get_queue . remove ( get_event_to_cancel ) self . _trigger_reserve_get ( None ) return True # Case 2: already yielded reservation if get_event_to_cancel in self . reservations_get : # 1) Remove from active reservations self . reservations_get . remove ( get_event_to_cancel ) # 2) Find its index in the parallel lists ev_idx = self . reserved_events . index ( get_event_to_cancel ) # 3) Pop out the exact item reference item = self . reserved_items . pop ( ev_idx ) # 4) Drop the event token self . reserved_events . pop ( ev_idx ) # 5) Remove it from ready_items wherever it currently is try : self . ready_items . remove ( item ) except ValueError : raise RuntimeError ( f \"Item { item !r} not found in ready_items during cancel.\" ) # 6) Compute new insertion index if self . mode == \"FIFO\" : # one slot before the remaining reserved block insert_idx = len ( self . ready_items ) - len ( self . reserved_events ) - 1 else : # LIFO # top of stack insert_idx = len ( self . ready_items ) # 7) Re\u2011insert it self . ready_items . insert ( insert_idx , item ) # 8) Trigger any other pending reservations self . _trigger_reserve_get ( None ) return True # No such reservation raise RuntimeError ( \"No matching event in reserve_get_queue or reservations_get\" )","title":"reserve_get_cancel"},{"location":"api_ref_main_page_2/#factorysimpy.base.slotted_belt_store.BeltStore.reserve_put","text":"Create a reservation request to put an item into the store. This function generates a SimPy event representing a reservation request. The event is assigned attributes such as priority, resource name, and the process making the request. The event is then added to reserve_put_queue , which is maintained in priority order. After adding the event to the queue, _trigger_reserve_put is called to process any pending reservations. Parameters: priority ( int , default: 0 ) \u2013 The priority level of the reservation request. Lower values indicate higher priority. Defaults to 0. Returns: event ( Event ) \u2013 A reservation event that will succeed when space is available. Source code in src/factorysimpy/base/slotted_belt_store.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def reserve_put ( self , priority = 0 ): \"\"\" Create a reservation request to put an item into the store. This function generates a SimPy event representing a reservation request. The event is assigned attributes such as priority, resource name, and the process making the request. The event is then added to `reserve_put_queue`, which is maintained in priority order. After adding the event to the queue, `_trigger_reserve_put` is called to process any pending reservations. Args: priority (int, optional): The priority level of the reservation request. Lower values indicate higher priority. Defaults to 0. Returns: event (simpy.Event): A reservation event that will succeed when space is available. \"\"\" event = self . env . event () event . resourcename = self # Store reference event . requesting_process = self . env . active_process # Process making the reservation event . priority_to_put = priority # Priority for sorting reservations # Add the event to the reservation queue and sort by priority self . reserve_put_queue . append ( event ) self . reserve_put_queue . sort ( key = lambda e : e . priority_to_put ) # Attempt to process reservations self . _trigger_reserve_put ( event ) return event","title":"reserve_put"},{"location":"api_ref_main_page_2/#factorysimpy.base.slotted_belt_store.BeltStore.reserve_put_cancel","text":"Cancel a previously made reserve_put request. This method allows a process to cancel its reservation for putting an item into the store. If the reservation exists in the reserve_put_queue , it is removed before triggering _trigger_reserve_put to process any pending reservations. If the reservation is already in reservations_put , it is also removed and _trigger_reserve_put is triggered. Parameters: put_event_to_cancel ( Event ) \u2013 The reservation event that needs to be canceled. Returns: proceed ( bool ) \u2013 True if the reservation was successfully canceled. Raises: RuntimeError \u2013 If the specified event does not exist in reserve_put_queue or reservations_put . Source code in src/factorysimpy/base/slotted_belt_store.py 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 def reserve_put_cancel ( self , put_event_to_cancel ): \"\"\" Cancel a previously made `reserve_put` request. This method allows a process to cancel its reservation for putting an item into the store. If the reservation exists in the `reserve_put_queue`, it is removed before triggering `_trigger_reserve_put` to process any pending reservations. If the reservation is already in `reservations_put`, it is also removed and `_trigger_reserve_put` is triggered. Args: put_event_to_cancel (simpy.Event): The reservation event that needs to be canceled. Returns: proceed (bool): True if the reservation was successfully canceled. Raises: RuntimeError: If the specified event does not exist in `reserve_put_queue` or `reservations_put`. \"\"\" #checking and removing the event if it is not yielded and is present in the reserve_put_queue proceed = False if put_event_to_cancel in self . reserve_put_queue : self . reserve_put_queue . remove ( put_event_to_cancel ) self . _trigger_reserve_put ( None ) #if t is removed, then a waiting event can be succeeded, if any proceed = True #checking and removing the event if it is already yielded and is present in the reservations_put elif put_event_to_cancel in self . reservations_put : self . reservations_put . remove ( put_event_to_cancel ) self . _trigger_reserve_put ( None ) #if t is removed, then a waiting event can be succeeded, if any proceed = True else : raise RuntimeError ( \"No matching event in reserve_put_queue or reservations_put for this process\" ) return proceed","title":"reserve_put_cancel"},{"location":"api_ref_main_page_2/#factorysimpy.base.slotted_belt_store.BeltStore.resume_all_move_processes","text":"Resume all interrupted move_to_ready_items processes. Source code in src/factorysimpy/base/slotted_belt_store.py 731 732 733 734 735 736 737 738 739 740 def resume_all_move_processes ( self ): \"\"\" Resume all interrupted move_to_ready_items processes. \"\"\" print ( f \"T= { self . env . now : .2f } BufferStore resuming move processes\" ) # Create a new resume event and trigger it old_resume_event = self . resume_event self . resume_event = self . env . event () old_resume_event . succeed ()","title":"resume_all_move_processes"},{"location":"api_ref_main_page_2/#factorysimpy.base.slotted_belt_store.BeltStore.selective_interrupt","text":"Perform selective interruption based on belt occupancy patterns and mode. When noaccumulation_mode_on=True (STALLED_NONACCUMULATING_STATE): - Interrupt all items immediately When noaccumulation_mode_on=False (STALLED_ACCUMULATING_STATE): - Use pattern-based interruption with delays based on item positions Pattern-based rules for accumulating mode: - For patterns like '_ *', interrupt all items. - For patterns like '_ _ _', interrupt item in second last position after 1 delay, and second item after 2 delays. - For patterns like ' ___*', interrupt first item and second item after 3 delays. - For patterns like ' __*', interrupt first item, second after 2 delays, and third after 2 delays. Parameters: reason ( str , default: 'Selective interrupt' ) \u2013 Reason for the interrupt Source code in src/factorysimpy/base/slotted_belt_store.py 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 def selective_interrupt ( self , reason = \"Selective interrupt\" ): \"\"\" Perform selective interruption based on belt occupancy patterns and mode. When noaccumulation_mode_on=True (STALLED_NONACCUMULATING_STATE): - Interrupt all items immediately When noaccumulation_mode_on=False (STALLED_ACCUMULATING_STATE): - Use pattern-based interruption with delays based on item positions Pattern-based rules for accumulating mode: - For patterns like '_****', interrupt all items. - For patterns like '_*_*_', interrupt item in second last position after 1 delay, and second item after 2 delays. - For patterns like '*___*', interrupt first item and second item after 3 delays. - For patterns like '**__*', interrupt first item, second after 2 delays, and third after 2 delays. Args: reason (str): Reason for the interrupt \"\"\" if not self . items : print ( f \"T= { self . env . now : .2f } No items on belt to interrupt\" ) return # If noaccumulation_mode_on is True (STALLED_NONACCUMULATING_STATE), interrupt all items immediately if self . noaccumulation_mode_on : print ( f \"T= { self . env . now : .2f } No accumulation mode: interrupting all items immediately\" ) for i , item in enumerate ( self . items ): item_id = item [ 0 ] . id if hasattr ( item [ 0 ], 'id' ) else str ( id ( item )) self . _interrupt_specific_item ( item_id , f \" { reason } - immediate (no accumulation)\" ) return # For accumulating mode (STALLED_ACCUMULATING_STATE), use pattern-based interruption print ( f \"T= { self . env . now : .2f } Accumulating mode: using pattern-based interruption\" ) # Get current belt pattern pattern = self . _get_belt_pattern () print ( f \"T= { self . env . now : .2f } Current belt pattern: { pattern } \" ) # Analyze pattern and determine interruption strategy interruption_plan = self . _analyze_pattern_for_interruption ( pattern ) if not interruption_plan : print ( f \"T= { self . env . now : .2f } No interruption needed for current pattern\" ) return print ( f \"T= { self . env . now : .2f } Executing selective interruption plan: { interruption_plan } \" ) # Execute the interruption plan self . _execute_interruption_plan ( interruption_plan , reason )","title":"selective_interrupt"},{"location":"api_ref_main_page_2/#factorysimpy.constructs","text":"","title":"constructs"},{"location":"api_ref_main_page_2/#factorysimpy.constructs.chain","text":"","title":"chain"},{"location":"api_ref_main_page_2/#factorysimpy.constructs.chain.connect_nodes_with_buffers","text":"Connects source, machines, buffers, and optionally a sink in the following order: src -> buffer1 -> machine1 -> buffer2 -> machine2 -> ... -> bufferN -> sink Parameters: src \u2013 Source node machines \u2013 List of machine nodes buffers \u2013 List of buffer edges (should be len(machines) - 1) inlcuding source and sink sink \u2013 Optional sink node Returns: \u2013 List of all nodes and buffers in connection order Source code in src/factorysimpy/constructs/chain.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def connect_nodes_with_buffers ( machines , buffers , src , sink ): \"\"\" Connects source, machines, buffers, and optionally a sink in the following order: src -> buffer1 -> machine1 -> buffer2 -> machine2 -> ... -> bufferN -> sink Args: src: Source node machines: List of machine nodes buffers: List of buffer edges (should be len(machines) - 1) inlcuding source and sink sink: Optional sink node Returns: List of all nodes and buffers in connection order \"\"\" assert len ( buffers ) == len ( machines ) - 1 , \"Number of buffers must be one more than number of machines\" # Connect intermediate machines and buffers for i in range ( 1 , len ( machines )): buffers [ i - 1 ] . connect ( machines [ i - 1 ], machines [ i ]) # Return all nodes and buffers for reference return machines , buffers","title":"connect_nodes_with_buffers"},{"location":"api_ref_main_page_2/#factorysimpy.constructs.mesh","text":"","title":"mesh"},{"location":"api_ref_main_page_2/#factorysimpy.constructs.mesh.connect_mesh","text":"Builds a mesh/grid of nodes connected with buffers. Each node is connected to its right and down neighbor. Returns: mesh_nodes \u2013 2D list of nodes (rows x cols) edge_dict \u2013 dict of buffers by (from_node.id, to_node.id) Source code in src/factorysimpy/constructs/mesh.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def connect_mesh ( env , rows , cols , node_cls , edge_cls , node_kwargs = None , edge_kwargs = None , node_kwargs_grid = None , edge_kwargs_grid = None , prefix = \"M\" , edge_prefix = \"B\" , source_cls = None , sink_cls = None , source_kwargs = None , sink_kwargs = None ): \"\"\" Builds a mesh/grid of nodes connected with buffers. Each node is connected to its right and down neighbor. Returns: mesh_nodes: 2D list of nodes (rows x cols) edge_dict: dict of buffers by (from_node.id, to_node.id) \"\"\" node_kwargs = node_kwargs or {} edge_kwargs = edge_kwargs or {} mesh_nodes = [] edge_dict = {} def get_kwargs ( grid , r , c , default ): if grid and r < len ( grid ) and c < len ( grid [ r ]): return grid [ r ][ c ] return default # Create nodes (machines) for r in range ( rows ): row = [] for c in range ( cols ): kwargs = get_kwargs ( node_kwargs_grid , r , c , node_kwargs ) node_id = f \" { prefix } _ { r + 1 } _ { c + 1 } \" node = node_cls ( env = env , id = node_id , ** kwargs ) row . append ( node ) mesh_nodes . append ( row ) # Helper to create and connect edges def create_edge ( from_node , to_node , r , c ): kwargs = get_kwargs ( edge_kwargs_grid , r , c , edge_kwargs ) edge_id = f \" { edge_prefix } _ { from_node . id } _ { to_node . id } \" edge = edge_cls ( env = env , id = edge_id , ** kwargs ) edge . connect ( from_node , to_node ) edge_dict [( from_node . id , to_node . id )] = edge # Create buffers (edges) to right and down for r in range ( rows ): for c in range ( cols ): from_node = mesh_nodes [ r ][ c ] if c + 1 < cols : create_edge ( from_node , mesh_nodes [ r ][ c + 1 ], r , c ) if r + 1 < rows : create_edge ( from_node , mesh_nodes [ r + 1 ][ c ], r , c ) return mesh_nodes , edge_dict","title":"connect_mesh"},{"location":"api_ref_main_page_2/#factorysimpy.constructs.mesh.connect_mesh_with_source_sink","text":"Builds a mesh/grid of nodes connected with buffers. Source sends to first row, Sink collects from last row. Returns: mesh_nodes \u2013 2D list of nodes (rows x cols) edge_dict \u2013 dict of buffers by (from_node.id, to_node.id) \u2013 source, sink: optional Source code in src/factorysimpy/constructs/mesh.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 def connect_mesh_with_source_sink ( env , rows , cols , node_cls , edge_cls , node_kwargs = None , edge_kwargs = None , node_kwargs_grid = None , edge_kwargs_grid = None , prefix = \"M\" , edge_prefix = \"B\" , source_cls = None , sink_cls = None , source_kwargs = None , sink_kwargs = None ): \"\"\" Builds a mesh/grid of nodes connected with buffers. Source sends to first row, Sink collects from last row. Returns: mesh_nodes: 2D list of nodes (rows x cols) edge_dict: dict of buffers by (from_node.id, to_node.id) source, sink: optional \"\"\" node_kwargs = node_kwargs or {} edge_kwargs = edge_kwargs or {} source_kwargs = source_kwargs or {} sink_kwargs = sink_kwargs or {} mesh_nodes = [] edge_dict = {} # Create nodes (machines) for r in range ( rows ): row = [] for c in range ( cols ): kwargs = node_kwargs_grid [ r ][ c ] if node_kwargs_grid else node_kwargs node_id = f \" { prefix } _ { r + 1 } _ { c + 1 } \" node = node_cls ( env = env , id = node_id , ** kwargs ) row . append ( node ) mesh_nodes . append ( row ) # Create buffers (edges) to right and down for r in range ( rows ): for c in range ( cols ): from_node = mesh_nodes [ r ][ c ] # Connect right if c + 1 < cols : to_node = mesh_nodes [ r ][ c + 1 ] edge_id = f \" { edge_prefix } _ { from_node . id } _ { to_node . id } \" kwargs = edge_kwargs_grid [ r ][ c ] if edge_kwargs_grid else edge_kwargs edge = edge_cls ( env = env , id = edge_id , ** kwargs ) edge . connect ( from_node , to_node ) edge_dict [( from_node . id , to_node . id )] = edge # Connect down if r + 1 < rows : to_node = mesh_nodes [ r + 1 ][ c ] edge_id = f \" { edge_prefix } _ { from_node . id } _ { to_node . id } \" kwargs = edge_kwargs_grid [ r ][ c ] if edge_kwargs_grid else edge_kwargs edge = edge_cls ( env = env , id = edge_id , ** kwargs ) edge . connect ( from_node , to_node ) edge_dict [( from_node . id , to_node . id )] = edge # Optional source source = None if source_cls : source = source_cls ( env = env , id = \"Source\" , ** source_kwargs ) for c in range ( cols ): to_node = mesh_nodes [ 0 ][ c ] edge_id = f \" { edge_prefix } _SRC_ { to_node . id } \" edge = edge_cls ( env = env , id = edge_id , ** edge_kwargs ) edge . connect ( source , to_node ) edge_dict [( source . id , to_node . id )] = edge # Optional sink sink = None if sink_cls : sink = sink_cls ( env = env , id = \"Sink\" , ** sink_kwargs ) for c in range ( cols ): from_node = mesh_nodes [ rows - 1 ][ c ] edge_id = f \" { edge_prefix } _ { from_node . id } _SINK\" edge = edge_cls ( env = env , id = edge_id , ** edge_kwargs ) edge . connect ( from_node , sink ) edge_dict [( from_node . id , sink . id )] = edge return mesh_nodes , edge_dict , source , sink","title":"connect_mesh_with_source_sink"},{"location":"api_ref_main_page_2/#factorysimpy.edges","text":"","title":"edges"},{"location":"api_ref_main_page_2/#factorysimpy.edges.buffer","text":"","title":"buffer"},{"location":"api_ref_main_page_2/#factorysimpy.edges.buffer.Buffer","text":"Bases: Edge Buffer class representing a FIFO queue. Inherits from the Edge class. This buffer can have a single input edge and a single output edge. Attributes: state ( str ) \u2013 The current state of the buffer. capacity ( int ) \u2013 The capacity of the buffer's internal storage. mode ( str ) \u2013 Mode of operation for the buffer, It can be - \"FIFO\" (First In First Out) - \"LIFO\" (Last In First Out). delay ( ( int , float ) ) \u2013 Delay after which the item becomes available. It Can be int or float: Used as a constant delay. Behavior: The Buffer is a type of edge represents components that holds the items that are waiting to be accepted by the destination node. Items that are added in buffer becomes available for use after delay amount of time. It operates in two modes- 1. FIFO : It prioritizes items in the order they were added, with the oldest items being available for the destination node first. 2. LIFO : It prioritizes items in the reverse order of their arrival, items that newly added are available to use by the destination node first Incoming edges can use reserve_get and reserve_put calls on the store in the buffer to reserve an item or space and after yielding the requests, an item can be put and obtained by using put and get methods. Raises: AssertionError \u2013 If the buffer does not have at least one source node or one destination node. Output performance metrics The key performance metrics of the buffer edge are captured in the stats attribute (dict) during a simulation run. last_state_change_time : Time when the state was last changed . time_averaged_num_of_items_in_buffer : Time - averaged number of items available in the buffer . total_time_spent_in_states : Dictionary with total time spent in each state . Source code in src/factorysimpy/edges/buffer.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def __init__ ( self , env , id , capacity = 1 , delay = 0 , mode = \"FIFO\" ): super () . __init__ ( env , id , capacity ) self . state = \"IDLE_STATE\" self . mode = mode self . delay = delay self . capacity = capacity self . stats = { \"last_state_change_time\" : None , \"time_averaged_num_of_items_in_buffer\" : 0 , \"total_time_spent_in_states\" :{ \"IDLE_STATE\" : 0.0 , \"RELEASING_STATE\" : 0.0 , \"BLOCKED_STATE\" : 0.0 } } if self . mode not in [ \"FIFO\" , \"LIFO\" ]: raise ValueError ( \"Invalid mode. Choose either 'FIFO' or 'LIFO'.\" ) # Initialize the buffer store self . inbuiltstore = BufferStore ( env , capacity = self . capacity , mode = self . mode ) if callable ( delay ) or hasattr ( delay , '__next__' ) or isinstance ( delay , ( int , float )) or delay is None : self . delay = delay else : raise ValueError ( \"delay must be None, int, float, generator, or callable.\" )","title":"Buffer"},{"location":"api_ref_main_page_2/#factorysimpy.edges.buffer.Buffer.can_get","text":"Check if the buffer can accept an item.","title":"can_get"},{"location":"api_ref_main_page_2/#factorysimpy.edges.buffer.Buffer.can_get--returns","text":"bool True if the buffer can give an item, False otherwise. Source code in src/factorysimpy/edges/buffer.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 def can_get ( self ): \"\"\" Check if the buffer can accept an item. Returns ------- bool True if the buffer can give an item, False otherwise. \"\"\" if not self . inbuiltstore . ready_items : return False #only return items that are older than the delay. Count such items #count = sum(1 for item in self.inbuiltstore.items if item.time_stamp_creation + self.delay <= self.env.now) # count should be greater than the number of reservations that are already there return len ( self . inbuiltstore . ready_items ) > len ( self . inbuiltstore . reservations_get )","title":"Returns"},{"location":"api_ref_main_page_2/#factorysimpy.edges.buffer.Buffer.can_put","text":"Check if the buffer can accept an item.","title":"can_put"},{"location":"api_ref_main_page_2/#factorysimpy.edges.buffer.Buffer.can_put--returns","text":"bool True if the buffer can accept an item, False otherwise. Source code in src/factorysimpy/edges/buffer.py 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 def can_put ( self ): \"\"\" Check if the buffer can accept an item. Returns ------- bool True if the buffer can accept an item, False otherwise. \"\"\" # Check if the buffer has space for new items if len ( self . inbuiltstore . items ) + len ( self . inbuiltstore . ready_items ) == self . capacity : return False # return True if the number of items in the buffer is less than the store capacity minus the number of reservations # reservations_put is the number of items that are already reserved to be put in the buffer return ( self . capacity - len ( self . inbuiltstore . items ) - len ( self . inbuiltstore . ready_items )) > len ( self . inbuiltstore . reservations_put )","title":"Returns"},{"location":"api_ref_main_page_2/#factorysimpy.edges.buffer.Buffer.get","text":"Get an item from the buffer.","title":"get"},{"location":"api_ref_main_page_2/#factorysimpy.edges.buffer.Buffer.get--parameters","text":"event : simpy.Event The event that was reserved for getting an item.","title":"Parameters"},{"location":"api_ref_main_page_2/#factorysimpy.edges.buffer.Buffer.get--returns","text":"item : object The item retrieved from the buffer. Source code in src/factorysimpy/edges/buffer.py 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 def get ( self , event ): \"\"\" Get an item from the buffer. Parameters ---------- event : simpy.Event The event that was reserved for getting an item. Returns ------- item : object The item retrieved from the buffer. \"\"\" item = self . inbuiltstore . get ( event ) self . _buffer_stats_collector () return item","title":"Returns"},{"location":"api_ref_main_page_2/#factorysimpy.edges.buffer.Buffer.reserve_get_cancel","text":"Cancel a reserved get event.","title":"reserve_get_cancel"},{"location":"api_ref_main_page_2/#factorysimpy.edges.buffer.Buffer.reserve_get_cancel--parameters","text":"event : simpy.Event The event that was reserved for getting an item. Source code in src/factorysimpy/edges/buffer.py 182 183 184 185 186 187 188 189 190 191 def reserve_get_cancel ( self , event ): \"\"\" Cancel a reserved get event. Parameters ---------- event : simpy.Event The event that was reserved for getting an item. \"\"\" return self . inbuiltstore . reserve_get_cancel ( event )","title":"Parameters"},{"location":"api_ref_main_page_2/#factorysimpy.edges.buffer.Buffer.reserve_put_cancel","text":"Cancel a reserved put event.","title":"reserve_put_cancel"},{"location":"api_ref_main_page_2/#factorysimpy.edges.buffer.Buffer.reserve_put_cancel--parameters","text":"event : simpy.Event The event that was reserved for putting an item. Source code in src/factorysimpy/edges/buffer.py 193 194 195 196 197 198 199 200 201 202 def reserve_put_cancel ( self , event ): \"\"\" Cancel a reserved put event. Parameters ---------- event : simpy.Event The event that was reserved for putting an item. \"\"\" return self . inbuiltstore . reserve_put_cancel ( event )","title":"Parameters"},{"location":"api_ref_main_page_2/#factorysimpy.edges.continuous_conveyor","text":"","title":"continuous_conveyor"},{"location":"api_ref_main_page_2/#factorysimpy.edges.continuous_conveyor.ConveyorBelt","text":"Bases: Edge A conveyor belt system with optional accumulation. Attributes: capacity ( int ) : Maximum capacity of the belt . state ( str ) : state of the conveyor belt . length ( float ) : Length of the item . speed ( float ) : Speed of the conveyor belt . accumulating ( bool ) : Whether the belt supports accumulation ( 1 for yes , 0 for no ) . belt ( BeltStore ) : The belt store object . Source code in src/factorysimpy/edges/continuous_conveyor.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def __init__ ( self , env , id , conveyor_length , speed , item_length , accumulating ): capacity = int ( np . ceil ( conveyor_length ) / item_length ) super () . __init__ ( env , id , capacity ) self . state = \"IDLE_STATE\" self . length = item_length #length of the item self . conveyor_length = conveyor_length self . accumulating = accumulating self . speed = speed self . delay = int ( self . conveyor_length / self . speed ) * capacity #self.delay = (self.length*self.speed)/capacity self . belt = BeltStore ( env , capacity , self . speed , self . accumulating ) #self.time_per_item = self.length/self.speed #self.inp_buf=ReservablePriorityReqStore(env, capacity=1) #self.out_buf=ReservablePriorityReqStore(env, capacity=1) self . stats = { \"last_state_change_time\" : None , \"time_averaged_num_of_items_in_conveyor\" : 0 , \"total_time_spent_in_states\" :{ \"IDLE_STATE\" : 0.0 , \"MOVING_STATE\" : 0.0 , \"ACCUMULATING_STATE\" : 0.0 , \"STALLED_NONACCUMULATING_STATE\" : 0.0 } } self . item_arrival_event = self . env . event () # self.item_get_event=self.env.event() self . get_events_available = self . env . event () self . put_events_available = self . env . event () self . noaccumulation_mode_on = False # self.get_request_queue = [] # self.put_request_queue = [] # self.active_events = [] # self.get_dict = {} # self.put_dict = {} self . env . process ( self . behaviour ())","title":"ConveyorBelt"},{"location":"api_ref_main_page_2/#factorysimpy.edges.continuous_conveyor.ConveyorBelt.can_get","text":"Check if an item can be retrieved from the belt. Source code in src/factorysimpy/edges/continuous_conveyor.py 123 124 125 126 127 128 129 def can_get ( self ): \"\"\"Check if an item can be retrieved from the belt.\"\"\" #first_item_to_go_out = self.items[0] if self.items else None if not self . out_buf . items : return False else : return True","title":"can_get"},{"location":"api_ref_main_page_2/#factorysimpy.edges.continuous_conveyor.ConveyorBelt.can_put","text":"Check if an item can be added to the belt. Source code in src/factorysimpy/edges/continuous_conveyor.py 138 139 140 141 142 143 def can_put ( self ): \"\"\"Check if an item can be added to the belt.\"\"\" if not self . inp_buf . items : return True else : return False","title":"can_put"},{"location":"api_ref_main_page_2/#factorysimpy.edges.continuous_conveyor.ConveyorBelt.get","text":"Get an item from the belt.","title":"get"},{"location":"api_ref_main_page_2/#factorysimpy.edges.continuous_conveyor.ConveyorBelt.get--parameters","text":"event : simpy.Event The event that was reserved for getting an item.","title":"Parameters"},{"location":"api_ref_main_page_2/#factorysimpy.edges.continuous_conveyor.ConveyorBelt.get--returns","text":"Item The item retrieved from the belt. Source code in src/factorysimpy/edges/continuous_conveyor.py 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 def get ( self , event ): \"\"\" Get an item from the belt. Parameters ---------- event : simpy.Event The event that was reserved for getting an item. Returns ------- Item The item retrieved from the belt. \"\"\" print ( f \"T= { self . env . now : .2f } : { self . id } :get: getting item from belt\" ) item = self . belt . get ( event ) item . conveyor_exit_time = self . env . now self . _conveyor_stats_collector () event = self . env . event () self . get_events_available . succeed () print ( f \" { self . env . now } { item . id } time in conveyor { item . conveyor_entry_time } and { item . conveyor_exit_time } - time spend in conveyor { item . conveyor_exit_time - item . conveyor_entry_time if item . conveyor_exit_time and item . conveyor_entry_time else 'N/A' } \" ) return item","title":"Returns"},{"location":"api_ref_main_page_2/#factorysimpy.edges.continuous_conveyor.ConveyorBelt.is_empty","text":"Check if the belt is completely empty. Source code in src/factorysimpy/edges/continuous_conveyor.py 105 106 107 108 def is_empty ( self ): \"\"\"Check if the belt is completely empty.\"\"\" return ( len ( self . belt . items ) + len ( self . belt . ready_items ) == 0 )","title":"is_empty"},{"location":"api_ref_main_page_2/#factorysimpy.edges.continuous_conveyor.ConveyorBelt.is_full","text":"Check if the belt is full. Source code in src/factorysimpy/edges/continuous_conveyor.py 119 120 121 def is_full ( self ): \"\"\"Check if the belt is full.\"\"\" return len ( self . belt . items ) + len ( self . belt . ready_items ) == self . belt . capacity","title":"is_full"},{"location":"api_ref_main_page_2/#factorysimpy.edges.continuous_conveyor.ConveyorBelt.is_stalled","text":"Check if the belt is stalled due to time constraints. Source code in src/factorysimpy/edges/continuous_conveyor.py 131 132 133 134 135 136 def is_stalled ( self ): \"\"\"Check if the belt is stalled due to time constraints.\"\"\" if self . belt . ready_items and len ( self . belt . reservations_get ) == 0 : return True else : return False","title":"is_stalled"},{"location":"api_ref_main_page_2/#factorysimpy.edges.continuous_conveyor.ConveyorBelt.put","text":"Put an item into the belt.","title":"put"},{"location":"api_ref_main_page_2/#factorysimpy.edges.continuous_conveyor.ConveyorBelt.put--parameters","text":"event : simpy.Event The event that was reserved for putting an item. item : Item The item to be put on the belt.","title":"Parameters"},{"location":"api_ref_main_page_2/#factorysimpy.edges.continuous_conveyor.ConveyorBelt.put--returns","text":"simpy.Event An event that will be triggered when the item is successfully put on the belt. Source code in src/factorysimpy/edges/continuous_conveyor.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 def put ( self , event , item ): \"\"\" Put an item into the belt. Parameters ---------- event : simpy.Event The event that was reserved for putting an item. item : Item The item to be put on the belt. Returns ------- simpy.Event An event that will be triggered when the item is successfully put on the belt. \"\"\" #delay=self.get_delay(self.delay) print ( f \"T= { self . env . now : .2f } : Conveyor:put: putting item { item . id } \" ) delay = self . length * self . capacity / self . speed item . conveyor_entry_time = self . env . now item_to_put = ( item , delay ) print ( f \"T= { self . env . now : .2f } : { self . id } :put: putting item { item_to_put [ 0 ] . id } on belt with delay { item_to_put [ 1 ] } { self . state } \" ) return_val = self . belt . put ( event , item_to_put ) self . _conveyor_stats_collector () if len ( self . belt . items ) == 1 and self . state == \"IDLE_STATE\" : self . item_arrival_event . succeed () print ( f \"T= { self . env . now : .2f } : { self . id } :put: item arrival event succeeded\" ) else : event = self . env . event () self . put_events_available . succeed () if self . accumulating == 0 : print ( f \"T= { self . env . now : .2f } : { self . id } : attempting to put an item while non accumulating mode on and { self . state } and { self . belt . noaccumulation_mode_on } \" ) print ( f \"T= { self . env . now : .2f } : { self . id } :put: item arrival event else succeeded\" ) if self . state == \"STALLED_ACCUMULATING_STATE\" and self . accumulating == 1 or self . state == \"STALLED_NONACCUMULATING_STATE\" and self . accumulating == 0 : print ( f \"T= { self . env . now : .2f } : { self . id } :put: handling new item during interruption { item_to_put [ 0 ] . id } on belt\" ) self . belt . handle_new_item_during_interruption ( item_to_put ) return return_val","title":"Returns"},{"location":"api_ref_main_page_2/#factorysimpy.edges.continuous_conveyor.ConveyorBelt.set_conveyor_state","text":"Set the conveyor state and manage belt store interrupts/resumes. Parameters: new_state ( str ) \u2013 The new conveyor state Source code in src/factorysimpy/edges/continuous_conveyor.py 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 def set_conveyor_state ( self , new_state ): \"\"\" Set the conveyor state and manage belt store interrupts/resumes. Args: new_state (str): The new conveyor state \"\"\" old_state = self . state self . state = new_state print ( f \"T= { self . env . now : .2f } : { self . id } state changed from { old_state } to { new_state } \" ) # Control belt store based on conveyor state changes if old_state in [ \"MOVING_STATE\" , \"IDLE_STATE\" ] and new_state in [ \"STALLED_ACCUMULATING_STATE\" , \"STALLED_NONACCUMULATING_STATE\" ]: # When conveyor becomes stalled (either accumulating or non-accumulating), apply selective interruption if not self . accumulating : self . belt . noaccumulation_mode_on = True self . belt . selective_interrupt ( f \"Conveyor { self . id } selective interruption - { new_state } \" ) elif old_state in [ \"STALLED_ACCUMULATING_STATE\" , \"STALLED_NONACCUMULATING_STATE\" ] and new_state in [ \"MOVING_STATE\" , \"IDLE_STATE\" ]: # When conveyor resumes to moving or becomes idle, resume all belt store processes #self.belt.interrupt_and_resume_all_delayed_interrupt_processes() if not self . accumulating : self . belt . noaccumulation_mode_on = False self . belt . resume_all_move_processes () self . belt . interrupt_and_resume_all_delayed_interrupt_processes () else : print ( \"state changes from\" , old_state , \"to\" , new_state )","title":"set_conveyor_state"},{"location":"api_ref_main_page_2/#factorysimpy.edges.edge","text":"","title":"edge"},{"location":"api_ref_main_page_2/#factorysimpy.edges.edge.Edge","text":"Edge represents the passive components. It used to connect two nodes and helps to move items between them. It is the base class used to model buffers, conveyors, fleets, etc in manufacturing system. Parameters: id ( str ) \u2013 unique identifier for the edge src_node ( Node ) \u2013 reference to the source node connected to this edge. dest_node ( Node ) \u2013 reference to the destination node connected to this edge. Raises: TypeError \u2013 If the type of env or id is incorrect. ValueError \u2013 If the delay parameter is not a valid type (int, float, generator, or callable). ValueError \u2013 If the edge is already connected to a source or destination node and reconnect is False. ValueError \u2013 If the source or destination nodes are not valid Node instances. Source code in src/factorysimpy/edges/edge.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def __init__ ( self , env , id , capacity ): self . env = env self . id = id self . src_node = None self . dest_node = None self . capacity = capacity # Type checks if not isinstance ( env , simpy . Environment ): raise TypeError ( \"env must be a simpy.Environment instance\" ) if not isinstance ( id , str ): raise TypeError ( \"id must be a string\" ) if not isinstance ( self . capacity , int ) or self . capacity <= 0 : raise ValueError ( \"capacity must be a positive integer\" ) assert self . src_node is None , f \"Edge ' { self . id } ' must have a source node.\" assert self . dest_node is None , f \"Edge ' { self . id } ' must have a destination node.\" assert self . id is not None , \"Edge id cannot be None.\" assert self . capacity is not None , \"Edge capacity cannot be None.\"","title":"Edge"},{"location":"api_ref_main_page_2/#factorysimpy.edges.edge.Edge.connect","text":"Connects this edge to a source node and a destination node. This method checks that both src and dest are valid Node objects and that the edge is not already connected, unless reconnect is set to True. It also registers this edge in the out_edges of the source node and the in_edges of the destination node. Parameters: src ( Node ) \u2013 The source node to connect. dest ( Node ) \u2013 The destination node to connect. reconnect ( bool , default: False ) \u2013 If True, allows reconnection even if the edge is already connected. Defaults to False. Raises: ValueError \u2013 If the edge is already connected and reconnect is False. ValueError \u2013 If src or dest is not a valid Node instance. Source code in src/factorysimpy/edges/edge.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 def connect ( self , src : Node , dest : Node , reconnect : bool = False ): \"\"\" Connects this edge to a source node and a destination node. This method checks that both `src` and `dest` are valid Node objects and that the edge is not already connected, unless `reconnect` is set to True. It also registers this edge in the `out_edges` of the source node and the `in_edges` of the destination node. Args: src (Node): The source node to connect. dest (Node): The destination node to connect. reconnect (bool, optional): If True, allows reconnection even if the edge is already connected. Defaults to False. Raises: ValueError: If the edge is already connected and `reconnect` is False. ValueError: If `src` or `dest` is not a valid Node instance. \"\"\" if not reconnect : if self . src_node or self . dest_node : raise ValueError ( f \"Edge ' { self . id } ' is already connected source or destination node.\" ) if not isinstance ( src , Node ): raise ValueError ( f \"Source ' { src } ' is not a valid Node.\" ) if not isinstance ( dest , Node ): raise ValueError ( f \"Destination ' { dest } ' is not a valid Node.\" ) self . src_node = src self . dest_node = dest # Register edge to nodes if src . out_edges is None : src . out_edges = [] if self not in src . out_edges : src . out_edges . append ( self ) if dest . in_edges is None : dest . in_edges = [] if self not in dest . in_edges : dest . in_edges . append ( self ) print ( f \"T= { self . env . now : .2f } : Connected edge ' { self . id } ' from ' { src . id } ' to ' { dest . id } ' \" )","title":"connect"},{"location":"api_ref_main_page_2/#factorysimpy.edges.edge.Edge.get_delay","text":"Returns value based on the type of parameter delay provided. Parameters: delay ( int, float, generator, or callable ) \u2013 The delay time, which can be: int or float: Used as a constant delay. generator: A generator instance yielding delay values. callable: A function that returns a delay values. Returns: \u2013 Returns a constant delay if delay is an int or float, a value yielded if delay is a generator, or the value returned from a Callable function if delay is callable. Source code in src/factorysimpy/edges/edge.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def get_delay ( self , delay ): \"\"\" Returns value based on the type of parameter `delay` provided. Args: delay (int, float, generator, or callable): The delay time, which can be: - int or float: Used as a constant delay. - generator: A generator instance yielding delay values. - callable: A function that returns a delay values. Returns: Returns a constant delay if `delay` is an int or float, a value yielded if `delay` is a generator, or the value returned from a Callable function if `delay` is callable. \"\"\" if hasattr ( delay , '__next__' ): # Generator instance val = next ( delay ) elif callable ( delay ): # Function val = delay () else : # int or float val = delay assert val >= 0 , \"Delay must be non-negative\" return val","title":"get_delay"},{"location":"api_ref_main_page_2/#factorysimpy.edges.edge.Edge.update_state","text":"Update node state and track the time spent in the previous state. Parameters: new_state ( str ) \u2013 The new state to transition to. Must be one of \"SETUP_STATE\", \"GENERATING_STATE\", \"BLOCKED_STATE\". current_time ( float ) \u2013 The current simulation time. Source code in src/factorysimpy/edges/edge.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def update_state ( self , new_state : str , current_time : float ): \"\"\" Update node state and track the time spent in the previous state. Args: new_state (str): The new state to transition to. Must be one of \"SETUP_STATE\", \"GENERATING_STATE\", \"BLOCKED_STATE\". current_time (float): The current simulation time. \"\"\" if self . state is not None and self . stats [ \"last_state_change_time\" ] is not None : elapsed = current_time - self . stats [ \"last_state_change_time\" ] self . stats [ \"total_time_spent_in_states\" ][ self . state ] = ( self . stats [ \"total_time_spent_in_states\" ] . get ( self . state , 0.0 ) + elapsed ) self . state = new_state self . stats [ \"last_state_change_time\" ] = current_time","title":"update_state"},{"location":"api_ref_main_page_2/#factorysimpy.edges.fleet","text":"","title":"fleet"},{"location":"api_ref_main_page_2/#factorysimpy.edges.fleet.Fleet","text":"Bases: Edge Fleet class representing an AGV (Automated Guided Vehicle) or a group of transporters. Inherits from the Edge class. This fleet can have a single input edge and a single output edge. Attributes: state ( str ) \u2013 The current state of the fleet. capacity ( int ) \u2013 The capacity of the fleet's internal storage. delay ( ( int , float ) ) \u2013 Delay after which fleet activates to move items incase the target capacity is not reached. It Can be int or float: Used as a constant delay. transit_delay ( ( int , float ) ) \u2013 It is the time taken by the fleet to transport the item from src node to destination node. (can be a constant, generator, or callable). Behavior: The Fleet is a type of edge represents components that moves multiple items simulataneaously between nodes. User can specify a parameter capacity to specify how many items can be moved at once. Incoming edges can use reserve_get and reserve_put calls on the store in the fleet to reserve an item or space and after yielding the requests, an item can be put and obtained by using put and get methods. Raises: AssertionError \u2013 If the fleet does not have at least one source node or one destination node. Output performance metrics The key performance metrics of the fleet edge are captured in the stats attribute (dict) during a simulation run. last_state_change_time : Time when the state was last changed . time_averaged_num_of_items_in_fleet : Time - averaged number of items available in the fleet . total_time_spent_in_states : Dictionary with total time spent in each state . Source code in src/factorysimpy/edges/fleet.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def __init__ ( self , env , id , capacity = 1 , delay = 1 , transit_delay = 0 ): super () . __init__ ( env , id , capacity ) self . state = \"IDLE_STATE\" self . delay = delay self . capacity = capacity self . transit_delay = transit_delay self . stats = { \"last_state_change_time\" : None , \"time_averaged_num_of_items_in_fleet\" : 0 , \"total_time_spent_in_states\" :{ \"IDLE_STATE\" : 0.0 , \"RELEASING_STATE\" : 0.0 , \"BLOCKED_STATE\" : 0.0 } } # Initialize the fleet store self . inbuiltstore = FleetStore ( env , capacity = self . capacity , delay = self . delay , transit_delay = self . transit_delay ) if callable ( delay ) or hasattr ( delay , '__next__' ) or isinstance ( delay , ( int , float )) or delay is None : self . delay = delay else : raise ValueError ( \"delay must be None, int, float, generator, or callable.\" )","title":"Fleet"},{"location":"api_ref_main_page_2/#factorysimpy.edges.fleet.Fleet.can_get","text":"Check if the fleet can accept an item.","title":"can_get"},{"location":"api_ref_main_page_2/#factorysimpy.edges.fleet.Fleet.can_get--returns","text":"bool True if the fleet can give an item, False otherwise. Source code in src/factorysimpy/edges/fleet.py 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 def can_get ( self ): \"\"\" Check if the fleet can accept an item. Returns ------- bool True if the fleet can give an item, False otherwise. \"\"\" if not self . inbuiltstore . ready_items : return False #only return items that are older than the delay. Count such items #count = sum(1 for item in self.inbuiltstore.items if item.time_stamp_creation + self.delay <= self.env.now) # count should be greater than the number of reservations that are already there return len ( self . inbuiltstore . ready_items ) > len ( self . inbuiltstore . reservations_get )","title":"Returns"},{"location":"api_ref_main_page_2/#factorysimpy.edges.fleet.Fleet.can_put","text":"Check if the fleet can accept an item.","title":"can_put"},{"location":"api_ref_main_page_2/#factorysimpy.edges.fleet.Fleet.can_put--returns","text":"bool True if the fleet can accept an item, False otherwise. Source code in src/factorysimpy/edges/fleet.py 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 def can_put ( self ): \"\"\" Check if the fleet can accept an item. Returns ------- bool True if the fleet can accept an item, False otherwise. \"\"\" # Check if the fleet has space for new items if len ( self . inbuiltstore . items ) + len ( self . inbuiltstore . ready_items ) == self . capacity : return False # return True if the number of items in the fleet is less than the store capacity minus the number of reservations # reservations_put is the number of items that are already reserved to be put in the fleet return ( self . capacity - len ( self . inbuiltstore . items ) - len ( self . inbuiltstore . ready_items )) > len ( self . inbuiltstore . reservations_put )","title":"Returns"},{"location":"api_ref_main_page_2/#factorysimpy.edges.fleet.Fleet.get","text":"Get an item from the fleet.","title":"get"},{"location":"api_ref_main_page_2/#factorysimpy.edges.fleet.Fleet.get--parameters","text":"event : simpy.Event The event that was reserved for getting an item.","title":"Parameters"},{"location":"api_ref_main_page_2/#factorysimpy.edges.fleet.Fleet.get--returns","text":"item : object The item retrieved from the fleet. Source code in src/factorysimpy/edges/fleet.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 def get ( self , event ): \"\"\" Get an item from the fleet. Parameters ---------- event : simpy.Event The event that was reserved for getting an item. Returns ------- item : object The item retrieved from the fleet. \"\"\" #print(f\"T={self.env.now:.2f}: {self.id} is getting an item at time {self.env.now}, total item in fleet is {len(self.inbuiltstore.items)+len(self.inbuiltstore.ready_items)}\") item = self . inbuiltstore . get ( event ) self . _fleet_stats_collector () #print(f\"T={self.env.now:.2f}, got an item!!!!\") item . fleet_exit_time = self . env . now return item","title":"Returns"},{"location":"api_ref_main_page_2/#factorysimpy.edges.fleet.Fleet.reserve_get_cancel","text":"Cancel a reserved get event.","title":"reserve_get_cancel"},{"location":"api_ref_main_page_2/#factorysimpy.edges.fleet.Fleet.reserve_get_cancel--parameters","text":"event : simpy.Event The event that was reserved for getting an item. Source code in src/factorysimpy/edges/fleet.py 173 174 175 176 177 178 179 180 181 182 def reserve_get_cancel ( self , event ): \"\"\" Cancel a reserved get event. Parameters ---------- event : simpy.Event The event that was reserved for getting an item. \"\"\" return self . inbuiltstore . reserve_get_cancel ( event )","title":"Parameters"},{"location":"api_ref_main_page_2/#factorysimpy.edges.fleet.Fleet.reserve_put_cancel","text":"Cancel a reserved put event.","title":"reserve_put_cancel"},{"location":"api_ref_main_page_2/#factorysimpy.edges.fleet.Fleet.reserve_put_cancel--parameters","text":"event : simpy.Event The event that was reserved for putting an item. Source code in src/factorysimpy/edges/fleet.py 184 185 186 187 188 189 190 191 192 193 def reserve_put_cancel ( self , event ): \"\"\" Cancel a reserved put event. Parameters ---------- event : simpy.Event The event that was reserved for putting an item. \"\"\" return self . inbuiltstore . reserve_put_cancel ( event )","title":"Parameters"},{"location":"api_ref_main_page_2/#factorysimpy.edges.slotted_conveyor","text":"","title":"slotted_conveyor"},{"location":"api_ref_main_page_2/#factorysimpy.edges.slotted_conveyor.ConveyorBelt","text":"Bases: Edge A conveyor belt system with optional accumulation. Attributes: capacity ( int ) : Maximum capacity of the belt . state ( str ) : state of the conveyor belt . delay ( float ) : Time interval between two successive movements on the belt . accumulation ( bool ) : Whether the belt supports accumulation ( 1 for yes , 0 for no ) . Source code in src/factorysimpy/edges/slotted_conveyor.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 def __init__ ( self , env , id , capacity , delay , accumulating ): super () . __init__ ( env , id , capacity ) self . state = \"IDLE_STATE\" #self.length= length #length of the item self . accumulating = accumulating self . delay = delay #self.delay = int(self.length/self.speed)*capacity self . belt = BeltStore ( env , capacity , self . delay ) #self.time_per_item = self.length/self.speed #self.inp_buf=ReservablePriorityReqStore(env, capacity=1) #self.out_buf=ReservablePriorityReqStore(env, capacity=1) self . stats = { \"last_state_change_time\" : None , \"time_averaged_num_of_items_in_conveyor\" : 0 , \"total_time_spent_in_states\" :{ \"IDLE_STATE\" : 0.0 , \"MOVING_STATE\" : 0.0 , \"ACCUMULATING_STATE\" : 0.0 , \"STALLED_NONACCUMULATING_STATE\" : 0.0 } } self . item_arrival_event = self . env . event () # self.item_get_event=self.env.event() self . get_events_available = self . env . event () self . put_events_available = self . env . event () self . noaccumulation_mode_on = False # self.get_request_queue = [] # self.put_request_queue = [] # self.active_events = [] # self.get_dict = {} # self.put_dict = {} self . env . process ( self . behaviour ())","title":"ConveyorBelt"},{"location":"api_ref_main_page_2/#factorysimpy.edges.slotted_conveyor.ConveyorBelt.can_get","text":"Check if an item can be retrieved from the belt. Source code in src/factorysimpy/edges/slotted_conveyor.py 138 139 140 141 142 143 144 def can_get ( self ): \"\"\"Check if an item can be retrieved from the belt.\"\"\" #first_item_to_go_out = self.items[0] if self.items else None if not self . out_buf . items : return False else : return True","title":"can_get"},{"location":"api_ref_main_page_2/#factorysimpy.edges.slotted_conveyor.ConveyorBelt.can_put","text":"Check if an item can be added to the belt. Source code in src/factorysimpy/edges/slotted_conveyor.py 153 154 155 156 157 158 def can_put ( self ): \"\"\"Check if an item can be added to the belt.\"\"\" if not self . inp_buf . items : return True else : return False","title":"can_put"},{"location":"api_ref_main_page_2/#factorysimpy.edges.slotted_conveyor.ConveyorBelt.get","text":"Get an item from the belt.","title":"get"},{"location":"api_ref_main_page_2/#factorysimpy.edges.slotted_conveyor.ConveyorBelt.get--parameters","text":"event : simpy.Event The event that was reserved for getting an item.","title":"Parameters"},{"location":"api_ref_main_page_2/#factorysimpy.edges.slotted_conveyor.ConveyorBelt.get--returns","text":"Item The item retrieved from the belt. Source code in src/factorysimpy/edges/slotted_conveyor.py 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 def get ( self , event ): \"\"\" Get an item from the belt. Parameters ---------- event : simpy.Event The event that was reserved for getting an item. Returns ------- Item The item retrieved from the belt. \"\"\" print ( f \"T= { self . env . now : .2f } : { self . id } :get: getting item from belt\" ) item = self . belt . get ( event ) item . conveyor_exit_time = self . env . now self . _conveyor_stats_collector () # event= self.env.event() # self.get_events_available.succeed() return item","title":"Returns"},{"location":"api_ref_main_page_2/#factorysimpy.edges.slotted_conveyor.ConveyorBelt.is_empty","text":"Check if the belt is completely empty. Source code in src/factorysimpy/edges/slotted_conveyor.py 127 128 129 def is_empty ( self ): \"\"\"Check if the belt is completely empty.\"\"\" return ( len ( self . belt . items ) + len ( self . belt . ready_items ) == 0 )","title":"is_empty"},{"location":"api_ref_main_page_2/#factorysimpy.edges.slotted_conveyor.ConveyorBelt.is_full","text":"Check if the belt is full. Source code in src/factorysimpy/edges/slotted_conveyor.py 134 135 136 def is_full ( self ): \"\"\"Check if the belt is full.\"\"\" return len ( self . belt . items ) + len ( self . belt . ready_items ) == self . belt . capacity","title":"is_full"},{"location":"api_ref_main_page_2/#factorysimpy.edges.slotted_conveyor.ConveyorBelt.is_stalled","text":"Check if the belt is stalled due to time constraints. Source code in src/factorysimpy/edges/slotted_conveyor.py 146 147 148 149 150 151 def is_stalled ( self ): \"\"\"Check if the belt is stalled due to time constraints.\"\"\" if self . belt . ready_items and len ( self . belt . reservations_get ) == 0 : return True else : return False","title":"is_stalled"},{"location":"api_ref_main_page_2/#factorysimpy.edges.slotted_conveyor.ConveyorBelt.put","text":"Put an item into the belt.","title":"put"},{"location":"api_ref_main_page_2/#factorysimpy.edges.slotted_conveyor.ConveyorBelt.put--parameters","text":"event : simpy.Event The event that was reserved for putting an item. item : Item The item to be put on the belt.","title":"Parameters"},{"location":"api_ref_main_page_2/#factorysimpy.edges.slotted_conveyor.ConveyorBelt.put--returns","text":"simpy.Event An event that will be triggered when the item is successfully put on the belt. Source code in src/factorysimpy/edges/slotted_conveyor.py 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 def put ( self , event , item ): \"\"\" Put an item into the belt. Parameters ---------- event : simpy.Event The event that was reserved for putting an item. item : Item The item to be put on the belt. Returns ------- simpy.Event An event that will be triggered when the item is successfully put on the belt. \"\"\" #delay=self.get_delay(self.delay) print ( f \"T= { self . env . now : .2f } : Conveyor:put: putting item { item . id } \" ) delay = self . capacity * self . delay item . conveyor_entry_time = self . env . now item_to_put = ( item , delay ) print ( f \"T= { self . env . now : .2f } : { self . id } :put: putting item { item_to_put [ 0 ] . id } on belt with delay { item_to_put [ 1 ] } \" ) return_val = self . belt . put ( event , item_to_put ) self . _conveyor_stats_collector () # if len(self.belt.items)==1: # self.item_arrival_event.succeed() # print(f\"T={self.env.now:.2f}: {self.id }:put: item arrival event succeeded\") # else: # self.put_events_available.succeed() # print(f\"T={self.env.now:.2f}: {self.id }:put: item arrival event else succeeded\") return return_val","title":"Returns"},{"location":"api_ref_main_page_2/#factorysimpy.edges.slotted_conveyor.ConveyorBelt.set_conveyor_state","text":"Set the conveyor state and manage belt store interrupts/resumes. Parameters: new_state ( str ) \u2013 The new conveyor state Source code in src/factorysimpy/edges/slotted_conveyor.py 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 def set_conveyor_state ( self , new_state ): \"\"\" Set the conveyor state and manage belt store interrupts/resumes. Args: new_state (str): The new conveyor state \"\"\" old_state = self . state self . state = new_state print ( f \"T= { self . env . now : .2f } : { self . id } state changed from { old_state } to { new_state } \" ) # Control belt store based on conveyor state changes if old_state in [ \"MOVING_STATE\" , \"IDLE_STATE\" ] and new_state in [ \"STALLED_ACCUMULATING_STATE\" , \"STALLED_NONACCUMULATING_STATE\" ]: # When conveyor becomes stalled (either accumulating or non-accumulating), apply selective interruption self . belt . selective_interrupt ( f \"Conveyor { self . id } selective interruption - { new_state } \" ) elif old_state in [ \"STALLED_ACCUMULATING_STATE\" , \"STALLED_NONACCUMULATING_STATE\" ] and new_state in [ \"MOVING_STATE\" , \"IDLE_STATE\" ]: # When conveyor resumes to moving or becomes idle, resume all belt store processes self . belt . resume_all_move_processes ()","title":"set_conveyor_state"},{"location":"api_ref_main_page_2/#factorysimpy.helper","text":"","title":"helper"},{"location":"api_ref_main_page_2/#factorysimpy.helper.baseflowitem","text":"","title":"baseflowitem"},{"location":"api_ref_main_page_2/#factorysimpy.helper.baseflowitem.BaseFlowItem","text":"A class representing an item . Source code in src/factorysimpy/helper/baseflowitem.py 3 4 5 6 7 8 9 10 11 12 13 def __init__ ( self , id ): self . id = id self . timestamp_creation = None self . timestamp_destruction = None self . timestamp_node_entry = None self . timestamp_node_exit = None self . current_node_id = None self . source_id = None # Track the source node self . payload = None self . destructed_in_node = None # Node where item was destructed self . stats = {} # Dictionary to store time spent at each node","title":"BaseFlowItem"},{"location":"api_ref_main_page_2/#factorysimpy.helper.baseflowitem.BaseFlowItem.set_creation","text":"Set creation time and source node ID. Source code in src/factorysimpy/helper/baseflowitem.py 15 16 17 18 def set_creation ( self , source_id , env ): \"\"\"Set creation time and source node ID.\"\"\" self . timestamp_creation = env . now self . source_id = source_id","title":"set_creation"},{"location":"api_ref_main_page_2/#factorysimpy.helper.baseflowitem.BaseFlowItem.set_destruction","text":"set the destruction time and node of the item. Source code in src/factorysimpy/helper/baseflowitem.py 20 21 22 23 def set_destruction ( self , node_id , env ): \"\"\"set the destruction time and node of the item.\"\"\" self . timestamp_destruction = env . now self . destructed_in_node = node_id","title":"set_destruction"},{"location":"api_ref_main_page_2/#factorysimpy.helper.baseflowitem.BaseFlowItem.update_node_event","text":"Update item details and stats when entering or exiting a node. Parameters: node_id ( str ) \u2013 The ID of the node. env ( Environment ) \u2013 The simulation environment (for current time). event_type ( str , default: 'entry' ) \u2013 \"entry\" or \"exit\" to specify the event. Source code in src/factorysimpy/helper/baseflowitem.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def update_node_event ( self , node_id , env , event_type = \"entry\" ): \"\"\" Update item details and stats when entering or exiting a node. Args: node_id (str): The ID of the node. env (simpy.Environment): The simulation environment (for current time). event_type (str): \"entry\" or \"exit\" to specify the event. \"\"\" if event_type == \"entry\" : self . timestamp_node_entry = env . now #print(f\"T={self.timestamp_node_entry:.2f}: {self.id} entered node {node_id}\") self . current_node_id = node_id elif event_type == \"exit\" : self . timestamp_node_exit = env . now # Calculate time spent at the node and update stats if self . current_node_id is not None and self . timestamp_node_entry is not None : time_spent = self . timestamp_node_exit - self . timestamp_node_entry if self . current_node_id in self . stats : self . stats [ self . current_node_id ] += time_spent else : self . stats [ self . current_node_id ] = time_spent","title":"update_node_event"},{"location":"api_ref_main_page_2/#factorysimpy.helper.item","text":"","title":"item"},{"location":"api_ref_main_page_2/#factorysimpy.helper.item.Item","text":"Bases: BaseFlowItem A class representing a pallet, which can hold multiple items. Source code in src/factorysimpy/helper/item.py 5 6 7 def __init__ ( self , id ): super () . __init__ ( id ) self . flow_item_type = \"item\"","title":"Item"},{"location":"api_ref_main_page_2/#factorysimpy.helper.pallet","text":"","title":"pallet"},{"location":"api_ref_main_page_2/#factorysimpy.helper.pallet.Pallet","text":"Bases: BaseFlowItem A class representing a pallet, which can hold multiple items. Source code in src/factorysimpy/helper/pallet.py 5 6 7 8 def __init__ ( self , id ): super () . __init__ ( id ) self . flow_item_type = \"Pallet\" self . items = [] # List to hold contained items","title":"Pallet"},{"location":"api_ref_main_page_2/#factorysimpy.helper.pallet.Pallet.add_item","text":"Add an item to the pallet. Source code in src/factorysimpy/helper/pallet.py 10 11 12 def add_item ( self , item ): \"\"\"Add an item to the pallet.\"\"\" self . items . append ( item )","title":"add_item"},{"location":"api_ref_main_page_2/#factorysimpy.helper.pallet.Pallet.remove_item","text":"Remove an item from the pallet if present. Source code in src/factorysimpy/helper/pallet.py 14 15 16 17 18 19 def remove_item ( self ): \"\"\"Remove an item from the pallet if present.\"\"\" if self . items : item = self . items . pop ( - 1 ) # Remove the last item return item return None","title":"remove_item"},{"location":"api_ref_main_page_2/#factorysimpy.nodes","text":"","title":"nodes"},{"location":"api_ref_main_page_2/#factorysimpy.nodes.combiner","text":"","title":"combiner"},{"location":"api_ref_main_page_2/#factorysimpy.nodes.combiner.Combiner","text":"Bases: Node Combiner class representing a processing node in a factory simulation. Inherits from the Node class.The combiner can have multiple input edges and a multiple output edges. It gets items from the input edges and packs them into a pallet or box and pushes it to the output edge. Parameters: state ( str ) \u2013 Current state of the combiner node. One of : SETUP_STATE: Initial setup phase before combiner starts to operate. IDLE_STATE: Worker threads waiting to receive items. PROCESSING_STATE: Actively processing items. BLOCKED_STATE: When all the worker threads are waiting to push the processed item but the out going edge is full. blocking ( bool , default: True ) \u2013 If True, the source waits until it can put an item into the out edge. If False, it discards the item if the out edge is full and cannot accept the item that is being pushed by the combiner. processing_delay ( (None, int , float , Generator , Callable ) , default: 0 ) \u2013 Delay for processing items. Can be: None: Used when the processing time depends on parameters of the node object (like current state of the object) or environment. int or float: Used as a constant delay. Generator: A generator function yielding delay values over time. Callable: A function that returns a delay (int or float). out_edge_selection ( None or str or callable , default: 'FIRST_AVAILABLE' ) \u2013 Criterion or function for selecting the out edge. Options include \"RANDOM\", \"ROUND_ROBIN\", \"FIRST_AVAILABLE\". None: None: Used when out edge selction depends on parameters of the node object (like current state of the object) or environment. str: A string that specifies the selection method. \"RANDOM\": Selects a random out edge in the out_edges list. \"ROUND_ROBIN\": Selects out edges in a round-robin manner. \"FIRST_AVAILABLE\": Selects the first out edge that can accept an item. callable: A function that returns an edge index. Behavior The combiner node represents components that process or modify the items that flow in the simulation model. It can have multiple incoming edges and multiple outgoing edge. Edge to which processed item is pushed is decided using the method specified in the parameter out_edge_selection . Combiner will transition through the states- SETUP_STATE , PROCESSING_STATE , IDLE_STATE and BLOCKED_STATE . The combiner has a blocking behavior if blocking = True and gets blocked when all its worker threads have processed items and the out edge is full and cannot accept the item that is being pushed by the combiner and waits until the out edge can accept the item. If blocking = False , the combiner will discard the item if the out edge is full and cannot accept the item that is being pushed by the combiner. Raises: AssertionError \u2013 If the combiner has no input or output edges. Output performance metrics: The key performance metrics of the combiner node is captured in stats attribute (dict) during a simulation run. last_state_change_time : Time when the state was last changed . num_item_processed : Total number of items generated . num_item_discarded : Total number of items discarded . total_time_spent_in_states : Dictionary with total time spent in each state . Source code in src/factorysimpy/nodes/combiner.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 def __init__ ( self , env , id , in_edges = None , out_edges = None , node_setup_time = 0 , target_quantity_of_each_item = [ 1 ], processing_delay = 0 , blocking = True , out_edge_selection = \"FIRST_AVAILABLE\" ): super () . __init__ ( env , id , in_edges , out_edges , node_setup_time ) self . state = \"SETUP_STATE\" # Initial state of the combiner self . work_capacity = 1 self . out_edge_selection = out_edge_selection self . blocking = blocking self . per_thread_total_time_in_blocked_state = 0.0 self . per_thread_total_time_in_processing_state = 0.0 self . target_quantity_of_each_item = target_quantity_of_each_item self . worker_thread_list = [] # List to keep track of worker threads self . item_in_process = None self . pallet_in_process = None self . num_workers = 0 # Number of worker threads currently processing self . time_last_occupancy_change = 0 # Time when the occupancy was last changed self . worker_thread = simpy . Resource ( env , capacity = self . work_capacity ) # Resource for worker threads self . time_per_work_occupancy = [ 0.0 for _ in range ( self . work_capacity + 1 )] # Time spent by each worker thread self . stats = { \"total_time_spent_in_states\" : { \"SETUP_STATE\" : 0.0 , \"IDLE_STATE\" : 0.0 , \"PROCESSING_STATE\" : 0.0 , \"BLOCKED_STATE\" : 0.0 }, \"last_state_change_time\" : None , \"num_item_processed\" : 0 , \"num_item_discarded\" : 0 , \"processing_delay\" :[], \"out_edge_selection\" :[]} # Initialize processing delay # If processing_delay is a generator, callable, int, float or None, it is accepted. if callable ( processing_delay ) or hasattr ( processing_delay , '__next__' ) or isinstance ( processing_delay , ( int , float )) or processing_delay is None : self . processing_delay = processing_delay else : raise ValueError ( \"processing_delay must be None, int, float, generator, or callable.\" ) self . env . process ( self . behaviour ()) # Start the combiner behavior process","title":"Combiner"},{"location":"api_ref_main_page_2/#factorysimpy.nodes.combiner.Combiner.add_in_edges","text":"Adds an in_edge to the node. Raises an error if the edge already exists in the in_edges list. Parameters: edge (Edge Object) \u2013 The edge to be added as an in_edge. Source code in src/factorysimpy/nodes/combiner.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 def add_in_edges ( self , edge ): \"\"\" Adds an in_edge to the node. Raises an error if the edge already exists in the in_edges list. Args: edge (Edge Object) : The edge to be added as an in_edge. \"\"\" if self . in_edges is None : self . in_edges = [] # if len(self.in_edges) >= self.num_in_edges: # raise ValueError(f\"Combiner'{self.id}' already has {self.num_in_edges} in_edges. Cannot add more.\") if edge not in self . in_edges : self . in_edges . append ( edge ) else : raise ValueError ( f \"Edge already exists in Combiner ' { self . id } ' in_edges.\" )","title":"add_in_edges"},{"location":"api_ref_main_page_2/#factorysimpy.nodes.combiner.Combiner.add_out_edges","text":"Adds an out_edge to the node. Raises an error if the edge already exists in the out_edges list. Parameters: edge (Edge Object) \u2013 The edge to be added as an out_edge. Source code in src/factorysimpy/nodes/combiner.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 def add_out_edges ( self , edge ): \"\"\" Adds an out_edge to the node. Raises an error if the edge already exists in the out_edges list. Args: edge (Edge Object) : The edge to be added as an out_edge. \"\"\" if self . out_edges is None : self . out_edges = [] # if len(self.out_edges) >= 1: # raise ValueError(f\"Combiner '{self.id}' already has 1 out_edge. Cannot add more.\") if edge not in self . out_edges : self . out_edges . append ( edge ) else : raise ValueError ( f \"Edge already exists in Combiner ' { self . id } ' out_edges.\" )","title":"add_out_edges"},{"location":"api_ref_main_page_2/#factorysimpy.nodes.combiner.Combiner.update_state","text":"Update node state and track the time spent in the previous state. Parameters: i ( int ) \u2013 The index of the worker thread to update the state for. new_state ( str ) \u2013 The new state to transition to. Must be one of \"SETUP_STATE\", \"GENERATING_STATE\", \"BLOCKED_STATE\". current_time ( float ) \u2013 The current simulation time. Source code in src/factorysimpy/nodes/combiner.py 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 def update_state ( self , new_state : str , current_time : float ): \"\"\" Update node state and track the time spent in the previous state. Args: i (int): The index of the worker thread to update the state for. new_state (str): The new state to transition to. Must be one of \"SETUP_STATE\", \"GENERATING_STATE\", \"BLOCKED_STATE\". current_time (float): The current simulation time. \"\"\" if self . state is not None and self . stats [ \"last_state_change_time\" ] is not None : elapsed = current_time - self . stats [ \"last_state_change_time\" ] self . stats [ \"total_time_spent_in_states\" ][ self . state ] = ( self . stats [ \"total_time_spent_in_states\" ] . get ( self . state , 0.0 ) + elapsed ) self . state = new_state self . stats [ \"last_state_change_time\" ] = current_time","title":"update_state"},{"location":"api_ref_main_page_2/#factorysimpy.nodes.machine","text":"","title":"machine"},{"location":"api_ref_main_page_2/#factorysimpy.nodes.machine.Machine","text":"Bases: Node Machine represents a processing node in a factory simulation. This Machine can have multiple input edges and output edges. Parameters: state_rep ( tuple ) \u2013 Current state of the machine node representates as a tuple based on the state of the worker threads (num_worker_threads_processing, num_worker_threads_blocked). Worker threads can be either in the processing state or in the blocked state. Based on that machine can be in one or many of the following states: SETUP_STATE: Initial setup phase before machine starts to operate. Denoted as (-1,-1) IDLE_STATE: Worker threads waiting to receive items. Denoted as (0,0) ATLEAST_ONE_PROCESSING_STATE: Active state where items are being processed. State when atleast one thread is in processing state. ALL_ACTIVE_BLOCKED_STATE: The state when all the worker_threads that are currently active are in \"BLOCKED_STATE\" as they are waiting for the out edge to be available to accept the processed item. Number of active threads can be equal to greater than work_capacity. ALL_ACTIVE_PROCESSING_STATE: The state when all the active threads are in processing state. Number of active threads can be equal to greater than work_capacity. ATLEAST_ONE_BLOCKED_STATE: The state when atleast one of the worker_threads is in \"BLOCKED_STATE\" as it is waiting for the out edge to be available to accept the processed item. blocking ( bool , default: True ) \u2013 If True, the source waits until it can put an item into the out edge. If False, it discards the item if the out edge is full and cannot accept the item that is being pushed by the machine. work_capacity ( int , default: 1 ) \u2013 Maximum no. of processing that can be performed simultaneously.1 worker thread can process one item. processing_delay ( (None, int , float , Generator , Callable ) , default: 0 ) \u2013 Delay for processing items. Can be: None: Used when the processing time depends on parameters of the node object (like current state of the object) or environment. int or float: Used as a constant delay. Generator: A generator function yielding delay values over time. Callable: A function that returns a delay (int or float). in_edge_selection ( None or str or callable , default: 'FIRST_AVAILABLE' ) \u2013 Criterion or function for selecting the edge. Options include \"RANDOM\", \"ROUND_ROBIN\", \"FIRST_AVAILABLE\". None: None: Used when edge selction depends on parameters of the node object (like current state of the object) or environment. str: A string that specifies the selection method. \"RANDOM\": Selects a random edge. \"ROUND_ROBIN\": Selects edges in a round-robin manner. \"FIRST_AVAILABLE\": Selects the first out edge that can give an item. callable: A function that returns an edge index. out_edge_selection ( None or str or callable , default: 'FIRST_AVAILABLE' ) \u2013 Criterion or function for selecting the out edge. Options include \"RANDOM\", \"ROUND_ROBIN\", \"FIRST_AVAILABLE\". None: None: Used when out edge selction depends on parameters of the node object (like current state of the object) or environment. str: A string that specifies the selection method. \"RANDOM\": Selects a random out edge in the out_edges list. \"ROUND_ROBIN\": Selects out edges in a round-robin manner. \"FIRST_AVAILABLE\": Selects the first out edge that can accept an item. callable: A function that returns an edge index. Behavior The machine node represents components that process or modify the items that flow in the simulation model. It can have multiple incoming edges and multiple outgoing edge. Edge from which the item comes in and the edge to which processed item is pushed is decided using the method specified in the parameter in_edge_selection and out_edge_selection . Machine will transition through the states- SETUP_STATE , PROCESSING_STATE , IDLE_STATE and BLOCKED_STATE . The machine has a blocking behavior if blocking = True and gets blocked when all its worker threads have processed items and the out edge is full and cannot accept the item that is being pushed by the machine and waits until the out edge can accept the item. If blocking = False , the machine will discard the item if the out edge is full and cannot accept the item that is being pushed by the machine. Raises: AssertionError \u2013 If the Machine has no input or output edges. Output performance metrics: The key performance metrics of the Machine node is captured in stats attribute (dict) during a simulation run. last_state_change_time : Time when the state was last changed . num_item_processed : Total number of items generated . num_item_discarded : Total number of items discarded . total_time_spent_in_states : Dictionary with total time spent in each state . Source code in src/factorysimpy/nodes/machine.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 def __init__ ( self , env , id , in_edges = None , out_edges = None , node_setup_time = 0 , work_capacity = 1 , processing_delay = 0 , blocking = True , in_edge_selection = \"FIRST_AVAILABLE\" , out_edge_selection = \"FIRST_AVAILABLE\" ): super () . __init__ ( env , id , in_edges , out_edges , node_setup_time ) self . work_capacity = work_capacity self . in_edge_selection = in_edge_selection self . out_edge_selection = out_edge_selection self . state_rep = None self . blocking = blocking self . per_thread_total_time_in_blocked_state = 0.0 self . per_thread_total_time_in_processing_state = 0.0 self . worker_thread_list = [] # List to keep track of worker threads self . item_in_process = None self . num_workers = 0 # Number of worker threads currently processing self . time_last_occupancy_change = 0 # Time when the occupancy was last changed self . worker_thread = simpy . Resource ( env , capacity = self . work_capacity ) # Resource for worker threads self . time_per_work_occupancy = [ 0.0 for _ in range ( work_capacity + 1 )] # Time spent by each worker thread #self.stats={\"total_time_spent_in_states\": {\"SETUP_STATE\": 0.0, \"IDLE_STATE\":0.0, \"PROCESSING_STATE\": 0.0,\"BLOCKED_STATE\":0.0 }, # \"last_state_change_time\": None, \"num_item_processed\": 0, \"num_item_discarded\": 0,\"processing_delay\":[], \"in_edge_selection\":[],\"out_edge_selection\":[]} self . total_time_all_blocked = 0.0 self . total_time_all_processing = 0.0 self . total_time_atleast_one_blocked = 0.0 self . total_time_atleast_one_processing = 0.0 self . total_time_idle = 0.0 self . total_time_setup = 0.0 self . stats = { \"total_time_spent_in_states\" : { \"SETUP_STATE\" : 0.0 , \"IDLE_STATE\" : 0.0 , \"ATLEAST_ONE_PROCESSING_STATE\" : 0.0 , \"ALL_ACTIVE_BLOCKED_STATE\" : 0.0 , \"ALL_ACTIVE_PROCESSING_STATE\" : 0.0 , \"ATLEAST_ONE_BLOCKED_STATE\" : 0.0 }, \"last_state_change_time\" : None , \"num_item_processed\" : 0 , \"num_item_discarded\" : 0 , \"processing_delay\" :[], \"in_edge_selection\" :[], \"out_edge_selection\" :[]} # Initialize processing delay # If processing_delay is a generator, callable, int, float or None, it is accepted. if callable ( processing_delay ) or hasattr ( processing_delay , '__next__' ) or isinstance ( processing_delay , ( int , float )) or processing_delay is None : self . processing_delay = processing_delay else : raise ValueError ( \"processing_delay must be None, int, float, generator, or callable.\" ) self . env . process ( self . behaviour ()) # Start the machine behavior process","title":"Machine"},{"location":"api_ref_main_page_2/#factorysimpy.nodes.machine.Machine.add_in_edges","text":"Adds an in_edge to the node. Raises an error if the edge already exists in the in_edges list. Parameters: edge (Edge Object) \u2013 The edge to be added as an in_edge. Source code in src/factorysimpy/nodes/machine.py 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 def add_in_edges ( self , edge ): \"\"\" Adds an in_edge to the node. Raises an error if the edge already exists in the in_edges list. Args: edge (Edge Object) : The edge to be added as an in_edge. \"\"\" if self . in_edges is None : self . in_edges = [] # if len(self.in_edges) >= self.num_in_edges: # raise ValueError(f\"Machine'{self.id}' already has {self.num_in_edges} in_edges. Cannot add more.\") if edge not in self . in_edges : self . in_edges . append ( edge ) else : raise ValueError ( f \"Edge already exists in Machine ' { self . id } ' in_edges.\" )","title":"add_in_edges"},{"location":"api_ref_main_page_2/#factorysimpy.nodes.machine.Machine.add_out_edges","text":"Adds an out_edge to the node. Raises an error if the edge already exists in the out_edges list. Parameters: edge (Edge Object) \u2013 The edge to be added as an out_edge. Source code in src/factorysimpy/nodes/machine.py 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 def add_out_edges ( self , edge ): \"\"\" Adds an out_edge to the node. Raises an error if the edge already exists in the out_edges list. Args: edge (Edge Object) : The edge to be added as an out_edge. \"\"\" if self . out_edges is None : self . out_edges = [] # if len(self.out_edges) >= 1: # raise ValueError(f\"Machine '{self.id}' already has 1 out_edge. Cannot add more.\") if edge not in self . out_edges : self . out_edges . append ( edge ) else : raise ValueError ( f \"Edge already exists in Machine ' { self . id } ' out_edges.\" )","title":"add_out_edges"},{"location":"api_ref_main_page_2/#factorysimpy.nodes.machine.Machine.update_state_rep","text":"Update the state representation tuple based on the current state of worker threads. Parameters: state ( str ) \u2013 The current state of the machine. current_time ( float ) \u2013 The current simulation time. Source code in src/factorysimpy/nodes/machine.py 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 def update_state_rep ( self , current_time ): \"\"\" Update the state representation tuple based on the current state of worker threads. Args: state (str): The current state of the machine. current_time (float): The current simulation time. \"\"\" previous_state_rep = self . state_rep if self . state_rep is not None and self . stats [ \"last_state_change_time\" ] is not None : elapsed = current_time - self . stats [ \"last_state_change_time\" ] # all idle if previous_state_rep == ( 0 , 0 ): self . stats [ \"total_time_spent_in_states\" ][ \"IDLE_STATE\" ] += elapsed self . total_time_idle += elapsed # all active are blocked and none processing if previous_state_rep [ 1 ] > 0 and previous_state_rep [ 0 ] == 0 : self . stats [ \"total_time_spent_in_states\" ][ \"ALL_ACTIVE_BLOCKED_STATE\" ] += elapsed self . total_time_all_blocked += elapsed # at least one processing if previous_state_rep [ 0 ] > 0 : self . stats [ \"total_time_spent_in_states\" ][ \"ATLEAST_ONE_PROCESSING_STATE\" ] += elapsed self . total_time_atleast_one_processing += elapsed # all active are processing and none blocked if previous_state_rep [ 0 ] > 0 and previous_state_rep [ 1 ] == 0 : self . stats [ \"total_time_spent_in_states\" ][ \"ALL_ACTIVE_PROCESSING_STATE\" ] += elapsed self . total_time_all_processing += elapsed #at least one blocked if previous_state_rep [ 1 ] > 0 : self . stats [ \"total_time_spent_in_states\" ][ \"ATLEAST_ONE_BLOCKED_STATE\" ] += elapsed self . total_time_atleast_one_blocked += elapsed num_processing , num_blocked = self . _count_worker_state () self . state_rep = ( num_processing , num_blocked ) self . stats [ \"last_state_change_time\" ] = current_time","title":"update_state_rep"},{"location":"api_ref_main_page_2/#factorysimpy.nodes.node","text":"","title":"node"},{"location":"api_ref_main_page_2/#factorysimpy.nodes.node.Node","text":"Base class to represent an active entity in a manufacturing system, such as machines, splits, or joints. Parameters: id ( str ) \u2013 Identifier for the node. node_setup_time ( int, or float , default: 0 ) \u2013 Initial setup time for the node. Can be: int or float: Used as a constant delay. in_edges ( list , default: None ) \u2013 List of input edges connected to the node. out_edges ( list , default: None ) \u2013 List of output edges connected to the node. Raises: TypeError \u2013 If the type of env or id is incorrect. ValueError \u2013 If node_setup_time input is invalid. Source code in src/factorysimpy/nodes/node.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def __init__ ( self , env , id , in_edges = None , out_edges = None , node_setup_time = 0 ): # Type checks if not isinstance ( env , simpy . Environment ): raise TypeError ( \"env must be a simpy.Environment instance\" ) if not isinstance ( id , str ): raise TypeError ( \"name must be a string\" ) self . env = env self . id = id # Identifier for the node. self . node_setup_time = node_setup_time # Time taken to set up the node. self . in_edges = in_edges # List of input edges connected to the node. self . out_edges = out_edges #List of output edges connected to the node. if isinstance ( node_setup_time , ( int , float )): self . node_setup_time = node_setup_time else : raise ValueError ( \"Invalid node_setup_time value. Provide constant ( int or float).\" )","title":"Node"},{"location":"api_ref_main_page_2/#factorysimpy.nodes.node.Node.get_delay","text":"Returns value based on the type of parameter delay provided. Parameters: delay ( int, float, generator, or callable ) \u2013 The delay time, which can be: int or float: Used as a constant delay. generator: A generator instance yielding delay values. callable: A function that returns a delay values. Returns: \u2013 Returns a constant delay if delay is an int or float, a value yielded if delay is a generator, or the value returned from a Callable function if delay is callable. Source code in src/factorysimpy/nodes/node.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def get_delay ( self , delay ): \"\"\" Returns value based on the type of parameter `delay` provided. Args: delay (int, float, generator, or callable): The delay time, which can be: - int or float: Used as a constant delay. - generator: A generator instance yielding delay values. - callable: A function that returns a delay values. Returns: Returns a constant delay if `delay` is an int or float, a value yielded if `delay` is a generator, or the value returned from a Callable function if `delay` is callable. \"\"\" if hasattr ( delay , '__next__' ): # Generator instance val = next ( delay ) elif callable ( delay ): # Function val = delay () else : # int or float val = delay #print(self.id) assert val >= 0 , f \" { self . id } - Delay must be non-negative\" return val","title":"get_delay"},{"location":"api_ref_main_page_2/#factorysimpy.nodes.node.Node.update_state","text":"Update node state and track the time spent in the previous state. Parameters: new_state ( str ) \u2013 The new state to transition to. Must be one of \"SETUP_STATE\", \"GENERATING_STATE\", \"BLOCKED_STATE\". current_time ( float ) \u2013 The current simulation time. Source code in src/factorysimpy/nodes/node.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 def update_state ( self , new_state : str , current_time : float ): \"\"\" Update node state and track the time spent in the previous state. Args: new_state (str): The new state to transition to. Must be one of \"SETUP_STATE\", \"GENERATING_STATE\", \"BLOCKED_STATE\". current_time (float): The current simulation time. \"\"\" if self . state is not None and self . stats [ \"last_state_change_time\" ] is not None : elapsed = current_time - self . stats [ \"last_state_change_time\" ] self . stats [ \"total_time_spent_in_states\" ][ self . state ] = ( self . stats [ \"total_time_spent_in_states\" ] . get ( self . state , 0.0 ) + elapsed ) self . state = new_state self . stats [ \"last_state_change_time\" ] = current_time","title":"update_state"},{"location":"api_ref_main_page_2/#factorysimpy.nodes.sink","text":"","title":"sink"},{"location":"api_ref_main_page_2/#factorysimpy.nodes.sink.Sink","text":"Bases: Node A Sink is a terminal node that collects flow items at the end. Once an item enters the Sink, it is considered to have exited the system and cannot be retrieved or processed further This sink can have multiple input edges and no output edges. Raises AssertionError: If the sink does not have at least 1 input edge or has an output edge. Source code in src/factorysimpy/nodes/sink.py 23 24 25 26 27 28 29 30 31 32 33 def __init__ ( self , env , id , in_edges = None , node_setup_time = 0 ): super () . __init__ ( env , id , in_edges , None , node_setup_time ) self . state = \"COLLECTING_STATE\" self . in_edge_events = [] self . stats = { \"num_item_received\" : 0 , \"last_state_change_time\" : 0.0 , \"total_time_spent_in_states\" :{ \"COLLECTING_STATE\" : 0.0 }, \"total_cycle_time\" : 0.0 } self . item_in_process = None self . buffertime = 0 # Start behavior process self . env . process ( self . behaviour ()) self . item_list = {}","title":"Sink"},{"location":"api_ref_main_page_2/#factorysimpy.nodes.source","text":"","title":"source"},{"location":"api_ref_main_page_2/#factorysimpy.nodes.source.Source","text":"Bases: Node Parameters: state ( str ) \u2013 Current state of the source node. One of : SETUP_STATE: Initial setup phase before item generation starts. GENERATING_STATE: Actively generating and dispatching items. BLOCKED_STATE: Waiting to transfer item when edge is full (in blocking mode). inter_arrival_time ( None, int, float, generator, or callable , default: 0 ) \u2013 Time between item generations. Can be: None: Used when the setup time depends on parameters of the node object (like current state of the object) or environment. int or float: Used as a constant delay. Callable: A function that returns a delay (int or float). Generator: A generator function yielding delay values over time. flow_item_type ( str , default: 'item' ) \u2013 Type of item to be generated. Default is \"item\". Can be \"item\" : Smallest unit of discrete item and it cannot hold other items inside. \"pallet\" : Entities that can store multiple smaller units of items blocking ( bool , default: False ) \u2013 If True, the source waits until it can put an item into the out edge. out_edge_selection ( None or str or callable , default: 'FIRST_AVAILABLE' ) \u2013 Criterion or function for selecting the out edge. Options include \"RANDOM\", \"FIRST\", \"LAST\", \"ROUND_ROBIN\", \"FIRST_AVAILABLE\". None: Used when out edge selection depends on parameters of the node object (like current state of the object) or environment. str: A string that specifies the selection method. \"RANDOM\": Selects a random out edge. \"ROUND_ROBIN\": Selects out edges in a round-robin manner. \"FIRST_AVAILABLE\": Selects the first out edge that can accept an item. callable: A function that returns an edge index. Behavior: The Source node is responsible for generating items that flow in the simulation model. It operates in two modes: blocking and non-blocking. when blocking=True : - After each inter_arrival_time , the source generates an item. - If the selected out edge is full, the source waits until space is available. - Once space is available, the item is transferred to the selected edge. - inter_arrival_time must not be None . when blocking=False : - After each inter_arrival_time , the source generates an item. - If the selected out edge is full, the item is discarded immediately. - If space is available, the item is transferred without waiting. - inter_arrival_time must not be 0. Raises: ValueError \u2013 If inter_arrival_time is 0 in non-blocking mode or if out_edge_selection is not a valid type. ValueError \u2013 If out_edge_selection is not a string or callable. ValueError \u2013 If out_edges is not provided or has less than one edge. ValueError \u2013 If in_edges is provided, as Source nodes should not have input edges. ValueError \u2013 If out_edges already has an edge when trying to add a new one. Output performance metrics: The key performance metrics of the Source node is captured in stats attribute (dict) during a simulation run. last_state_change_time : Time when the state was last changed . num_item_generated : Total number of items generated . num_item_discarded : Total number of items discarded due to lack of space in out edge . total_time_spent_in_states : Dictionary with total time spent in each state . Source code in src/factorysimpy/nodes/source.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def __init__ ( self , env , id , in_edges = None , out_edges = None , item_length = 1 , flow_item_type = \"item\" , inter_arrival_time = 0 , blocking = False , out_edge_selection = \"FIRST_AVAILABLE\" ): super () . __init__ ( env , id , in_edges , out_edges ) self . state = \"SETUP_STATE\" # Initial state of the source node self . blocking = blocking self . item_length = item_length self . out_edge_selection = out_edge_selection # Selection strategy for out edges self . flow_item_type = flow_item_type # Type of item to be generated, default is \"item\" self . stats = { \"last_state_change_time\" : None , \"num_item_generated\" : 0 , \"num_item_discarded\" : 0 , \"total_time_spent_in_states\" :{ \"SETUP_STATE\" : 0.0 , \"GENERATING_STATE\" : 0.0 , \"BLOCKED_STATE\" : 0.0 } } if inter_arrival_time == 0 and not self . blocking : raise ValueError ( \"Non-blocking source must have a non-zero inter_arrival_time.\" ) elif callable ( inter_arrival_time ): self . inter_arrival_time = inter_arrival_time elif hasattr ( inter_arrival_time , '__next__' ): self . inter_arrival_time = inter_arrival_time elif isinstance ( inter_arrival_time , ( int , float )): self . inter_arrival_time = inter_arrival_time # interarrival_time is None and will be initialized later by the user elif inter_arrival_time is None : self . inter_arrival_time = inter_arrival_time else : #print(\"GGG\",inter_arrival_time) raise ValueError ( \"inter_arrival_time must be a None, int, float, generator, or callable.\" ) # Start behavior process self . env . process ( self . behaviour ())","title":"Source"},{"location":"api_ref_main_page_2/#factorysimpy.nodes.source.Source.add_out_edges","text":"Adds an out_edge to the source node. Raises an error if the source already has an out_edge or if the edge already exists in the out_edges list. Parameters: edge ( Edge Object ) \u2013 The edge to be added as an out_edge. Source code in src/factorysimpy/nodes/source.py 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 def add_out_edges ( self , edge ): \"\"\" Adds an out_edge to the source node. Raises an error if the source already has an out_edge or if the edge already exists in the out_edges list. Args: edge (Edge Object): The edge to be added as an out_edge. \"\"\" if self . out_edges is None : self . out_edges = [] if len ( self . out_edges ) >= 1 : raise ValueError ( f \"Source ' { self . id } ' already has 1 out_edge. Cannot add more.\" ) if edge not in self . out_edges : self . out_edges . append ( edge ) else : raise ValueError ( f \"Edge already exists in Source ' { self . id } ' out_edges.\" )","title":"add_out_edges"},{"location":"api_ref_main_page_2/#factorysimpy.nodes.source.Source.update_state","text":"Update node state and track the time spent in the previous state. Parameters: i ( int ) \u2013 The index of the worker thread to update the state for. new_state ( str ) \u2013 The new state to transition to. Must be one of \"SETUP_STATE\", \"GENERATING_STATE\", \"BLOCKED_STATE\". current_time ( float ) \u2013 The current simulation time. Source code in src/factorysimpy/nodes/source.py 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 def update_state ( self , new_state : str , current_time : float ): \"\"\" Update node state and track the time spent in the previous state. Args: i (int): The index of the worker thread to update the state for. new_state (str): The new state to transition to. Must be one of \"SETUP_STATE\", \"GENERATING_STATE\", \"BLOCKED_STATE\". current_time (float): The current simulation time. \"\"\" if self . state is not None and self . stats [ \"last_state_change_time\" ] is not None : elapsed = current_time - self . stats [ \"last_state_change_time\" ] self . stats [ \"total_time_spent_in_states\" ][ self . state ] = ( self . stats [ \"total_time_spent_in_states\" ] . get ( self . state , 0.0 ) + elapsed ) self . state = new_state self . stats [ \"last_state_change_time\" ] = current_time","title":"update_state"},{"location":"api_ref_main_page_2/#factorysimpy.nodes.splitter","text":"","title":"splitter"},{"location":"api_ref_main_page_2/#factorysimpy.nodes.splitter.Splitter","text":"Bases: Node Splitter class representing a processing node that can unpack an incoming item and send it to multiple outgoing edges in a factory simulation. Parameters: state ( str ) \u2013 Current state of the splitter node. One of : SETUP_STATE: Initial setup phase before splitter starts to operate. IDLE_STATE: Worker threads waiting to receive items. PROCESSING_STATE: Actively processing items. BLOCKED_STATE: When all the worker threads are waiting to push the processed item but the out going edge is full. blocking ( bool , default: True ) \u2013 If True, the node waits until it can put an item into the out edge. If False, it discards the item if the out edge is full and cannot accept the item that is being pushed by the splitter. mode ( str , default: 'UNPACK' ) \u2013 Mode of operation of the splitter. Either \"UNPACK\" or \"SPLIT\". - \"UNPACK\": The splitter unpacks all items from a packed item (like a pallet) and pushes each item to an output edge, one by one. After all items are pushed, the empty container itself is pushed to an output edge. - \"SPLIT\": The splitter splits the incoming item into a target quantity of items, specified by split_quantity and pushes each item to an output edge, one by one. split_quantity ( int , default: None ) \u2013 Target quantity of items to split the input flow item into. This parameter is required if mode is \"SPLIT\". If mode is \"UNPACK\", this parameter is ignored. processing_delay ( (None, int , float , Generator , Callable ) , default: 0 ) \u2013 Delay for processing items. Can be: None: Used when the processing time depends on parameters of the node object (like current state of the object) or environment. int or float: Used as a constant delay. Generator: A generator function yielding delay values over time. Callable: A function that returns a delay (int or float). in_edge_selection ( None or str or callable , default: 'FIRST_AVAILABLE' ) \u2013 Criterion or function for selecting the edge. Options include \"RANDOM\", \"ROUND_ROBIN\", \"FIRST_AVAILABLE\". None: Used when edge selction depends on parameters of the node object (like current state of the object) or environment. str: A string that specifies the selection method. \"RANDOM\": Selects a random edge. \"ROUND_ROBIN\": Selects edges in a round-robin manner. \"FIRST_AVAILABLE\": Selects the first out edge that can give an item. callable: A function that returns an edge index. out_edge_selection ( None or str or callable , default: 'FIRST_AVAILABLE' ) \u2013 Criterion or function for selecting the out edge. Options include \"RANDOM\", \"ROUND_ROBIN\", \"FIRST_AVAILABLE\". None: None: Used when out edge selction depends on parameters of the node object (like current state of the object) or environment. str: A string that specifies the selection method. \"RANDOM\": Selects a random out edge in the out_edges list. \"ROUND_ROBIN\": Selects out edges in a round-robin manner. \"FIRST_AVAILABLE\": Selects the first out edge that can accept an item. callable: A function that returns an edge index. Behavior The Splitter node represents components that process or modify the items that flow in the simulation model. It can have multiple incoming edges and multiple outgoing edge. Edge from which the item comes in and the edge to which processed item is pushed is decided using the method specified in the parameter in_edge_selection and out_edge_selection . Splitter will transition through the states- SETUP_STATE , PROCESSING_STATE , IDLE_STATE and BLOCKED_STATE . The Splitter has a blocking behavior if blocking = True and gets blocked when all its worker threads have processed items and the out edge is full and cannot accept the item that is being pushed by the Splitter and waits until the out edge can accept the item. If blocking = False , the Splitter will discard the item if the out edge is full and cannot accept the item that is being pushed by the Splitter. Raises: AssertionError \u2013 If the Splitter has no input or output edges. Output performance metrics: The key performance metrics of the Splitter node is captured in stats attribute (dict) during a simulation run. last_state_change_time : Time when the state was last changed . num_item_processed : Total number of items generated . num_item_discarded : Total number of items discarded . total_time_spent_in_states : Dictionary with total time spent in each state . Source code in src/factorysimpy/nodes/splitter.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def __init__ ( self , env , id , in_edges = None , out_edges = None , node_setup_time = 0 , processing_delay = 0 , blocking = True , mode = \"UNPACK\" , split_quantity = None , in_edge_selection = \"FIRST_AVAILABLE\" , out_edge_selection = \"FIRST_AVAILABLE\" ): super () . __init__ ( env , id , in_edges , out_edges , node_setup_time ) self . state = \"SETUP_STATE\" # Initial state of the Splitter self . work_capacity = 1 self . in_edge_selection = in_edge_selection self . out_edge_selection = out_edge_selection self . blocking = blocking self . mode = mode self . split_quantity = split_quantity self . per_thread_total_time_in_blocked_state = 0.0 self . per_thread_total_time_in_processing_state = 0.0 self . worker_thread_list = [] # List to keep track of worker threads self . item_in_process = None self . pallet_in_process = None self . num_workers = 0 # Number of worker threads currently processing self . time_last_occupancy_change = 0 # Time when the occupancy was last changed self . worker_thread = simpy . Resource ( env , capacity = self . work_capacity ) # Resource for worker threads self . time_per_work_occupancy = [ 0.0 for _ in range ( self . work_capacity + 1 )] # Time spent by each worker thread self . stats = { \"total_time_spent_in_states\" : { \"SETUP_STATE\" : 0.0 , \"IDLE_STATE\" : 0.0 , \"PROCESSING_STATE\" : 0.0 , \"BLOCKED_STATE\" : 0.0 }, \"last_state_change_time\" : None , \"num_item_processed\" : 0 , \"num_item_discarded\" : 0 , \"processing_delay\" :[], \"in_edge_selection\" :[], \"out_edge_selection\" :[]} # Initialize processing delay # If processing_delay is a generator, callable, int, float or None, it is accepted. if callable ( processing_delay ) or hasattr ( processing_delay , '__next__' ) or isinstance ( processing_delay , ( int , float )) or processing_delay is None : self . processing_delay = processing_delay else : raise ValueError ( \"processing_delay must be None, int, float, generator, or callable.\" ) self . env . process ( self . behaviour ()) # Start the Splitter behavior process","title":"Splitter"},{"location":"api_ref_main_page_2/#factorysimpy.nodes.splitter.Splitter.add_in_edges","text":"Adds an in_edge to the node. Raises an error if the edge already exists in the in_edges list. Parameters: edge (Edge Object) \u2013 The edge to be added as an in_edge. Source code in src/factorysimpy/nodes/splitter.py 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 def add_in_edges ( self , edge ): \"\"\" Adds an in_edge to the node. Raises an error if the edge already exists in the in_edges list. Args: edge (Edge Object) : The edge to be added as an in_edge. \"\"\" if self . in_edges is None : self . in_edges = [] # if len(self.in_edges) >= self.num_in_edges: # raise ValueError(f\"Splitter'{self.id}' already has {self.num_in_edges} in_edges. Cannot add more.\") if edge not in self . in_edges : self . in_edges . append ( edge ) else : raise ValueError ( f \"Edge already exists in Splitter ' { self . id } ' in_edges.\" )","title":"add_in_edges"},{"location":"api_ref_main_page_2/#factorysimpy.nodes.splitter.Splitter.add_out_edges","text":"Adds an out_edge to the node. Raises an error if the edge already exists in the out_edges list. Parameters: edge (Edge Object) \u2013 The edge to be added as an out_edge. Source code in src/factorysimpy/nodes/splitter.py 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 def add_out_edges ( self , edge ): \"\"\" Adds an out_edge to the node. Raises an error if the edge already exists in the out_edges list. Args: edge (Edge Object) : The edge to be added as an out_edge. \"\"\" if self . out_edges is None : self . out_edges = [] # if len(self.out_edges) >= 1: # raise ValueError(f\"Splitter '{self.id}' already has 1 out_edge. Cannot add more.\") if edge not in self . out_edges : self . out_edges . append ( edge ) else : raise ValueError ( f \"Edge already exists in Splitter ' { self . id } ' out_edges.\" )","title":"add_out_edges"},{"location":"api_ref_main_page_2/#factorysimpy.nodes.splitter.Splitter.update_state","text":"Update node state and track the time spent in the previous state. Parameters: i ( int ) \u2013 The index of the worker thread to update the state for. new_state ( str ) \u2013 The new state to transition to. Must be one of \"SETUP_STATE\", \"GENERATING_STATE\", \"BLOCKED_STATE\". current_time ( float ) \u2013 The current simulation time. Source code in src/factorysimpy/nodes/splitter.py 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 def update_state ( self , new_state : str , current_time : float ): \"\"\" Update node state and track the time spent in the previous state. Args: i (int): The index of the worker thread to update the state for. new_state (str): The new state to transition to. Must be one of \"SETUP_STATE\", \"GENERATING_STATE\", \"BLOCKED_STATE\". current_time (float): The current simulation time. \"\"\" if self . state is not None and self . stats [ \"last_state_change_time\" ] is not None : elapsed = current_time - self . stats [ \"last_state_change_time\" ] self . stats [ \"total_time_spent_in_states\" ][ self . state ] = ( self . stats [ \"total_time_spent_in_states\" ] . get ( self . state , 0.0 ) + elapsed ) self . state = new_state self . stats [ \"last_state_change_time\" ] = current_time","title":"update_state"},{"location":"api_ref_main_page_2/#factorysimpy.utils","text":"","title":"utils"},{"location":"api_ref_main_page_2/#factorysimpy.utils.stats_summary","text":"","title":"stats_summary"},{"location":"api_ref_main_page_2/#factorysimpy.utils.stats_summary.compute_performance_metrics","text":"Compute cycle time, resource utilization, throughput, and % time spent in each state for each worker. Parameters: stats ( dict ) \u2013 The stats dictionary from the component (key: worker id, value: stats dict). sim_time ( float ) \u2013 The total simulation time. Returns: dict \u2013 A dictionary with metrics for each worker. Source code in src/factorysimpy/utils/stats_summary.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def compute_performance_metrics ( stats , sim_time ): \"\"\" Compute cycle time, resource utilization, throughput, and % time spent in each state for each worker. Args: stats (dict): The stats dictionary from the component (key: worker id, value: stats dict). sim_time (float): The total simulation time. Returns: dict: A dictionary with metrics for each worker. \"\"\" results = {} for worker_id , s in stats . items (): total_time = sum ( s [ \"total_time_spent_in_states\" ] . values ()) # Defensive: If sim_time is 0, avoid division by zero sim_time = max ( sim_time , 1e-8 ) # Utilization: % time in PROCESSING_STATE util = s [ \"total_time_spent_in_states\" ] . get ( \"PROCESSING_STATE\" , 0.0 ) / sim_time # Throughput: items processed per unit time num_processed = s . get ( \"num_item_processed\" , 0 ) + s . get ( \"num_pallet_processed\" , 0 ) throughput = num_processed / sim_time # Cycle time: average time per processed item cycle_time = ( s [ \"total_time_spent_in_states\" ] . get ( \"PROCESSING_STATE\" , 0.0 ) / num_processed ) if num_processed > 0 else None # % time in each state pct_time_states = { state : ( t / sim_time ) * 100 for state , t in s [ \"total_time_spent_in_states\" ] . items ()} # Discarded num_discarded = s . get ( \"num_item_discarded\" , 0 ) + s . get ( \"num_pallet_discarded\" , 0 ) results [ worker_id ] = { \"utilization\" : util , \"throughput\" : throughput , \"cycle_time\" : cycle_time , \"percent_time_in_states\" : pct_time_states , \"num_processed\" : num_processed , \"num_discarded\" : num_discarded , } return results","title":"compute_performance_metrics"},{"location":"api_ref_main_page_2/#factorysimpy.utils.utils","text":"","title":"utils"},{"location":"api_ref_main_page_2/#factorysimpy.utils.utils.get_edge_selector","text":"Returns a generator that yields selected indices from the node's edge list. Args: sel_type ( str ): The selection strategy . One of : ' RANDOM ' , ' ROUND_ROBIN ' . node ( object ): The node object containing in_edges or out_edges . env ( simpy . Environment ): The simulation environment . edge_type ( str , optional ): Whether to select from ' out_edges ' or ' in_edges ' . Default is ' OUT ' . Returns: generator : A generator yielding selected indices from the specified edge list . Raises: ValueError : If sel_type is not a valid selection strategy . Source code in src/factorysimpy/utils/utils.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def get_edge_selector ( sel_type , node , env , edge_type = None ): \"\"\" Returns a generator that yields selected indices from the node's edge list. Args: sel_type (str): The selection strategy. One of: 'RANDOM', 'ROUND_ROBIN'. node (object): The node object containing in_edges or out_edges. env (simpy.Environment): The simulation environment. edge_type (str, optional): Whether to select from 'out_edges' or 'in_edges'. Default is 'OUT'. Returns: generator: A generator yielding selected indices from the specified edge list. Raises: ValueError: If sel_type is not a valid selection strategy. \"\"\" edge_type = edge_type . lower () assert edge_type in [ \"in\" , \"out\" ], \"edge_type must be either 'in' or 'out'.\" strategies = { \"RANDOM\" : Random_edge_selector , \"ROUND_ROBIN\" : RoundRobin_edge_selector , } if sel_type not in strategies : raise ValueError ( f \"Invalid selection type: { sel_type } . Must be one of: { ', ' . join ( strategies . keys ()) } .\" ) #print(edge_type) return strategies [ sel_type ]( node , env , edge_type )","title":"get_edge_selector"},{"location":"authors/","text":"Authors \u00b6 Dr. Neha Karanjkar Assistant Professor, School of Mathematics and Computer Science, Indian Institute of Technology Goa. Webpage: https://nehakaranjkar.github.io/ Lekshmi P. PhD Student, School of Mathematics and Computer Science, Indian Institute of Technology Goa. Webpage: https://lekshmipremkumar.github.io/","title":"Authors"},{"location":"authors/#authors","text":"Dr. Neha Karanjkar Assistant Professor, School of Mathematics and Computer Science, Indian Institute of Technology Goa. Webpage: https://nehakaranjkar.github.io/ Lekshmi P. PhD Student, School of Mathematics and Computer Science, Indian Institute of Technology Goa. Webpage: https://lekshmipremkumar.github.io/","title":"Authors"},{"location":"basic_components/","text":"Basic Components \u00b6 Node, Edge and BaseFlowItem are the 3 basic component types in the library. All the other components are derived from them. Nodes are the active, static elements in the system and are responsible for operations such as processing, splitting, or combining items. Every node maintains a list of in_edges and out_edges , which are references to edge objects that connect it to other nodes. Other parameters of Nodes are id (a unique name) and node_setup_time (initial delay in each node, which is be a constant value). Common node types include Machine, Split, Combiner, Source, and Sink. Source can be used to generate items that flow in the system. Machines are the entities that modifies/processes an item. To multiplex the items that flow in the system, Splits can be used and to pack/join items from different input edges a Combiner can be used. Sink is the terminal node in the system and the items that enter this node cannot be retrieved. Edges are passive components that connect exactly two nodes (src_node and dest_node) and helps in transfering items between them. Edges are directed. Each edge has a unique identifier called id , and parameters src_node and dest_node to store the reference to the source node and destination node. Specific types of edges include Buffer, Conveyor, and Fleet. Buffers act as queues with a defined delay. Conveyors move items between nodes while preserving order and support both discrete (slotted belts) and continuous motion. Fleets represent systems like warehouse robots or human operators that transport items between nodes without preserving order. BaseFlowItem represents the entities that flow in the system. Every baseflowitem has a unique id . There are mainly two two of flow items available specified as flow_item_type . It can be either item or a pallet. Item is the smallest unit of discrete items that flow in the system. Pallets represents enitities that can hold multiple base items that belong to flow_item_type - \"items\". Rules for interconnection Node represent static entities that are active. Components like machine, source, sink, split, combiners, etc are derived from node. Edge is directed and connects one node to another. Conveyor, buffer and fleet are the entities that are of type Edge. Items are discrete parts that flow in the system through the directed edges from one node to another. Each node has two lists in_edges and out_edges that points to a list with references of the edges that comes in and go out of the node. Each edge stores pointers to a src_node and a dest_node . An edge can be used only to connect a node to another node or same node. An edge can have the same node in both src_node and dest_node . Self loops are allowed. Nodes are the active elements whose activites initiates state changes in the system. Edges are the passive elements and state change occurs due to actions initiated by nodes. To multiplex the output from a machine node into multiple streams, a splittermust be connected to the machine using an edge. To join multiple streams and to feed as input to a machine , a Combiner must be connected to the machine using an edge. Steps for Connecting Components Instantiate nodes and edges: n1 = Source () n2 = Machine () n3 = Sink () e1 = Buffer () e2 = Buffer () Establish connections: e1 . connect ( n1 , n2 ) e2 . connect ( n2 , n3 ) Nodes \u00b6 Nodes represent active elements in the system. This is a basic type and is the basis for the active components like Machine, Split, Sink, Source, Combiner, etc. Every node has a unique identifier named id and maintains two lists named in_edges and out_edges . Every node has a node_setup_time that can be specified as a constant delay (integer of float). Activities that takesplace in a node create state changes in the system. The API documentation can be found in Node . Basic attributes id - unique identifier of the node in_edges - list of all the input edges to the node out_edges - list of all the output edges from the node node_setup_time - an initial delay to set up the node. Source \u00b6 About The source is an active component that generates items that flow through the system. There are two modes of operation for the source. If the parameter blocking is set to True, the source generates an item and tries to send it to the connected output edge. If the edge is full or cannot accept the item, the source waits until space becomes available. If the blocking parameter is set to False, the source generates items and attempts to send them to the output edge. If the edge is full or cannot accept the item, the source discards the item. The API documentation can be found in Source . Basic attributes state - Current state of the component. inter_arrival_time - Time interval between two successive item generation. flow_item_type - This is the type of item the source should generate. Either \"item\" or \"pallet\". blocking - If True, waits for output edge to be available to accept item and pushes the item when it is available; if False, discards the item if the output edge if full. out_edge_selection - Edge selection policy as a function to select output edge. Behavior At the start of the simulation, the source waits for node_setup_time . This is an initial, one-time wait time for setting up the node and should be provided as a constant (an int or float ). During a simulation run, the source generates items at discrete instants of time determined by the parameter inter_arrival_time . Details on how to configure parameter inter_arrival_time can be found here . After the wait it produces a flow item based on the type mentioned in flow_item_type . It can be of two types namely \"item\" and \"pallet\". Item represents the smallest unit of discrete items that flow in the system. Pallets represents the type of flow item that can hold multiple items inside and it can be used to pack items. The source can have multiple output edges. It then chooses an output edge from out_edges list based on the out_edge_selection parameter. More details on how to configure parameter out_edge_selection can be found here . After generating an item and choosing an output edge, the source behaves as follows: If blocking is True , it waits with the processed item in a \"BLOCKED_STATE\" for the out edge to be available and pushes the item when output edge becomes available or has space. If blocking is False , it checks if there is space in the output edge to accomodate the item. If the edge is full or unavailable, the item is discarded and the count of discarded item is recorded. States During its operation, the source transitions through the following states: \"SETUP_STATE\": Initialization or node setup phase before item generation starts. \"GENERATING_STATE\": Active state where items are being created and pushed to the output edge. \"BLOCKED_STATE\": The source is blocked, waiting for the output edge to be available to accept an item (only when blocking is True ). Usage Source can be initialised as shown below. import factorysimpy from factorysimpy.nodes.source import Source SRC = Source ( env , # Simulation environment id = \"SRC2\" , # Unique identifier for the source node inter_arrival_time = 0.4 , # Time between item generations (can be constant or function/generator) flow_item_type = \"item\" , # Type of baseflowitem that the source should generate blocking = False , # If True, waits for output edge to accept item; if False, discards item if the output edge is full out_edge_selection = 0 # Strategy or function to select output edge (can be string or callable or genrator or a constant int) ) Statistics collected Several key metrics are being monitored in the class can be accessed in the attribute stats as component.stats[ num_item_generated ]. The source component reports the following key metrics. Total number of items generated Number of items discarded (non-blocking mode) Time spent in each state Consider a source with blocking = False and instance name as SRC. Metrics of a component SRC can be accessed after completion of the simulation run as print ( f \"Total number of items generated by { SRC . id } = { SRC . stats [ \"num_items_processed\" ] } \" ) print ( f \"Total number of items discarded by { SRC . id } = { SRC . stats [ \"num_items_discarded\" ] } \" ) print ( f \"Source { SRC . id } , state times: { SRC . stats [ \"time_spent_in_states\" ] } \" ) Examples A simple example with all parameters passed as constants An example with inter_arrival_delay passed as a normal python function An example with inter_arrival_delay passed as a normal python generator function instance An example with out_edge_selection parameter is passed as custom function that yields edge indices Machine \u00b6 About A machine is an active component that processes items flowing through the system. Each item incurs a processing_delay amount of time to get processed in the machine. A machine can have multiple in_edges and out_edges . A machine can process multiple items simultaneously. The parameter work_capacity indicates the maximum number of items that can be processed simulatanously inside the machine. If work_capacity is set to a number greater than 1 (for example, k), this represents a machine with a maximum of k worker processes that are capable of processing k items simultaneously. Machine has two modes of operation based on the parameter value specified in blocking . If it is set to True , the processed item is held in a blocked state and machine waits for the out edge to be available to accept the item and pushes the processed item to the chosen out edge once it is available. The other mode can be configured by setting blocking to False . In this mode , the machine checks if there is space available in the chosen output edge and only if there is space the item is pushed. If the output edge is unavailable or full, the item will be discarded and its count will be recorded. The API documentation can be found in Machine . Basic attributes work_capacity - Maximum number of items that can be processed by the machine simulataneously. processing_delay - Time taken to process an item. state_rep - This is a 2-tuple where the entries are the number of threads in the processing state and in the blocked state respectively e.g., (num_processing_threads, num_blocked_threads). The number of threads in the IDLE_STATE can be determined by subtracting the sum of num_processing_threads and num_blocked_threads from the total work_capacity (work_capacity - (num_processing_threads + num_blocked_threads)). Inaddition to these, there is a \"SETUP_STATE\" for the machine and is denoted as (-1,-1). \"IDLE_STATE\" is when all the threads are idle and is represented as (0,0). blocking - If True, waits for output edge to be available to accept item and pushes the item when it is available; if False, discards the item if the output edge is full. in_edge_selection - Edge selection policy as a function to select input edge. out_edge_selection - Edge selection policy as a function to select output edge. Behavior At the start of the simulation, the machine waits for node_setup_time . This is an initial, one-time wait time for setting up the node and should be provided as a constant (an int or float ). Machine can process atmost work_capacity number of items in parallel. As soon as an item is input from one of its input edges based on in_edge_selection , a worker thread is reserved which remains busy for processing the item in processing_delay amount of time and at the end of this time the worker thread attempts to output the item to one of the out_edges selected using the out_edge_selection parameter. More details on how to configure the parameters processing_delay , out_edge_selection and in_edge_selection can be found here . Multiple items can be in \"PROCESSING_STATE\" at a time. After processing the item, the worker thread behaves as follows: If blocking is True , it waits with the processed item in a \"BLOCKED_STATE\" for the out edge to be available and pushes the item when output edge becomes available or has space. If blocking is False , it checks if there is space in the output edge to accomodate the item. If the edge is full or unavailable, the item is discarded and the count of discarded item is recorded. States During its operation, a machine transitions between different states based on the status of its worker threads. Each worker thread moves through the following thread level states: IDLE_STATE : All the threads are idle. PROCESSING_STATE : The thread is actively processing an item. BLOCKED_STATE : The thread has finished processing but is waiting for an available output edge to transfer the item. The machine reports the following statistics for the various states a machine transitions through during simulation based on the collective status of the states of its threads. total_time_setup (S): Time spent in the initialization or warming up phase before item processing starts. Denoted as (-1,-1) in state_rep. total_time_idle (I): Time duration for which the machine doesnot have any worker thread that is currently getting processed or is blocked. total_time_atleast_one_processing (1P): Time duration for which the machine is actively processing items. There will be atleast one thread in processing state in the machine. total_time_all_blocked (AB): Time duration for which all the worker_threads that are currently active are in \"BOCKED_STATE\" as they are waiting for the out edge to be available to accept the processed item. The number of active threads can be equal to less than work_capacity. ie, there will >=1 threads in blocked state, >=0 threads in idle state and no threads in processing state. total_time_all_active_processing (AP): Time duration for which all the active threads are in processing state. The number of active threads can be equal to less than work_capacity. ie, there will >=1 threads in processing state, >=0 threads in idle state and no threads in blocked state. total_time_atleast_one_blocked (1B): Time duration for which atleast one of the worker_threads is in \"BOCKED_STATE\" as it is waiting for the out edge to be available to accept the processed item. Some of the reported statistics are not mutually exclusive and may occur simultaneously. However, the following groupings are mutually exclusive and collectively exhaustive, meaning they cover all possible scenarios without overlap within each group: Group A: {S + I + 1P + AB} = total simulation time Group B: {S + I + AP + 1B} = total simulation time Each group individually spans 100% of the simulation time. State Diagram State_rep - (N_P, N_B); (Number of threads in processing state, number of threads in blocked state) Number of threads in idle state, N_I = work_capacity - (N_P + N_B) stateDiagram direction TB [*] --> Idle : No jobs and all threads idle Idle --> Processing:Input job Processing --> Blocked:Output blocked Processing --> Idle:Job finished Blocked --> Idle:Output succeeded Usage A machine can be initialised as below. import factorysimpy from factorysimpy.nodes.machine import Machine MACHINE1 = Machine ( env , # Simulation environment id = \"MACHINE1\" , # Unique identifier for the machine node work_capacity = 4 , # Max number of items that can be processed simultaneously processing_delay = 1.2 , # Processing delay (constant or generator/function) blocking = False , # If True, waits for output edge to accept item; if False, discards item if the output edge is full in_edge_selection = \"RANDOM\" , # Policy or function to select input edge out_edge_selection = \"RANDOM\" # Policy or function to select output edge ) Statistics collected The machine component reports the following key metrics. Total number of items processed total time in PROCESSING_STATE (per thread) Total time spent in BLOCKED_STATE (per thread) Occupancy of the worker threads Total time spent in each of the machine level states Total number if items discarded (when blocking = False) Consider a machine with work_capacity = 2 , blocking = False and and instance name as MACHINE1. Metrics of a component MACHINE1 can be accessed after completion of the simulation run as print ( f \"Total number of items processed by { MACHINE1 . id } = { MACHINE1 . stats [ \"num_items_processed\" ] } \" ) print ( f \"Total number of items discarded by { MACHINE1 . id } = { MACHINE1 . stats [ \"num_items_discarded\" ] } \" ) print ( f \"Machine { MACHINE1 . id } ,total time in BLOCKED_STATE (per thread) : { MACHINE1 . per_thread_total_time_in_blocked_state } \" ) print ( f \"Machine { MACHINE1 . id } ,total time in PROCESSING_STATE (per thread) : { MACHINE1 . per_thread_total_time_in_processing_state } \" ) print ( f \"Worker occupancy: (Indices represent the number of active threads, and values represent the total time during which that many threads were active simultaneously) \\n { MACHINE1 . time_per_work_occupancy } \" ) # Compute mutually exclusive sums groupA_states = [ \"total_time_setup\" , \"total_time_idle\" , \"total_time_atleast_one_processing\" , \"total_time_all_active_blocked\" ] groupB_states = [ \"total_time_setup\" , \"total_time_idle\" , \"total_time_all_active_processing\" , \"total_time_atleast_one_blocked\" ] sum_groupA = sum ( getattr ( MACHINE1 , s ) for s in groupA_states ) sum_groupB = sum ( getattr ( MACHINE1 , s ) for s in groupB_states ) print ( \" \\n Mutually exclusive group totals:\" ) print ( f \" Group A (S+I+1P+AB): { sum_groupA : .2f } \" ) print ( f \" Group B (S+I+AP+1B): { sum_groupB : .2f } \" ) Examples A simple example with all parameters passed as constants Example with processing_delay passed as function that generates random variates from a chosen distribution Example with processing_delay passed as a generator function instance An example with out_edge_selection and in_edge_selection parameter is passed as custom function that yields edge indices Combiner \u00b6 About The Combiner component represents a node that combines or packs items from multiple input edges into a single pallet or box, and then pushes the packed pallet to an output edge. It is useful for modeling operations such as packing, assembly, or combining items from different sources. The number of items to be taken from each input edge can be specified, and the first input edge is expected to provide the pallet or container. A Combiner can process only one pallet at a time. The API documentation can be found in Combiner . Basic attributes state - current state of the component. This is a dictionary where each key is a worker thread's ID (assigned in order of initialization), and the value is the current state of that worker. processing_delay - time taken to process and pack the items blocking - if True, waits for output edge to accept the packed pallet; if False, discards the pallet if the output edge is full target_quantity_of_each_item - list specifying how many items to take from each input edge (first entry is always 1 for the pallet) out_edge_selection - edge selection policy as a function to select output edge Behavior At the start of the simulation, the Combiner waits for node_setup_time . This is an initial, one-time wait time for setting up the node and should be provided as a constant (an int or float ). Then it spawns work_capacity number of threads. The process then repeatedly: Pulls a pallet from the first input edge. Pulls the specified number of items from each of the other input edges and adds them to the pallet. Waits for processing_delay to simulate packing/combining. Pushes the packed pallet to the output edge, either waiting if blocking is True or discarding if the edge is full and blocking is False. To select an output edge, to push the item to, worker thread uses the method specified in out_edge_selection parameter. User can also provide a custom python function or a generator function instance to these parameters. User-provided function should return or yield an edge index. If the function depends on any of the node attributes, users can pass None to these parameters at the time of node creation and later initialise the parameter with the reference to the function. This is illustrated in the examples shown below. Various options available in the package for out_edge_selection include: \"RANDOM\": Selects a random out edge. \"ROUND_ROBIN\": Selects out edges in a round-robin manner. \"FIRST_AVAILABLE\": Selects the first out edge that can accept an item. States During its operation, the Combiner transitions through the following states: \"SETUP_STATE\": Initialization or warm-up phase before packing starts. \"IDLE_STATE\": Waiting to receive a pallet and items. \"PROCESSING_STATE\": Actively packing items into the pallet. \"BLOCKED_STATE\": Blocked, waiting for the output edge to accept the packed pallet. Usage A Combiner can be initialized as below: import factorysimpy from factorysimpy.nodes.combiner import Combiner COMBINER1 = Combiner ( env , # Simulation environment id = \"COMBINER1\" , # Unique identifier for the Combiner node target_quantity_of_each_item = [ 1 , 2 ], # 1 pallet from in_edges[0], 2 items from in_edges[1] processing_delay = 1.5 , # Packing delay (constant or generator/function) blocking = True , # Wait for output edge to accept pallet out_edge_selection = \"RANDOM\" # Policy or function to select output edge ) Statistics collected The Combiner component reports the following key metrics: Total number of pallets packed and pushed Number of pallets/items discarded (non-blocking mode) Time spent in each state After the simulation run, metrics can be accessed as: print ( f \"Total number of pallets processed by worker 1 of { COMBINER1 . id } = { COMBINER1 . stats [ 1 ][ 'num_item_processed' ] } \" ) print ( f \"Total number of pallets discarded by worker 1 of { COMBINER1 . id } = { COMBINER1 . stats [ 1 ][ 'num_item_discarded' ] } \" ) print ( f \"Combiner { COMBINER1 . id } , worker1 state times: { COMBINER1 . stats [ 1 ][ 'total_time_spent_in_states' ] } \" ) Examples An example of a Combiner node combining items from two sources Splitter \u00b6 About The Splitter component represents a node that unpacks or splits an input item (such as a pallet or batch) and sends its contents to multiple output edges. It is useful for modeling operations such as unpacking. A Splitter can process more only one pallet at a time. The input edge is selected according to the in_edge_selection policy, and the output edge for each unpacked item is selected according to the out_edge_selection policy. The API documentation can be found in Splitter . Basic attributes state - current state of the component. This is a dictionary where each key is a worker thread's ID (assigned in order of initialization), and the value is the current state of that worker. processing_delay - time taken to process and unpack the items blocking - if True, waits for output edge to accept the item; if False, discards the items if the output edge is full mode - mode of operation of the splitter. Either \"UNPACK\" or \"SPLIT\". split_quantity - Target quantity of items to split the input flow item into. in_edge_selection - edge selection policy as a function to select input edge out_edge_selection - edge selection policy as a function to select output edge Behavior At the start of the simulation, the splitter waits for node_setup_time . it repeatedly: Pulls a packed item (e.g., pallet) from the selected input edge. Waits for processing_delay to simulate unpacking or splitting. If the Splitter mode is \"UNPACK\", then it unpacks the items from the pallet and pushes each item to an output edge, one by one, using the out_edge_selection policy. After all items are pushed, the empty container itself is pushed to an output edge. If the Splitter mode is \"SPLIT\", then it splits the items into a target quanitity of items, specified by split_quantity and pushes each item to an output edge, one by one, using the out_edge_selection policy. If blocking is True, the splitter waits for the output edge to accept each item; if blocking is False, items are discarded if the output edge is full. To select an output edge and input edge, worker thread uses the method specified in out_edge_selection and in_edge_selection parameters. User can also provide a custom python function or a generator function instance to these parameters. User-provided function should return or yield an edge index. If the function depends on any of the node attributes, users can pass None to these parameters at the time of node creation and later initialise the parameter with the reference to the function. This is illustrated in the examples shown below. Various options available in the package for in_edge_selection and out_edge_selection include: \"RANDOM\": Selects a random out edge. \"ROUND_ROBIN\": Selects out edges in a round-robin manner. \"FIRST_AVAILABLE\": Selects the first out edge that can accept an item. States During its operation, the splitter transitions through the following states: \"SETUP_STATE\": Initialization or warm-up phase before unpacking starts. \"IDLE_STATE\": Waiting to receive a container/item. \"PROCESSING_STATE\": Actively unpacking or splitting items. \"BLOCKED_STATE\": Blocked, waiting for the output edge to accept the item. Usage A splitter can be initialized as below: import factorysimpy from factorysimpy.nodes.splitter import Splitter SPLITTER11 = Split ( env , # Simulation environment id = \"SPLITTER11\" , # Unique identifier for the splitternode processing_delay = 1.0 , # Unpacking delay (constant or generator/function) blocking = True , # Wait for output edge to accept item mode = \"UNPACK\" , # mode can be UNPACK or SPLIT split_quantity = None , # To be used is mode is SPLIT in_edge_selection = \"RANDOM\" , # Policy or function to select input edge out_edge_selection = \"ROUND_ROBIN\" # Policy or function to select output edge ) Statistics collected The splittercomponent reports the following key metrics: Total number of items unpacked and pushed Number of items discarded (non-blocking mode) Time spent in each state After the simulation run, metrics can be accessed as: print ( f \"Total number of items processed by worker 1 of { SPLITTER11 . id } = { SPLITTER11 . stats [ 1 ][ 'num_item_processed' ] } \" ) print ( f \"Total number of items discarded by worker 1 of { SPLITTER11 . id } = { SPLITTER11 . stats [ 1 ][ 'num_item_discarded' ] } \" ) print ( f \"splitter { SPLITTER11 . id } , worker1 state times: { SPLITTER11 . stats [ 1 ][ 'total_time_spent_in_states' ] } \" ) Examples An example of a splitternode unpacking a pallet and distributing items to multiple destinations Sink \u00b6 A Sink is a terminal node that collects flow items at the end. Once an item enters the sink, it is considered to have exited the system and cannot be retrieved or processed further. The sink can have multiple input edges but no output edges. More details on how to configure the parameter out_edge_selection can be found here . It only has a single state \"COLLECTING_STATE\". The API documentation can be found in Sink . Behavior During a simulation run, sink waits for an item to be available at one of its input edges and accepts that item, records the statistics and destructs that item. Usage A splittercan be initialized as below: import factorysimpy from factorysimpy.nodes.sink import Sink SINK = SINK ( env , # Simulation environment id = \"SINK\" , # Unique identifier for the node ) Statistics collected The sink component reports the following key metrics. Total number of items received sum of cycle times of all items received by the sink Consider a sink with instance name as SINK. Its metrics can be accessed after completion of the simulation run as total = SINK . stats [ \"num_item_received\" ] cycle_time = SINK . stats [ \"total_cycle_time\" ] / 60 print ( f \"Average cycle time per item: { cycle_time / total if total > 0 else 0 : .2f } minutes\" ) print ( f \"Total number of items received: { sink . stats } \" ) Edges \u00b6 Edges represent passive elements in the system. This is the basis for the components like Buffer, Conveyor, Fleet, etc. Every edge has a unique identifier named id and maintains references to a source node src_node and a destination node dest_node . There can only be one source node and one destination node for an edge. Edge acts as a conntction between these two nodes and facilitates the movement of items between the nodes. Buffer \u00b6 About The Buffer component represents a queue (FIFO or LIFO) that temporarily holds items between nodes in the system. It acts as an edge with internal storage, allowing items to be stored until the destination node is ready to accept them. Items placed in the buffer become available for retrieval after a specified delay . The buffer can operate in two modes: - FIFO (First In First Out): Oldest items are released first. - LIFO (Last In First Out): Newest items are released first. The API documentation can be found in Buffer . Basic attributes state - current state of the buffer capacity - maximum number of items the buffer can hold mode - mode of operation of the buffer. Either \"FIFO\" or \"LIFO\". delay - time after which an item becomes available for retrieval (can be a constant, generator, or callable) Behavior When an item is put into the buffer, it is stored internally and becomes available for retrieval after the specified delay . The buffer has methods to check if it can accept new items using can_put method and if it can provide items to the next node using can_get method. In FIFO mode, items are released in the order they were added; in LIFO mode, the most recently added items are released first. Incoming edges can use reserve_get and reserve_put calls on the store in the buffer to reserve an item or space and after yielding the requests, an item can be put and obtained by using put and get methods. Buffer has methods to list all the items in the buffer( items() ), to list only the ready items in the buffer( ready_items() ) and to return the number of items in the buffer ( occupancy() ). States The buffer transitions between states such as \"IDLE_STATE\" (waiting for items), \"RELEASING_STATE\" (releasing items), and \"BLOCKED_STATE\" (cannot accept or release items due to capacity or downstream constraints). \"EMPTY_STATE\" - when there is no items in the buffer \"RELEASING_STATE\"- When there is items in the buffer that are ready to be taken out. Usage A buffer can be initialized as below: import factorysimpy from factorysimpy.edges.buffer import Buffer BUF1 = Buffer ( env , # Simulation environment id = \"BUF1\" , # Unique identifier for the buffer capacity = 10 , # Maximum number of items in the buffer delay = 2.0 , # Delay before items become available (can be int, float, generator, or callable) mode = \"FIFO\" # \"FIFO\" or \"LIFO\" ) Statistics collected The buffer component reports the following key metrics: Time when the state was last changed ( last_state_change_time ) Time-averaged number of items in the buffer ( time_averaged_num_of_items_in_buffer ) Total time spent in each state ( total_time_spent_in_states ) After the simulation run, metrics can be accessed as: print ( f \"Buffer { BUF1 . id } last state change: { BUF1 . stats [ 'last_state_change_time' ] } \" ) print ( f \"Buffer { BUF1 . id } time-averaged number of items: { BUF1 . stats [ 'time_averaged_num_of_items_in_buffer' ] } \" ) print ( f \"Buffer { BUF1 . id } state times: { BUF1 . stats [ 'total_time_spent_in_states' ] } \" ) Examples A simple example with a FIFO buffer between a source and a machine Fleet \u00b6 About The fleet component represents an AGV that moves multiple items simultaneously between nodes in the system. It acts as an edge. The fleet is activated when either of two conditions is met: Capacity condition \u2013 the number of stored items reaches capacity. Delay condition \u2013 the specified delay time elapses after the first item arrives, even if capacity is not met. When activated, the fleet incurs transit_delay amount of time and makes its stored items available to the destination node. The API documentation can be found in Fleet . Basic attributes state - current state of the fleet capacity - target quantity of items after which the fleet will be activated delay - Maximum waiting time before the fleet is triggered. (can be a constant, generator, or callable) transit_delay - transit_delay (int, float): It is the time taken by the fleet to transport the item from src node to destination node. (can be a constant, generator, or callable) Behavior When an item is put into the fleet, it is stored internally and becomes available for retrieval after the specified delay or after a target quantity ( capacity ) of items is available in fleet. Once triggered the items will be available for the destination node. Fleet will incur transit_delay amount of time to travel to the src_node from dest_node and takes the object and incurs transit_delay time again and transfer the item to the dest_node from src_node. The fleet has methods to check if it can accept new items using can_put method and if it can provide items to the next node using can_get method. Incoming edges can use reserve_get and reserve_put calls on the store in the fleet to reserve an item or space and after yielding the requests, an item can be put and obtained by using put and get methods. States The fleet transitions between states such as \"IDLE_STATE\" (waiting for items), \"RELEASING_STATE\" (releasing items), and \"BLOCKED_STATE\" (cannot accept or release items due to capacity or downstream constraints). \"EMPTY_STATE\" - when there is no items in the fleet \"RELEASING_STATE\"- When there is items in the fleet Usage A fleet can be initialized as below: import factorysimpy from factorysimpy.edges.fleet import Fleet FLEET1 = Fleet ( env , # Simulation environment id = \"FLEET1\" , # Unique identifier for the fleet capacity = 10 , # target capacity of items required to activate the fleet delay = 2.0 , # Delay after which fleet activates the movement of items incase the target capacity is not reached. (can be int, float, generator, or callable) transit_delay = 0 # time to move the items from one node to another ) Statistics collected The fleet component reports the following key metrics: Time when the state was last changed ( last_state_change_time ) Time-averaged number of items in the fleet ( time_averaged_num_of_items_in_fleet ) Total time spent in each state ( total_time_spent_in_states ) After the simulation run, metrics can be accessed as: print ( f \"fleet { FLEET1 . id } last state change: { FLEET1 . stats [ 'last_state_change_time' ] } \" ) print ( f \"fleet { FLEET1 . id } time-averaged number of items: { FLEET1 . stats [ 'time_averaged_num_of_items_in_fleet' ] } \" ) print ( f \"Fleet { FLEET1 . id } state times: { FLEET1 . stats [ 'total_time_spent_in_states' ] } \" ) Examples A simple example with a fleet between a source and a machine Conveyor \u00b6 Conveyor connects two nodes and facilitates the movement of items between them. It introduces a transport delay between nodes and acts as a passive element. There are two variants of conveyor available in this package: Continuous-type Conveyor \u00b6 This variant models a conveyor belt where items can be placed onto the belt at any time. Each item requires a fixed transport time to reach its destination. The conveyor is designed for discrete items only and has a limited carrying capacity, i.e., it can hold only a fixed number of items simultaneously. Basic attributes state - current state of the conveyor conveyor_length - Length of the belt item_length - Length of the item. speed - speed of the conveyor belt (can be a constant) accumulating - Whether the belt supports accumulation (1 for yes, 0 for no) Behavior During a simulation run, a Conveyor that is initially empty begins operation as soon as it receives its first item. Each item requires a fixed transport time to reach the opposite end of the belt. The time delay to transport an item on the conveyor is calculated as conveyor_length / conveyor_speed. A new item can be added only after item_length/ conveyor_speed amount of time is incurred after the last item is put on the belt. The conveyor continues moving until the leading item reaches the destination node (dest_node). If the destination node does not accept the item, the conveyor enters a STALLED state. An accumulating conveyor can continue to accept new items while stalled, provided there is remaining capacity. A non-accumulating conveyor cannot accept new items while stalled. During its operation, the conveyor transitions through the following states: \"SETUP_STATE\": Initialization or warm-up phase. \"MOVING_STATE\": state when the belt is moving. \"STALLED_ACCUMULATING_STATE\": a belt (configured to be accumulating) becomes stalled when it has an item that is ready to be taken by the destination node. \"STALLED_NONACCUMULATING_STATE: a belt (configured to be non-accumulating) becomes stalled when it has an item that is ready to be taken by the destination node. Conveyors can be either accumulating or non-accumulating : A non-accumulating type conveyor will not allow src_node to push items into the conveyor if it is in a stalled state A accumulating conveyor allows src_node to push items until its capacity is reached when when it is in stalled state. Usage A continuous-type can be initialized as below: import factorysimpy from factorysimpy.edges.continuous_conveyor import ConveyorBelt CONVEYORBELT1 = ConveyorBelt ( env , # Simulation environment id = \"CONVEYORBELT1\" , # Unique identifier for the fleet conveyor_length = 5 , # Capacity of the conveyor speed = 1 , # Speed of the conveyor item_length = 1 , # Length of the item accumulating = True # If the conveyor is in Accumulating mode or not ) Monitoring and Reporting The component reports the following key metrics: Time averaged number of items Examples A simple example with a continuous-type conveyor belt Slotted-type Conveyor \u00b6 This variant moves items from one end to the other at fixed time intervals, simulating a belt with predefined slots. Its behavior is governed by teo key parameters- a constant delay between two successive movements and capacity that defines the number of slots available on the conveyor. It can hold only up to capacity number of items at a time. Basic attributes state - current state of the conveyor capacity - Maximum number of items that can be carried simultaneously delay - time interval between two successive movements on the belt (can be a constant, generator, or callable) accumulating - Whether the belt supports accumulation (1 for yes, 0 for no) Behavior During a simulation run, the conveyor remains idle until it receives the first item. At that point, it transitions into MOVING_STATE and begins advancing items at fixed intervals defined by delay. Each advancement shifts all items one slot closer to the destination end. The conveyor continues moving until the leading item reaches the destination node. The conveyor continues moving until the leading item reaches the destination node (dest_node). If the destination node does not accept the item, the conveyor enters a STALLED state. An accumulating conveyor can continue to accept new items while stalled, provided there is remaining capacity. A non-accumulating conveyor cannot accept new items while stalled. During its operation, the conveyor transitions through the following states: \"SETUP_STATE\": Initialization or warm-up phase. \"MOVING_STATE\": state when the belt is moving. \"STALLED_ACCUMULATING_STATE\": a belt (configured to be accumulating) becomes stalled when it has an item that is ready to be taken by the destination node. \"STALLED_NONACCUMULATING_STATE: a belt (configured to be non-accumulating) becomes stalled when it has an item that is ready to be taken by the destination node. It will not allow any item to be pushed onto belt while in this state. Usage A continuous-type can be initialized as below: import factorysimpy from factorysimpy.edges.slotted_conveyor import ConveyorBelt CONVEYORBELT1 = ConveyorBelt ( env , # Simulation environment id = \"CONVEYORBELT1\" , # Unique identifier for the fleet capacity = 5 , # Capacity of the conveyor delay = 1 , # Time interval between two successive movements of the belt accumulating = True # If the conveyor is in Accumulating mode or not ) Monitoring and Reporting The component reports the following key metrics: Time averaged number of items Examples A simple example with a slotted-type conveyor belt BaseFlowItem \u00b6 This is base class for the items that flow in the system. Basic attributes id - Unique identifier for the pallet. timestamp_creation - Time when the pallet was created. timestamp_destruction - Time when the pallet was destroyed (e.g., collected by a sink). timestamp_node_entry - Time when the pallet entered the current node. timestamp_node_exit - Time when the pallet exited the current node. current_node_id - The ID of the node the pallet is currently in. source_id - The ID of the source node that created the pallet. payload - Optional data carried by the pallet. destructed_in_node - The node where the pallet was destroyed. Item \u00b6 About The Item class represents the discrete entities that flow through the system. Each item is created by a source node and is then processed, transferred, or collected by various nodes and edges as it moves through the simulation. The Item object tracks its movement, including timestamps for creation, entry and exit at each node, and destruction, as well as the time spent at each node. Basic attributes flow_item_type - \"item\" type of the base flow item Behavior When an item is created, its creation time and source node are recorded. As the item enters and exits nodes, the update_node_event method updates entry/exit times and accumulates the time spent at each node in the stats dictionary. When the item is destroyed (e.g., collected by a sink), the destruction time and node are recorded. Statistics collected The Item class tracks: Creation and destruction times. The node where the item was created and destroyed. Time spent at each node (accessible via the stats dictionary). Consider that an item is created inside a source and it has finished its flow in the system. The statistics can be collected as f0llows item1 = Item ( id = \"item1\" ) for key , value in item1 . stats : print ( \"Time spent in node {key.id} is {value} \" ) Pallet \u00b6 About The Pallet class represents a special type of item that can hold multiple other items. It is used to model containers, pallets, or boxes that group several items together for combined processing, transport, or packing/unpacking operations in the system. The Pallet object tracks its own journey through the system, just like a regular Item , and also maintains a list of the items it contains. Basic attributes flow_item_type - \"Pallet\" type of the base flow item items - List of items currently held in the pallet. Behavior When a pallet is created, its creation time and source node are recorded. Items can be added to the pallet using the add_item(item) method. Items can be removed from the pallet using the remove_item() method, which returns an item or None if the pallet is empty. As the pallet enters and exits nodes, the update_node_event method updates entry/exit times and accumulates the time spent at each node in the stats dictionary. When the pallet is destroyed (e.g., collected by a sink), the destruction time and node are recorded. Statistics collected The Pallet class tracks: Creation and destruction times. The node where the pallet was created and destroyed. Time spent at each node (accessible via the stats dictionary). The number of items currently held in the pallet. Consider that an pallet is created inside a source and it has finished its flow in the system. The statistics can be collected as f0llows pallet1 = Pallet ( id = \"pallet1\" ) for key , value in pallet1 . stats : print ( \"Time spent in node {key.id} is {value} \" )","title":"Basic Components"},{"location":"basic_components/#basic-components","text":"Node, Edge and BaseFlowItem are the 3 basic component types in the library. All the other components are derived from them. Nodes are the active, static elements in the system and are responsible for operations such as processing, splitting, or combining items. Every node maintains a list of in_edges and out_edges , which are references to edge objects that connect it to other nodes. Other parameters of Nodes are id (a unique name) and node_setup_time (initial delay in each node, which is be a constant value). Common node types include Machine, Split, Combiner, Source, and Sink. Source can be used to generate items that flow in the system. Machines are the entities that modifies/processes an item. To multiplex the items that flow in the system, Splits can be used and to pack/join items from different input edges a Combiner can be used. Sink is the terminal node in the system and the items that enter this node cannot be retrieved. Edges are passive components that connect exactly two nodes (src_node and dest_node) and helps in transfering items between them. Edges are directed. Each edge has a unique identifier called id , and parameters src_node and dest_node to store the reference to the source node and destination node. Specific types of edges include Buffer, Conveyor, and Fleet. Buffers act as queues with a defined delay. Conveyors move items between nodes while preserving order and support both discrete (slotted belts) and continuous motion. Fleets represent systems like warehouse robots or human operators that transport items between nodes without preserving order. BaseFlowItem represents the entities that flow in the system. Every baseflowitem has a unique id . There are mainly two two of flow items available specified as flow_item_type . It can be either item or a pallet. Item is the smallest unit of discrete items that flow in the system. Pallets represents enitities that can hold multiple base items that belong to flow_item_type - \"items\". Rules for interconnection Node represent static entities that are active. Components like machine, source, sink, split, combiners, etc are derived from node. Edge is directed and connects one node to another. Conveyor, buffer and fleet are the entities that are of type Edge. Items are discrete parts that flow in the system through the directed edges from one node to another. Each node has two lists in_edges and out_edges that points to a list with references of the edges that comes in and go out of the node. Each edge stores pointers to a src_node and a dest_node . An edge can be used only to connect a node to another node or same node. An edge can have the same node in both src_node and dest_node . Self loops are allowed. Nodes are the active elements whose activites initiates state changes in the system. Edges are the passive elements and state change occurs due to actions initiated by nodes. To multiplex the output from a machine node into multiple streams, a splittermust be connected to the machine using an edge. To join multiple streams and to feed as input to a machine , a Combiner must be connected to the machine using an edge. Steps for Connecting Components Instantiate nodes and edges: n1 = Source () n2 = Machine () n3 = Sink () e1 = Buffer () e2 = Buffer () Establish connections: e1 . connect ( n1 , n2 ) e2 . connect ( n2 , n3 )","title":"Basic Components"},{"location":"basic_components/#nodes","text":"Nodes represent active elements in the system. This is a basic type and is the basis for the active components like Machine, Split, Sink, Source, Combiner, etc. Every node has a unique identifier named id and maintains two lists named in_edges and out_edges . Every node has a node_setup_time that can be specified as a constant delay (integer of float). Activities that takesplace in a node create state changes in the system. The API documentation can be found in Node . Basic attributes id - unique identifier of the node in_edges - list of all the input edges to the node out_edges - list of all the output edges from the node node_setup_time - an initial delay to set up the node.","title":"Nodes"},{"location":"basic_components/#source","text":"About The source is an active component that generates items that flow through the system. There are two modes of operation for the source. If the parameter blocking is set to True, the source generates an item and tries to send it to the connected output edge. If the edge is full or cannot accept the item, the source waits until space becomes available. If the blocking parameter is set to False, the source generates items and attempts to send them to the output edge. If the edge is full or cannot accept the item, the source discards the item. The API documentation can be found in Source . Basic attributes state - Current state of the component. inter_arrival_time - Time interval between two successive item generation. flow_item_type - This is the type of item the source should generate. Either \"item\" or \"pallet\". blocking - If True, waits for output edge to be available to accept item and pushes the item when it is available; if False, discards the item if the output edge if full. out_edge_selection - Edge selection policy as a function to select output edge. Behavior At the start of the simulation, the source waits for node_setup_time . This is an initial, one-time wait time for setting up the node and should be provided as a constant (an int or float ). During a simulation run, the source generates items at discrete instants of time determined by the parameter inter_arrival_time . Details on how to configure parameter inter_arrival_time can be found here . After the wait it produces a flow item based on the type mentioned in flow_item_type . It can be of two types namely \"item\" and \"pallet\". Item represents the smallest unit of discrete items that flow in the system. Pallets represents the type of flow item that can hold multiple items inside and it can be used to pack items. The source can have multiple output edges. It then chooses an output edge from out_edges list based on the out_edge_selection parameter. More details on how to configure parameter out_edge_selection can be found here . After generating an item and choosing an output edge, the source behaves as follows: If blocking is True , it waits with the processed item in a \"BLOCKED_STATE\" for the out edge to be available and pushes the item when output edge becomes available or has space. If blocking is False , it checks if there is space in the output edge to accomodate the item. If the edge is full or unavailable, the item is discarded and the count of discarded item is recorded. States During its operation, the source transitions through the following states: \"SETUP_STATE\": Initialization or node setup phase before item generation starts. \"GENERATING_STATE\": Active state where items are being created and pushed to the output edge. \"BLOCKED_STATE\": The source is blocked, waiting for the output edge to be available to accept an item (only when blocking is True ). Usage Source can be initialised as shown below. import factorysimpy from factorysimpy.nodes.source import Source SRC = Source ( env , # Simulation environment id = \"SRC2\" , # Unique identifier for the source node inter_arrival_time = 0.4 , # Time between item generations (can be constant or function/generator) flow_item_type = \"item\" , # Type of baseflowitem that the source should generate blocking = False , # If True, waits for output edge to accept item; if False, discards item if the output edge is full out_edge_selection = 0 # Strategy or function to select output edge (can be string or callable or genrator or a constant int) ) Statistics collected Several key metrics are being monitored in the class can be accessed in the attribute stats as component.stats[ num_item_generated ]. The source component reports the following key metrics. Total number of items generated Number of items discarded (non-blocking mode) Time spent in each state Consider a source with blocking = False and instance name as SRC. Metrics of a component SRC can be accessed after completion of the simulation run as print ( f \"Total number of items generated by { SRC . id } = { SRC . stats [ \"num_items_processed\" ] } \" ) print ( f \"Total number of items discarded by { SRC . id } = { SRC . stats [ \"num_items_discarded\" ] } \" ) print ( f \"Source { SRC . id } , state times: { SRC . stats [ \"time_spent_in_states\" ] } \" ) Examples A simple example with all parameters passed as constants An example with inter_arrival_delay passed as a normal python function An example with inter_arrival_delay passed as a normal python generator function instance An example with out_edge_selection parameter is passed as custom function that yields edge indices","title":"Source"},{"location":"basic_components/#machine","text":"About A machine is an active component that processes items flowing through the system. Each item incurs a processing_delay amount of time to get processed in the machine. A machine can have multiple in_edges and out_edges . A machine can process multiple items simultaneously. The parameter work_capacity indicates the maximum number of items that can be processed simulatanously inside the machine. If work_capacity is set to a number greater than 1 (for example, k), this represents a machine with a maximum of k worker processes that are capable of processing k items simultaneously. Machine has two modes of operation based on the parameter value specified in blocking . If it is set to True , the processed item is held in a blocked state and machine waits for the out edge to be available to accept the item and pushes the processed item to the chosen out edge once it is available. The other mode can be configured by setting blocking to False . In this mode , the machine checks if there is space available in the chosen output edge and only if there is space the item is pushed. If the output edge is unavailable or full, the item will be discarded and its count will be recorded. The API documentation can be found in Machine . Basic attributes work_capacity - Maximum number of items that can be processed by the machine simulataneously. processing_delay - Time taken to process an item. state_rep - This is a 2-tuple where the entries are the number of threads in the processing state and in the blocked state respectively e.g., (num_processing_threads, num_blocked_threads). The number of threads in the IDLE_STATE can be determined by subtracting the sum of num_processing_threads and num_blocked_threads from the total work_capacity (work_capacity - (num_processing_threads + num_blocked_threads)). Inaddition to these, there is a \"SETUP_STATE\" for the machine and is denoted as (-1,-1). \"IDLE_STATE\" is when all the threads are idle and is represented as (0,0). blocking - If True, waits for output edge to be available to accept item and pushes the item when it is available; if False, discards the item if the output edge is full. in_edge_selection - Edge selection policy as a function to select input edge. out_edge_selection - Edge selection policy as a function to select output edge. Behavior At the start of the simulation, the machine waits for node_setup_time . This is an initial, one-time wait time for setting up the node and should be provided as a constant (an int or float ). Machine can process atmost work_capacity number of items in parallel. As soon as an item is input from one of its input edges based on in_edge_selection , a worker thread is reserved which remains busy for processing the item in processing_delay amount of time and at the end of this time the worker thread attempts to output the item to one of the out_edges selected using the out_edge_selection parameter. More details on how to configure the parameters processing_delay , out_edge_selection and in_edge_selection can be found here . Multiple items can be in \"PROCESSING_STATE\" at a time. After processing the item, the worker thread behaves as follows: If blocking is True , it waits with the processed item in a \"BLOCKED_STATE\" for the out edge to be available and pushes the item when output edge becomes available or has space. If blocking is False , it checks if there is space in the output edge to accomodate the item. If the edge is full or unavailable, the item is discarded and the count of discarded item is recorded. States During its operation, a machine transitions between different states based on the status of its worker threads. Each worker thread moves through the following thread level states: IDLE_STATE : All the threads are idle. PROCESSING_STATE : The thread is actively processing an item. BLOCKED_STATE : The thread has finished processing but is waiting for an available output edge to transfer the item. The machine reports the following statistics for the various states a machine transitions through during simulation based on the collective status of the states of its threads. total_time_setup (S): Time spent in the initialization or warming up phase before item processing starts. Denoted as (-1,-1) in state_rep. total_time_idle (I): Time duration for which the machine doesnot have any worker thread that is currently getting processed or is blocked. total_time_atleast_one_processing (1P): Time duration for which the machine is actively processing items. There will be atleast one thread in processing state in the machine. total_time_all_blocked (AB): Time duration for which all the worker_threads that are currently active are in \"BOCKED_STATE\" as they are waiting for the out edge to be available to accept the processed item. The number of active threads can be equal to less than work_capacity. ie, there will >=1 threads in blocked state, >=0 threads in idle state and no threads in processing state. total_time_all_active_processing (AP): Time duration for which all the active threads are in processing state. The number of active threads can be equal to less than work_capacity. ie, there will >=1 threads in processing state, >=0 threads in idle state and no threads in blocked state. total_time_atleast_one_blocked (1B): Time duration for which atleast one of the worker_threads is in \"BOCKED_STATE\" as it is waiting for the out edge to be available to accept the processed item. Some of the reported statistics are not mutually exclusive and may occur simultaneously. However, the following groupings are mutually exclusive and collectively exhaustive, meaning they cover all possible scenarios without overlap within each group: Group A: {S + I + 1P + AB} = total simulation time Group B: {S + I + AP + 1B} = total simulation time Each group individually spans 100% of the simulation time. State Diagram State_rep - (N_P, N_B); (Number of threads in processing state, number of threads in blocked state) Number of threads in idle state, N_I = work_capacity - (N_P + N_B) stateDiagram direction TB [*] --> Idle : No jobs and all threads idle Idle --> Processing:Input job Processing --> Blocked:Output blocked Processing --> Idle:Job finished Blocked --> Idle:Output succeeded Usage A machine can be initialised as below. import factorysimpy from factorysimpy.nodes.machine import Machine MACHINE1 = Machine ( env , # Simulation environment id = \"MACHINE1\" , # Unique identifier for the machine node work_capacity = 4 , # Max number of items that can be processed simultaneously processing_delay = 1.2 , # Processing delay (constant or generator/function) blocking = False , # If True, waits for output edge to accept item; if False, discards item if the output edge is full in_edge_selection = \"RANDOM\" , # Policy or function to select input edge out_edge_selection = \"RANDOM\" # Policy or function to select output edge ) Statistics collected The machine component reports the following key metrics. Total number of items processed total time in PROCESSING_STATE (per thread) Total time spent in BLOCKED_STATE (per thread) Occupancy of the worker threads Total time spent in each of the machine level states Total number if items discarded (when blocking = False) Consider a machine with work_capacity = 2 , blocking = False and and instance name as MACHINE1. Metrics of a component MACHINE1 can be accessed after completion of the simulation run as print ( f \"Total number of items processed by { MACHINE1 . id } = { MACHINE1 . stats [ \"num_items_processed\" ] } \" ) print ( f \"Total number of items discarded by { MACHINE1 . id } = { MACHINE1 . stats [ \"num_items_discarded\" ] } \" ) print ( f \"Machine { MACHINE1 . id } ,total time in BLOCKED_STATE (per thread) : { MACHINE1 . per_thread_total_time_in_blocked_state } \" ) print ( f \"Machine { MACHINE1 . id } ,total time in PROCESSING_STATE (per thread) : { MACHINE1 . per_thread_total_time_in_processing_state } \" ) print ( f \"Worker occupancy: (Indices represent the number of active threads, and values represent the total time during which that many threads were active simultaneously) \\n { MACHINE1 . time_per_work_occupancy } \" ) # Compute mutually exclusive sums groupA_states = [ \"total_time_setup\" , \"total_time_idle\" , \"total_time_atleast_one_processing\" , \"total_time_all_active_blocked\" ] groupB_states = [ \"total_time_setup\" , \"total_time_idle\" , \"total_time_all_active_processing\" , \"total_time_atleast_one_blocked\" ] sum_groupA = sum ( getattr ( MACHINE1 , s ) for s in groupA_states ) sum_groupB = sum ( getattr ( MACHINE1 , s ) for s in groupB_states ) print ( \" \\n Mutually exclusive group totals:\" ) print ( f \" Group A (S+I+1P+AB): { sum_groupA : .2f } \" ) print ( f \" Group B (S+I+AP+1B): { sum_groupB : .2f } \" ) Examples A simple example with all parameters passed as constants Example with processing_delay passed as function that generates random variates from a chosen distribution Example with processing_delay passed as a generator function instance An example with out_edge_selection and in_edge_selection parameter is passed as custom function that yields edge indices","title":"Machine"},{"location":"basic_components/#combiner","text":"About The Combiner component represents a node that combines or packs items from multiple input edges into a single pallet or box, and then pushes the packed pallet to an output edge. It is useful for modeling operations such as packing, assembly, or combining items from different sources. The number of items to be taken from each input edge can be specified, and the first input edge is expected to provide the pallet or container. A Combiner can process only one pallet at a time. The API documentation can be found in Combiner . Basic attributes state - current state of the component. This is a dictionary where each key is a worker thread's ID (assigned in order of initialization), and the value is the current state of that worker. processing_delay - time taken to process and pack the items blocking - if True, waits for output edge to accept the packed pallet; if False, discards the pallet if the output edge is full target_quantity_of_each_item - list specifying how many items to take from each input edge (first entry is always 1 for the pallet) out_edge_selection - edge selection policy as a function to select output edge Behavior At the start of the simulation, the Combiner waits for node_setup_time . This is an initial, one-time wait time for setting up the node and should be provided as a constant (an int or float ). Then it spawns work_capacity number of threads. The process then repeatedly: Pulls a pallet from the first input edge. Pulls the specified number of items from each of the other input edges and adds them to the pallet. Waits for processing_delay to simulate packing/combining. Pushes the packed pallet to the output edge, either waiting if blocking is True or discarding if the edge is full and blocking is False. To select an output edge, to push the item to, worker thread uses the method specified in out_edge_selection parameter. User can also provide a custom python function or a generator function instance to these parameters. User-provided function should return or yield an edge index. If the function depends on any of the node attributes, users can pass None to these parameters at the time of node creation and later initialise the parameter with the reference to the function. This is illustrated in the examples shown below. Various options available in the package for out_edge_selection include: \"RANDOM\": Selects a random out edge. \"ROUND_ROBIN\": Selects out edges in a round-robin manner. \"FIRST_AVAILABLE\": Selects the first out edge that can accept an item. States During its operation, the Combiner transitions through the following states: \"SETUP_STATE\": Initialization or warm-up phase before packing starts. \"IDLE_STATE\": Waiting to receive a pallet and items. \"PROCESSING_STATE\": Actively packing items into the pallet. \"BLOCKED_STATE\": Blocked, waiting for the output edge to accept the packed pallet. Usage A Combiner can be initialized as below: import factorysimpy from factorysimpy.nodes.combiner import Combiner COMBINER1 = Combiner ( env , # Simulation environment id = \"COMBINER1\" , # Unique identifier for the Combiner node target_quantity_of_each_item = [ 1 , 2 ], # 1 pallet from in_edges[0], 2 items from in_edges[1] processing_delay = 1.5 , # Packing delay (constant or generator/function) blocking = True , # Wait for output edge to accept pallet out_edge_selection = \"RANDOM\" # Policy or function to select output edge ) Statistics collected The Combiner component reports the following key metrics: Total number of pallets packed and pushed Number of pallets/items discarded (non-blocking mode) Time spent in each state After the simulation run, metrics can be accessed as: print ( f \"Total number of pallets processed by worker 1 of { COMBINER1 . id } = { COMBINER1 . stats [ 1 ][ 'num_item_processed' ] } \" ) print ( f \"Total number of pallets discarded by worker 1 of { COMBINER1 . id } = { COMBINER1 . stats [ 1 ][ 'num_item_discarded' ] } \" ) print ( f \"Combiner { COMBINER1 . id } , worker1 state times: { COMBINER1 . stats [ 1 ][ 'total_time_spent_in_states' ] } \" ) Examples An example of a Combiner node combining items from two sources","title":"Combiner"},{"location":"basic_components/#splitter","text":"About The Splitter component represents a node that unpacks or splits an input item (such as a pallet or batch) and sends its contents to multiple output edges. It is useful for modeling operations such as unpacking. A Splitter can process more only one pallet at a time. The input edge is selected according to the in_edge_selection policy, and the output edge for each unpacked item is selected according to the out_edge_selection policy. The API documentation can be found in Splitter . Basic attributes state - current state of the component. This is a dictionary where each key is a worker thread's ID (assigned in order of initialization), and the value is the current state of that worker. processing_delay - time taken to process and unpack the items blocking - if True, waits for output edge to accept the item; if False, discards the items if the output edge is full mode - mode of operation of the splitter. Either \"UNPACK\" or \"SPLIT\". split_quantity - Target quantity of items to split the input flow item into. in_edge_selection - edge selection policy as a function to select input edge out_edge_selection - edge selection policy as a function to select output edge Behavior At the start of the simulation, the splitter waits for node_setup_time . it repeatedly: Pulls a packed item (e.g., pallet) from the selected input edge. Waits for processing_delay to simulate unpacking or splitting. If the Splitter mode is \"UNPACK\", then it unpacks the items from the pallet and pushes each item to an output edge, one by one, using the out_edge_selection policy. After all items are pushed, the empty container itself is pushed to an output edge. If the Splitter mode is \"SPLIT\", then it splits the items into a target quanitity of items, specified by split_quantity and pushes each item to an output edge, one by one, using the out_edge_selection policy. If blocking is True, the splitter waits for the output edge to accept each item; if blocking is False, items are discarded if the output edge is full. To select an output edge and input edge, worker thread uses the method specified in out_edge_selection and in_edge_selection parameters. User can also provide a custom python function or a generator function instance to these parameters. User-provided function should return or yield an edge index. If the function depends on any of the node attributes, users can pass None to these parameters at the time of node creation and later initialise the parameter with the reference to the function. This is illustrated in the examples shown below. Various options available in the package for in_edge_selection and out_edge_selection include: \"RANDOM\": Selects a random out edge. \"ROUND_ROBIN\": Selects out edges in a round-robin manner. \"FIRST_AVAILABLE\": Selects the first out edge that can accept an item. States During its operation, the splitter transitions through the following states: \"SETUP_STATE\": Initialization or warm-up phase before unpacking starts. \"IDLE_STATE\": Waiting to receive a container/item. \"PROCESSING_STATE\": Actively unpacking or splitting items. \"BLOCKED_STATE\": Blocked, waiting for the output edge to accept the item. Usage A splitter can be initialized as below: import factorysimpy from factorysimpy.nodes.splitter import Splitter SPLITTER11 = Split ( env , # Simulation environment id = \"SPLITTER11\" , # Unique identifier for the splitternode processing_delay = 1.0 , # Unpacking delay (constant or generator/function) blocking = True , # Wait for output edge to accept item mode = \"UNPACK\" , # mode can be UNPACK or SPLIT split_quantity = None , # To be used is mode is SPLIT in_edge_selection = \"RANDOM\" , # Policy or function to select input edge out_edge_selection = \"ROUND_ROBIN\" # Policy or function to select output edge ) Statistics collected The splittercomponent reports the following key metrics: Total number of items unpacked and pushed Number of items discarded (non-blocking mode) Time spent in each state After the simulation run, metrics can be accessed as: print ( f \"Total number of items processed by worker 1 of { SPLITTER11 . id } = { SPLITTER11 . stats [ 1 ][ 'num_item_processed' ] } \" ) print ( f \"Total number of items discarded by worker 1 of { SPLITTER11 . id } = { SPLITTER11 . stats [ 1 ][ 'num_item_discarded' ] } \" ) print ( f \"splitter { SPLITTER11 . id } , worker1 state times: { SPLITTER11 . stats [ 1 ][ 'total_time_spent_in_states' ] } \" ) Examples An example of a splitternode unpacking a pallet and distributing items to multiple destinations","title":"Splitter"},{"location":"basic_components/#sink","text":"A Sink is a terminal node that collects flow items at the end. Once an item enters the sink, it is considered to have exited the system and cannot be retrieved or processed further. The sink can have multiple input edges but no output edges. More details on how to configure the parameter out_edge_selection can be found here . It only has a single state \"COLLECTING_STATE\". The API documentation can be found in Sink . Behavior During a simulation run, sink waits for an item to be available at one of its input edges and accepts that item, records the statistics and destructs that item. Usage A splittercan be initialized as below: import factorysimpy from factorysimpy.nodes.sink import Sink SINK = SINK ( env , # Simulation environment id = \"SINK\" , # Unique identifier for the node ) Statistics collected The sink component reports the following key metrics. Total number of items received sum of cycle times of all items received by the sink Consider a sink with instance name as SINK. Its metrics can be accessed after completion of the simulation run as total = SINK . stats [ \"num_item_received\" ] cycle_time = SINK . stats [ \"total_cycle_time\" ] / 60 print ( f \"Average cycle time per item: { cycle_time / total if total > 0 else 0 : .2f } minutes\" ) print ( f \"Total number of items received: { sink . stats } \" )","title":"Sink"},{"location":"basic_components/#edges","text":"Edges represent passive elements in the system. This is the basis for the components like Buffer, Conveyor, Fleet, etc. Every edge has a unique identifier named id and maintains references to a source node src_node and a destination node dest_node . There can only be one source node and one destination node for an edge. Edge acts as a conntction between these two nodes and facilitates the movement of items between the nodes.","title":"Edges"},{"location":"basic_components/#buffer","text":"About The Buffer component represents a queue (FIFO or LIFO) that temporarily holds items between nodes in the system. It acts as an edge with internal storage, allowing items to be stored until the destination node is ready to accept them. Items placed in the buffer become available for retrieval after a specified delay . The buffer can operate in two modes: - FIFO (First In First Out): Oldest items are released first. - LIFO (Last In First Out): Newest items are released first. The API documentation can be found in Buffer . Basic attributes state - current state of the buffer capacity - maximum number of items the buffer can hold mode - mode of operation of the buffer. Either \"FIFO\" or \"LIFO\". delay - time after which an item becomes available for retrieval (can be a constant, generator, or callable) Behavior When an item is put into the buffer, it is stored internally and becomes available for retrieval after the specified delay . The buffer has methods to check if it can accept new items using can_put method and if it can provide items to the next node using can_get method. In FIFO mode, items are released in the order they were added; in LIFO mode, the most recently added items are released first. Incoming edges can use reserve_get and reserve_put calls on the store in the buffer to reserve an item or space and after yielding the requests, an item can be put and obtained by using put and get methods. Buffer has methods to list all the items in the buffer( items() ), to list only the ready items in the buffer( ready_items() ) and to return the number of items in the buffer ( occupancy() ). States The buffer transitions between states such as \"IDLE_STATE\" (waiting for items), \"RELEASING_STATE\" (releasing items), and \"BLOCKED_STATE\" (cannot accept or release items due to capacity or downstream constraints). \"EMPTY_STATE\" - when there is no items in the buffer \"RELEASING_STATE\"- When there is items in the buffer that are ready to be taken out. Usage A buffer can be initialized as below: import factorysimpy from factorysimpy.edges.buffer import Buffer BUF1 = Buffer ( env , # Simulation environment id = \"BUF1\" , # Unique identifier for the buffer capacity = 10 , # Maximum number of items in the buffer delay = 2.0 , # Delay before items become available (can be int, float, generator, or callable) mode = \"FIFO\" # \"FIFO\" or \"LIFO\" ) Statistics collected The buffer component reports the following key metrics: Time when the state was last changed ( last_state_change_time ) Time-averaged number of items in the buffer ( time_averaged_num_of_items_in_buffer ) Total time spent in each state ( total_time_spent_in_states ) After the simulation run, metrics can be accessed as: print ( f \"Buffer { BUF1 . id } last state change: { BUF1 . stats [ 'last_state_change_time' ] } \" ) print ( f \"Buffer { BUF1 . id } time-averaged number of items: { BUF1 . stats [ 'time_averaged_num_of_items_in_buffer' ] } \" ) print ( f \"Buffer { BUF1 . id } state times: { BUF1 . stats [ 'total_time_spent_in_states' ] } \" ) Examples A simple example with a FIFO buffer between a source and a machine","title":"Buffer"},{"location":"basic_components/#fleet","text":"About The fleet component represents an AGV that moves multiple items simultaneously between nodes in the system. It acts as an edge. The fleet is activated when either of two conditions is met: Capacity condition \u2013 the number of stored items reaches capacity. Delay condition \u2013 the specified delay time elapses after the first item arrives, even if capacity is not met. When activated, the fleet incurs transit_delay amount of time and makes its stored items available to the destination node. The API documentation can be found in Fleet . Basic attributes state - current state of the fleet capacity - target quantity of items after which the fleet will be activated delay - Maximum waiting time before the fleet is triggered. (can be a constant, generator, or callable) transit_delay - transit_delay (int, float): It is the time taken by the fleet to transport the item from src node to destination node. (can be a constant, generator, or callable) Behavior When an item is put into the fleet, it is stored internally and becomes available for retrieval after the specified delay or after a target quantity ( capacity ) of items is available in fleet. Once triggered the items will be available for the destination node. Fleet will incur transit_delay amount of time to travel to the src_node from dest_node and takes the object and incurs transit_delay time again and transfer the item to the dest_node from src_node. The fleet has methods to check if it can accept new items using can_put method and if it can provide items to the next node using can_get method. Incoming edges can use reserve_get and reserve_put calls on the store in the fleet to reserve an item or space and after yielding the requests, an item can be put and obtained by using put and get methods. States The fleet transitions between states such as \"IDLE_STATE\" (waiting for items), \"RELEASING_STATE\" (releasing items), and \"BLOCKED_STATE\" (cannot accept or release items due to capacity or downstream constraints). \"EMPTY_STATE\" - when there is no items in the fleet \"RELEASING_STATE\"- When there is items in the fleet Usage A fleet can be initialized as below: import factorysimpy from factorysimpy.edges.fleet import Fleet FLEET1 = Fleet ( env , # Simulation environment id = \"FLEET1\" , # Unique identifier for the fleet capacity = 10 , # target capacity of items required to activate the fleet delay = 2.0 , # Delay after which fleet activates the movement of items incase the target capacity is not reached. (can be int, float, generator, or callable) transit_delay = 0 # time to move the items from one node to another ) Statistics collected The fleet component reports the following key metrics: Time when the state was last changed ( last_state_change_time ) Time-averaged number of items in the fleet ( time_averaged_num_of_items_in_fleet ) Total time spent in each state ( total_time_spent_in_states ) After the simulation run, metrics can be accessed as: print ( f \"fleet { FLEET1 . id } last state change: { FLEET1 . stats [ 'last_state_change_time' ] } \" ) print ( f \"fleet { FLEET1 . id } time-averaged number of items: { FLEET1 . stats [ 'time_averaged_num_of_items_in_fleet' ] } \" ) print ( f \"Fleet { FLEET1 . id } state times: { FLEET1 . stats [ 'total_time_spent_in_states' ] } \" ) Examples A simple example with a fleet between a source and a machine","title":"Fleet"},{"location":"basic_components/#conveyor","text":"Conveyor connects two nodes and facilitates the movement of items between them. It introduces a transport delay between nodes and acts as a passive element. There are two variants of conveyor available in this package:","title":"Conveyor"},{"location":"basic_components/#continuous-type-conveyor","text":"This variant models a conveyor belt where items can be placed onto the belt at any time. Each item requires a fixed transport time to reach its destination. The conveyor is designed for discrete items only and has a limited carrying capacity, i.e., it can hold only a fixed number of items simultaneously. Basic attributes state - current state of the conveyor conveyor_length - Length of the belt item_length - Length of the item. speed - speed of the conveyor belt (can be a constant) accumulating - Whether the belt supports accumulation (1 for yes, 0 for no) Behavior During a simulation run, a Conveyor that is initially empty begins operation as soon as it receives its first item. Each item requires a fixed transport time to reach the opposite end of the belt. The time delay to transport an item on the conveyor is calculated as conveyor_length / conveyor_speed. A new item can be added only after item_length/ conveyor_speed amount of time is incurred after the last item is put on the belt. The conveyor continues moving until the leading item reaches the destination node (dest_node). If the destination node does not accept the item, the conveyor enters a STALLED state. An accumulating conveyor can continue to accept new items while stalled, provided there is remaining capacity. A non-accumulating conveyor cannot accept new items while stalled. During its operation, the conveyor transitions through the following states: \"SETUP_STATE\": Initialization or warm-up phase. \"MOVING_STATE\": state when the belt is moving. \"STALLED_ACCUMULATING_STATE\": a belt (configured to be accumulating) becomes stalled when it has an item that is ready to be taken by the destination node. \"STALLED_NONACCUMULATING_STATE: a belt (configured to be non-accumulating) becomes stalled when it has an item that is ready to be taken by the destination node. Conveyors can be either accumulating or non-accumulating : A non-accumulating type conveyor will not allow src_node to push items into the conveyor if it is in a stalled state A accumulating conveyor allows src_node to push items until its capacity is reached when when it is in stalled state. Usage A continuous-type can be initialized as below: import factorysimpy from factorysimpy.edges.continuous_conveyor import ConveyorBelt CONVEYORBELT1 = ConveyorBelt ( env , # Simulation environment id = \"CONVEYORBELT1\" , # Unique identifier for the fleet conveyor_length = 5 , # Capacity of the conveyor speed = 1 , # Speed of the conveyor item_length = 1 , # Length of the item accumulating = True # If the conveyor is in Accumulating mode or not ) Monitoring and Reporting The component reports the following key metrics: Time averaged number of items Examples A simple example with a continuous-type conveyor belt","title":"Continuous-type Conveyor"},{"location":"basic_components/#slotted-type-conveyor","text":"This variant moves items from one end to the other at fixed time intervals, simulating a belt with predefined slots. Its behavior is governed by teo key parameters- a constant delay between two successive movements and capacity that defines the number of slots available on the conveyor. It can hold only up to capacity number of items at a time. Basic attributes state - current state of the conveyor capacity - Maximum number of items that can be carried simultaneously delay - time interval between two successive movements on the belt (can be a constant, generator, or callable) accumulating - Whether the belt supports accumulation (1 for yes, 0 for no) Behavior During a simulation run, the conveyor remains idle until it receives the first item. At that point, it transitions into MOVING_STATE and begins advancing items at fixed intervals defined by delay. Each advancement shifts all items one slot closer to the destination end. The conveyor continues moving until the leading item reaches the destination node. The conveyor continues moving until the leading item reaches the destination node (dest_node). If the destination node does not accept the item, the conveyor enters a STALLED state. An accumulating conveyor can continue to accept new items while stalled, provided there is remaining capacity. A non-accumulating conveyor cannot accept new items while stalled. During its operation, the conveyor transitions through the following states: \"SETUP_STATE\": Initialization or warm-up phase. \"MOVING_STATE\": state when the belt is moving. \"STALLED_ACCUMULATING_STATE\": a belt (configured to be accumulating) becomes stalled when it has an item that is ready to be taken by the destination node. \"STALLED_NONACCUMULATING_STATE: a belt (configured to be non-accumulating) becomes stalled when it has an item that is ready to be taken by the destination node. It will not allow any item to be pushed onto belt while in this state. Usage A continuous-type can be initialized as below: import factorysimpy from factorysimpy.edges.slotted_conveyor import ConveyorBelt CONVEYORBELT1 = ConveyorBelt ( env , # Simulation environment id = \"CONVEYORBELT1\" , # Unique identifier for the fleet capacity = 5 , # Capacity of the conveyor delay = 1 , # Time interval between two successive movements of the belt accumulating = True # If the conveyor is in Accumulating mode or not ) Monitoring and Reporting The component reports the following key metrics: Time averaged number of items Examples A simple example with a slotted-type conveyor belt","title":"Slotted-type Conveyor"},{"location":"basic_components/#baseflowitem","text":"This is base class for the items that flow in the system. Basic attributes id - Unique identifier for the pallet. timestamp_creation - Time when the pallet was created. timestamp_destruction - Time when the pallet was destroyed (e.g., collected by a sink). timestamp_node_entry - Time when the pallet entered the current node. timestamp_node_exit - Time when the pallet exited the current node. current_node_id - The ID of the node the pallet is currently in. source_id - The ID of the source node that created the pallet. payload - Optional data carried by the pallet. destructed_in_node - The node where the pallet was destroyed.","title":"BaseFlowItem"},{"location":"basic_components/#item","text":"About The Item class represents the discrete entities that flow through the system. Each item is created by a source node and is then processed, transferred, or collected by various nodes and edges as it moves through the simulation. The Item object tracks its movement, including timestamps for creation, entry and exit at each node, and destruction, as well as the time spent at each node. Basic attributes flow_item_type - \"item\" type of the base flow item Behavior When an item is created, its creation time and source node are recorded. As the item enters and exits nodes, the update_node_event method updates entry/exit times and accumulates the time spent at each node in the stats dictionary. When the item is destroyed (e.g., collected by a sink), the destruction time and node are recorded. Statistics collected The Item class tracks: Creation and destruction times. The node where the item was created and destroyed. Time spent at each node (accessible via the stats dictionary). Consider that an item is created inside a source and it has finished its flow in the system. The statistics can be collected as f0llows item1 = Item ( id = \"item1\" ) for key , value in item1 . stats : print ( \"Time spent in node {key.id} is {value} \" )","title":"Item"},{"location":"basic_components/#pallet","text":"About The Pallet class represents a special type of item that can hold multiple other items. It is used to model containers, pallets, or boxes that group several items together for combined processing, transport, or packing/unpacking operations in the system. The Pallet object tracks its own journey through the system, just like a regular Item , and also maintains a list of the items it contains. Basic attributes flow_item_type - \"Pallet\" type of the base flow item items - List of items currently held in the pallet. Behavior When a pallet is created, its creation time and source node are recorded. Items can be added to the pallet using the add_item(item) method. Items can be removed from the pallet using the remove_item() method, which returns an item or None if the pallet is empty. As the pallet enters and exits nodes, the update_node_event method updates entry/exit times and accumulates the time spent at each node in the stats dictionary. When the pallet is destroyed (e.g., collected by a sink), the destruction time and node are recorded. Statistics collected The Pallet class tracks: Creation and destruction times. The node where the pallet was created and destroyed. Time spent at each node (accessible via the stats dictionary). The number of items currently held in the pallet. Consider that an pallet is created inside a source and it has finished its flow in the system. The statistics can be collected as f0llows pallet1 = Pallet ( id = \"pallet1\" ) for key , value in pallet1 . stats : print ( \"Time spent in node {key.id} is {value} \" )","title":"Pallet"},{"location":"buffer/","text":"Buffer ( env , id , capacity = 1 , delay = 0 , mode = 'FIFO' ) \u00b6 Bases: Edge Buffer class representing a FIFO queue. Inherits from the Edge class. This buffer can have a single input edge and a single output edge. Attributes: state ( str ) \u2013 The current state of the buffer. capacity ( int ) \u2013 The capacity of the buffer's internal storage. mode ( str ) \u2013 Mode of operation for the buffer, It can be - \"FIFO\" (First In First Out) - \"LIFO\" (Last In First Out). delay ( ( int , float ) ) \u2013 Delay after which the item becomes available. It Can be int or float: Used as a constant delay. Behavior: The Buffer is a type of edge represents components that holds the items that are waiting to be accepted by the destination node. Items that are added in buffer becomes available for use after delay amount of time. It operates in two modes- 1. FIFO : It prioritizes items in the order they were added, with the oldest items being available for the destination node first. 2. LIFO : It prioritizes items in the reverse order of their arrival, items that newly added are available to use by the destination node first Incoming edges can use reserve_get and reserve_put calls on the store in the buffer to reserve an item or space and after yielding the requests, an item can be put and obtained by using put and get methods. Raises: AssertionError \u2013 If the buffer does not have at least one source node or one destination node. Output performance metrics The key performance metrics of the buffer edge are captured in the stats attribute (dict) during a simulation run. last_state_change_time : Time when the state was last changed . time_averaged_num_of_items_in_buffer : Time - averaged number of items available in the buffer . total_time_spent_in_states : Dictionary with total time spent in each state . can_put () \u00b6 Check if the buffer can accept an item. Returns \u00b6 bool True if the buffer can accept an item, False otherwise. can_get () \u00b6 Check if the buffer can accept an item. Returns \u00b6 bool True if the buffer can give an item, False otherwise. get ( event ) \u00b6 Get an item from the buffer. Parameters \u00b6 event : simpy.Event The event that was reserved for getting an item. Returns \u00b6 item : object The item retrieved from the buffer. reserve_get_cancel ( event ) \u00b6 Cancel a reserved get event. Parameters \u00b6 event : simpy.Event The event that was reserved for getting an item. reserve_put_cancel ( event ) \u00b6 Cancel a reserved put event. Parameters \u00b6 event : simpy.Event The event that was reserved for putting an item.","title":"Buffer"},{"location":"buffer/#factorysimpy.edges.buffer.Buffer","text":"Bases: Edge Buffer class representing a FIFO queue. Inherits from the Edge class. This buffer can have a single input edge and a single output edge. Attributes: state ( str ) \u2013 The current state of the buffer. capacity ( int ) \u2013 The capacity of the buffer's internal storage. mode ( str ) \u2013 Mode of operation for the buffer, It can be - \"FIFO\" (First In First Out) - \"LIFO\" (Last In First Out). delay ( ( int , float ) ) \u2013 Delay after which the item becomes available. It Can be int or float: Used as a constant delay. Behavior: The Buffer is a type of edge represents components that holds the items that are waiting to be accepted by the destination node. Items that are added in buffer becomes available for use after delay amount of time. It operates in two modes- 1. FIFO : It prioritizes items in the order they were added, with the oldest items being available for the destination node first. 2. LIFO : It prioritizes items in the reverse order of their arrival, items that newly added are available to use by the destination node first Incoming edges can use reserve_get and reserve_put calls on the store in the buffer to reserve an item or space and after yielding the requests, an item can be put and obtained by using put and get methods. Raises: AssertionError \u2013 If the buffer does not have at least one source node or one destination node. Output performance metrics The key performance metrics of the buffer edge are captured in the stats attribute (dict) during a simulation run. last_state_change_time : Time when the state was last changed . time_averaged_num_of_items_in_buffer : Time - averaged number of items available in the buffer . total_time_spent_in_states : Dictionary with total time spent in each state .","title":"Buffer"},{"location":"buffer/#factorysimpy.edges.buffer.Buffer.can_put","text":"Check if the buffer can accept an item.","title":"can_put"},{"location":"buffer/#factorysimpy.edges.buffer.Buffer.can_put--returns","text":"bool True if the buffer can accept an item, False otherwise.","title":"Returns"},{"location":"buffer/#factorysimpy.edges.buffer.Buffer.can_get","text":"Check if the buffer can accept an item.","title":"can_get"},{"location":"buffer/#factorysimpy.edges.buffer.Buffer.can_get--returns","text":"bool True if the buffer can give an item, False otherwise.","title":"Returns"},{"location":"buffer/#factorysimpy.edges.buffer.Buffer.get","text":"Get an item from the buffer.","title":"get"},{"location":"buffer/#factorysimpy.edges.buffer.Buffer.get--parameters","text":"event : simpy.Event The event that was reserved for getting an item.","title":"Parameters"},{"location":"buffer/#factorysimpy.edges.buffer.Buffer.get--returns","text":"item : object The item retrieved from the buffer.","title":"Returns"},{"location":"buffer/#factorysimpy.edges.buffer.Buffer.reserve_get_cancel","text":"Cancel a reserved get event.","title":"reserve_get_cancel"},{"location":"buffer/#factorysimpy.edges.buffer.Buffer.reserve_get_cancel--parameters","text":"event : simpy.Event The event that was reserved for getting an item.","title":"Parameters"},{"location":"buffer/#factorysimpy.edges.buffer.Buffer.reserve_put_cancel","text":"Cancel a reserved put event.","title":"reserve_put_cancel"},{"location":"buffer/#factorysimpy.edges.buffer.Buffer.reserve_put_cancel--parameters","text":"event : simpy.Event The event that was reserved for putting an item.","title":"Parameters"},{"location":"changelog/","text":"Changelog \u00b6 v0.1.0a1 \u00b6 It is a prerelease version of the package intended for testing. Contains basic documentation and examples.","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#v010a1","text":"It is a prerelease version of the package intended for testing. Contains basic documentation and examples.","title":"v0.1.0a1"},{"location":"combiner/","text":"Combiner ( env , id , in_edges = None , out_edges = None , node_setup_time = 0 , target_quantity_of_each_item = [ 1 ], processing_delay = 0 , blocking = True , out_edge_selection = 'FIRST_AVAILABLE' ) \u00b6 Bases: Node Combiner class representing a processing node in a factory simulation. Inherits from the Node class.The combiner can have multiple input edges and a multiple output edges. It gets items from the input edges and packs them into a pallet or box and pushes it to the output edge. Parameters: state ( str ) \u2013 Current state of the combiner node. One of : SETUP_STATE: Initial setup phase before combiner starts to operate. IDLE_STATE: Worker threads waiting to receive items. PROCESSING_STATE: Actively processing items. BLOCKED_STATE: When all the worker threads are waiting to push the processed item but the out going edge is full. blocking ( bool , default: True ) \u2013 If True, the source waits until it can put an item into the out edge. If False, it discards the item if the out edge is full and cannot accept the item that is being pushed by the combiner. processing_delay ( (None, int , float , Generator , Callable ) , default: 0 ) \u2013 Delay for processing items. Can be: None: Used when the processing time depends on parameters of the node object (like current state of the object) or environment. int or float: Used as a constant delay. Generator: A generator function yielding delay values over time. Callable: A function that returns a delay (int or float). out_edge_selection ( None or str or callable , default: 'FIRST_AVAILABLE' ) \u2013 Criterion or function for selecting the out edge. Options include \"RANDOM\", \"ROUND_ROBIN\", \"FIRST_AVAILABLE\". None: None: Used when out edge selction depends on parameters of the node object (like current state of the object) or environment. str: A string that specifies the selection method. \"RANDOM\": Selects a random out edge in the out_edges list. \"ROUND_ROBIN\": Selects out edges in a round-robin manner. \"FIRST_AVAILABLE\": Selects the first out edge that can accept an item. callable: A function that returns an edge index. Behavior The combiner node represents components that process or modify the items that flow in the simulation model. It can have multiple incoming edges and multiple outgoing edge. Edge to which processed item is pushed is decided using the method specified in the parameter out_edge_selection . Combiner will transition through the states- SETUP_STATE , PROCESSING_STATE , IDLE_STATE and BLOCKED_STATE . The combiner has a blocking behavior if blocking = True and gets blocked when all its worker threads have processed items and the out edge is full and cannot accept the item that is being pushed by the combiner and waits until the out edge can accept the item. If blocking = False , the combiner will discard the item if the out edge is full and cannot accept the item that is being pushed by the combiner. Raises: AssertionError \u2013 If the combiner has no input or output edges. Output performance metrics: The key performance metrics of the combiner node is captured in stats attribute (dict) during a simulation run. last_state_change_time : Time when the state was last changed . num_item_processed : Total number of items generated . num_item_discarded : Total number of items discarded . total_time_spent_in_states : Dictionary with total time spent in each state . update_state ( new_state , current_time ) \u00b6 Update node state and track the time spent in the previous state. Parameters: i ( int ) \u2013 The index of the worker thread to update the state for. new_state ( str ) \u2013 The new state to transition to. Must be one of \"SETUP_STATE\", \"GENERATING_STATE\", \"BLOCKED_STATE\". current_time ( float ) \u2013 The current simulation time. add_in_edges ( edge ) \u00b6 Adds an in_edge to the node. Raises an error if the edge already exists in the in_edges list. Parameters: edge (Edge Object) \u2013 The edge to be added as an in_edge. add_out_edges ( edge ) \u00b6 Adds an out_edge to the node. Raises an error if the edge already exists in the out_edges list. Parameters: edge (Edge Object) \u2013 The edge to be added as an out_edge.","title":"Combiner"},{"location":"combiner/#factorysimpy.nodes.combiner.Combiner","text":"Bases: Node Combiner class representing a processing node in a factory simulation. Inherits from the Node class.The combiner can have multiple input edges and a multiple output edges. It gets items from the input edges and packs them into a pallet or box and pushes it to the output edge. Parameters: state ( str ) \u2013 Current state of the combiner node. One of : SETUP_STATE: Initial setup phase before combiner starts to operate. IDLE_STATE: Worker threads waiting to receive items. PROCESSING_STATE: Actively processing items. BLOCKED_STATE: When all the worker threads are waiting to push the processed item but the out going edge is full. blocking ( bool , default: True ) \u2013 If True, the source waits until it can put an item into the out edge. If False, it discards the item if the out edge is full and cannot accept the item that is being pushed by the combiner. processing_delay ( (None, int , float , Generator , Callable ) , default: 0 ) \u2013 Delay for processing items. Can be: None: Used when the processing time depends on parameters of the node object (like current state of the object) or environment. int or float: Used as a constant delay. Generator: A generator function yielding delay values over time. Callable: A function that returns a delay (int or float). out_edge_selection ( None or str or callable , default: 'FIRST_AVAILABLE' ) \u2013 Criterion or function for selecting the out edge. Options include \"RANDOM\", \"ROUND_ROBIN\", \"FIRST_AVAILABLE\". None: None: Used when out edge selction depends on parameters of the node object (like current state of the object) or environment. str: A string that specifies the selection method. \"RANDOM\": Selects a random out edge in the out_edges list. \"ROUND_ROBIN\": Selects out edges in a round-robin manner. \"FIRST_AVAILABLE\": Selects the first out edge that can accept an item. callable: A function that returns an edge index. Behavior The combiner node represents components that process or modify the items that flow in the simulation model. It can have multiple incoming edges and multiple outgoing edge. Edge to which processed item is pushed is decided using the method specified in the parameter out_edge_selection . Combiner will transition through the states- SETUP_STATE , PROCESSING_STATE , IDLE_STATE and BLOCKED_STATE . The combiner has a blocking behavior if blocking = True and gets blocked when all its worker threads have processed items and the out edge is full and cannot accept the item that is being pushed by the combiner and waits until the out edge can accept the item. If blocking = False , the combiner will discard the item if the out edge is full and cannot accept the item that is being pushed by the combiner. Raises: AssertionError \u2013 If the combiner has no input or output edges. Output performance metrics: The key performance metrics of the combiner node is captured in stats attribute (dict) during a simulation run. last_state_change_time : Time when the state was last changed . num_item_processed : Total number of items generated . num_item_discarded : Total number of items discarded . total_time_spent_in_states : Dictionary with total time spent in each state .","title":"Combiner"},{"location":"combiner/#factorysimpy.nodes.combiner.Combiner.update_state","text":"Update node state and track the time spent in the previous state. Parameters: i ( int ) \u2013 The index of the worker thread to update the state for. new_state ( str ) \u2013 The new state to transition to. Must be one of \"SETUP_STATE\", \"GENERATING_STATE\", \"BLOCKED_STATE\". current_time ( float ) \u2013 The current simulation time.","title":"update_state"},{"location":"combiner/#factorysimpy.nodes.combiner.Combiner.add_in_edges","text":"Adds an in_edge to the node. Raises an error if the edge already exists in the in_edges list. Parameters: edge (Edge Object) \u2013 The edge to be added as an in_edge.","title":"add_in_edges"},{"location":"combiner/#factorysimpy.nodes.combiner.Combiner.add_out_edges","text":"Adds an out_edge to the node. Raises an error if the edge already exists in the out_edges list. Parameters: edge (Edge Object) \u2013 The edge to be added as an out_edge.","title":"add_out_edges"},{"location":"configuring_parameters/","text":"Configuring parameters \u00b6 Edge Selection \u00b6 There are different methods available to choose an input edge and output edge. To choose an input edge to pull an item from, the nodes utilises the strategy specified in the parameter in_edge_selection . Similarly, to select an output edge, to push the item to, nodes uses the method specified in out_edge_selection parameter. These parameters can be a constant integer value (one of the edge indices), or one of the methods available in the package (passed as a string; listed below) or a Python function or a generator function instance provided by the user. User-provided function should return or yield an edge index. If the function depends on any of the node attributes, users can pass None to these parameters at the time of node creation and later initialise the parameter with the reference to the function. Various options available in the package for in_edge_selection and out_edge_selection are listed below. To use these strategies, their names can be passed as a string while initialising the node. \"RANDOM\": Selects a random out edge. \"ROUND_ROBIN\": Selects out edges in a round-robin manner. \"FIRST_AVAILABLE\": Selects the first out edge that can accept an item. In case of \"FIRST_AVAILABLE\", always the edge with the least index value will be selected if multiple edges are available. If blocking is set to False and out_edge_selection is set to \"FIRST_AVAILABLE\", then the worker thread will check if any of the out edges is available to accept. The item is discarded only if none of the edges are available. Examples \u00b6 Example showing how to pass constant values to these parameters Example showing how to pass one of the methods available in the package as a string or a custom function to these parameters Delay parameters \u00b6 node_setup_time , inter_arrival_time and processing_delay are one of the two delay paramaters that can be configured. node_setup_time is an intial one time delay for setting up any node. inter_arrival_time is the time interval between two successive item generation in the source and processing_delay is the time incurres by an item to get processed in components like machine, split, joint, etc. node_setup_time can be an int or a float and is a constant value. The parameters inter_arrival_time and processing_delay can be specified as a constant value ( int or float ) or as a reference to a python function or a generator function instance that generates random variates from a chosen distribution. If the function depends on any of the node attributes, users can pass None to this parameter at the time of node creation and later initialise the parameter with the reference to the function. Examples \u00b6 Example showing how to pass constant values to these parameters Example showing how to pass a custom function or generator function instance to these parameters","title":"Configuring parameters"},{"location":"configuring_parameters/#configuring-parameters","text":"","title":"Configuring parameters"},{"location":"configuring_parameters/#edge-selection","text":"There are different methods available to choose an input edge and output edge. To choose an input edge to pull an item from, the nodes utilises the strategy specified in the parameter in_edge_selection . Similarly, to select an output edge, to push the item to, nodes uses the method specified in out_edge_selection parameter. These parameters can be a constant integer value (one of the edge indices), or one of the methods available in the package (passed as a string; listed below) or a Python function or a generator function instance provided by the user. User-provided function should return or yield an edge index. If the function depends on any of the node attributes, users can pass None to these parameters at the time of node creation and later initialise the parameter with the reference to the function. Various options available in the package for in_edge_selection and out_edge_selection are listed below. To use these strategies, their names can be passed as a string while initialising the node. \"RANDOM\": Selects a random out edge. \"ROUND_ROBIN\": Selects out edges in a round-robin manner. \"FIRST_AVAILABLE\": Selects the first out edge that can accept an item. In case of \"FIRST_AVAILABLE\", always the edge with the least index value will be selected if multiple edges are available. If blocking is set to False and out_edge_selection is set to \"FIRST_AVAILABLE\", then the worker thread will check if any of the out edges is available to accept. The item is discarded only if none of the edges are available.","title":"Edge Selection"},{"location":"configuring_parameters/#examples","text":"Example showing how to pass constant values to these parameters Example showing how to pass one of the methods available in the package as a string or a custom function to these parameters","title":"Examples"},{"location":"configuring_parameters/#delay-parameters","text":"node_setup_time , inter_arrival_time and processing_delay are one of the two delay paramaters that can be configured. node_setup_time is an intial one time delay for setting up any node. inter_arrival_time is the time interval between two successive item generation in the source and processing_delay is the time incurres by an item to get processed in components like machine, split, joint, etc. node_setup_time can be an int or a float and is a constant value. The parameters inter_arrival_time and processing_delay can be specified as a constant value ( int or float ) or as a reference to a python function or a generator function instance that generates random variates from a chosen distribution. If the function depends on any of the node attributes, users can pass None to this parameter at the time of node creation and later initialise the parameter with the reference to the function.","title":"Delay parameters"},{"location":"configuring_parameters/#examples_1","text":"Example showing how to pass constant values to these parameters Example showing how to pass a custom function or generator function instance to these parameters","title":"Examples"},{"location":"constructs/","text":"Constructs \u00b6 About Constructs in FactorySimPy are utility functions that help you quickly build common network topologies of nodes and edges, such as chains of machines with buffers, or more complex arrangements. They automate the instantiation and connection of nodes (like sources, machines, sinks) and edges (like buffers), reducing boilerplate code and making your simulation scripts more concise and less error-prone. Key Functions connect_chain : Creates a chain of nodes (e.g., machines) and edges (e.g., buffers). connect_chain_with_source_sink : Extends connect_chain by adding a source node at the beginning and a sink node at the end. connect_nodes_with_buffers : Connects a list of machines and buffers in sequence, optionally including a source and sink. Usage Example Suppose you want to create a simple production line: Source \u2192 Buffer1 \u2192 Machine1 \u2192 Buffer2 \u2192 Machine2 \u2192 Buffer3 \u2192 Sink You can do this easily with constructs: import simpy from factorysimpy.nodes.machine import Machine from factorysimpy.edges.buffer import Buffer from factorysimpy.nodes.source import Source from factorysimpy.nodes.sink import Sink from factorysimpy.constructs.chain import connect_chain_with_source_sink env = simpy . Environment () # Define parameters for each component source_kwargs = { \"inter_arrival_time\" : 1.0 , \"blocking\" : True } node_kwargs = { \"work_capacity\" : 1 , \"processing_delay\" : 2.0 , \"in_edge_selection\" : \"FIRST\" , \"out_edge_selection\" : \"FIRST\" } edge_kwargs = { \"store_capacity\" : 5 , \"delay\" : 0.5 , \"mode\" : \"FIFO\" } sink_kwargs = {} # Create a chain with 2 machines, 3 buffers, a source, and a sink nodes , edges , src , sink = connect_chain_with_source_sink ( env , count = 2 , node_cls = Machine , edge_cls = Buffer , source_cls = Source , sink_cls = Sink , node_kwargs = node_kwargs , edge_kwargs = edge_kwargs , source_kwargs = source_kwargs , sink_kwargs = sink_kwargs ) machines , buffers = connect_nodes_with_buffers ( machines , buffers , src , sink ) # Now, nodes and edges are connected in order and connected: # src -> edges[0] -> nodes[1] -> edges[1] -> nodes[2] -> edges[2] -> sink env . run ( until = 20 ) Custom Connections If you want to connect a list of machines and buffers you created yourself, use connect_nodes_with_buffers : machines = [ Machine ( env , id = f \"M { i } \" , ** node_kwargs ) for i in range ( 2 )] buffers = [ Buffer ( env , id = f \"BUF { i } \" , ** edge_kwargs ) for i in range ( 3 )] src = Source ( env , id = \"SRC\" , ** source_kwargs ) sink = Sink ( env , id = \"SINK\" , ** sink_kwargs ) # Connect: src -> BUF0 -> M0 -> BUF1 -> M1 -> BUF2 -> sink machines , buffers = connect_nodes_with_buffers ( machines , buffers , src , sink ) Example A simple example with constructs","title":"Constructs for Modeling"},{"location":"constructs/#constructs","text":"About Constructs in FactorySimPy are utility functions that help you quickly build common network topologies of nodes and edges, such as chains of machines with buffers, or more complex arrangements. They automate the instantiation and connection of nodes (like sources, machines, sinks) and edges (like buffers), reducing boilerplate code and making your simulation scripts more concise and less error-prone. Key Functions connect_chain : Creates a chain of nodes (e.g., machines) and edges (e.g., buffers). connect_chain_with_source_sink : Extends connect_chain by adding a source node at the beginning and a sink node at the end. connect_nodes_with_buffers : Connects a list of machines and buffers in sequence, optionally including a source and sink. Usage Example Suppose you want to create a simple production line: Source \u2192 Buffer1 \u2192 Machine1 \u2192 Buffer2 \u2192 Machine2 \u2192 Buffer3 \u2192 Sink You can do this easily with constructs: import simpy from factorysimpy.nodes.machine import Machine from factorysimpy.edges.buffer import Buffer from factorysimpy.nodes.source import Source from factorysimpy.nodes.sink import Sink from factorysimpy.constructs.chain import connect_chain_with_source_sink env = simpy . Environment () # Define parameters for each component source_kwargs = { \"inter_arrival_time\" : 1.0 , \"blocking\" : True } node_kwargs = { \"work_capacity\" : 1 , \"processing_delay\" : 2.0 , \"in_edge_selection\" : \"FIRST\" , \"out_edge_selection\" : \"FIRST\" } edge_kwargs = { \"store_capacity\" : 5 , \"delay\" : 0.5 , \"mode\" : \"FIFO\" } sink_kwargs = {} # Create a chain with 2 machines, 3 buffers, a source, and a sink nodes , edges , src , sink = connect_chain_with_source_sink ( env , count = 2 , node_cls = Machine , edge_cls = Buffer , source_cls = Source , sink_cls = Sink , node_kwargs = node_kwargs , edge_kwargs = edge_kwargs , source_kwargs = source_kwargs , sink_kwargs = sink_kwargs ) machines , buffers = connect_nodes_with_buffers ( machines , buffers , src , sink ) # Now, nodes and edges are connected in order and connected: # src -> edges[0] -> nodes[1] -> edges[1] -> nodes[2] -> edges[2] -> sink env . run ( until = 20 ) Custom Connections If you want to connect a list of machines and buffers you created yourself, use connect_nodes_with_buffers : machines = [ Machine ( env , id = f \"M { i } \" , ** node_kwargs ) for i in range ( 2 )] buffers = [ Buffer ( env , id = f \"BUF { i } \" , ** edge_kwargs ) for i in range ( 3 )] src = Source ( env , id = \"SRC\" , ** source_kwargs ) sink = Sink ( env , id = \"SINK\" , ** sink_kwargs ) # Connect: src -> BUF0 -> M0 -> BUF1 -> M1 -> BUF2 -> sink machines , buffers = connect_nodes_with_buffers ( machines , buffers , src , sink ) Example A simple example with constructs","title":"Constructs"},{"location":"conveyor/","text":"ConveyorBelt ( env , id , capacity , delay , accumulating ) \u00b6 Bases: Edge A conveyor belt system with optional accumulation. Attributes: capacity ( int ) : Maximum capacity of the belt . state ( str ) : state of the conveyor belt . delay ( float ) : Time interval between two successive movements on the belt . accumulation ( bool ) : Whether the belt supports accumulation ( 1 for yes , 0 for no ) . is_empty () \u00b6 Check if the belt is completely empty. is_full () \u00b6 Check if the belt is full. can_get () \u00b6 Check if an item can be retrieved from the belt. is_stalled () \u00b6 Check if the belt is stalled due to time constraints. can_put () \u00b6 Check if an item can be added to the belt. put ( event , item ) \u00b6 Put an item into the belt. Parameters \u00b6 event : simpy.Event The event that was reserved for putting an item. item : Item The item to be put on the belt. Returns \u00b6 simpy.Event An event that will be triggered when the item is successfully put on the belt. get ( event ) \u00b6 Get an item from the belt. Parameters \u00b6 event : simpy.Event The event that was reserved for getting an item. Returns \u00b6 Item The item retrieved from the belt. set_conveyor_state ( new_state ) \u00b6 Set the conveyor state and manage belt store interrupts/resumes. Parameters: new_state ( str ) \u2013 The new conveyor state","title":"Conveyor"},{"location":"conveyor/#factorysimpy.edges.slotted_conveyor.ConveyorBelt","text":"Bases: Edge A conveyor belt system with optional accumulation. Attributes: capacity ( int ) : Maximum capacity of the belt . state ( str ) : state of the conveyor belt . delay ( float ) : Time interval between two successive movements on the belt . accumulation ( bool ) : Whether the belt supports accumulation ( 1 for yes , 0 for no ) .","title":"ConveyorBelt"},{"location":"conveyor/#factorysimpy.edges.slotted_conveyor.ConveyorBelt.is_empty","text":"Check if the belt is completely empty.","title":"is_empty"},{"location":"conveyor/#factorysimpy.edges.slotted_conveyor.ConveyorBelt.is_full","text":"Check if the belt is full.","title":"is_full"},{"location":"conveyor/#factorysimpy.edges.slotted_conveyor.ConveyorBelt.can_get","text":"Check if an item can be retrieved from the belt.","title":"can_get"},{"location":"conveyor/#factorysimpy.edges.slotted_conveyor.ConveyorBelt.is_stalled","text":"Check if the belt is stalled due to time constraints.","title":"is_stalled"},{"location":"conveyor/#factorysimpy.edges.slotted_conveyor.ConveyorBelt.can_put","text":"Check if an item can be added to the belt.","title":"can_put"},{"location":"conveyor/#factorysimpy.edges.slotted_conveyor.ConveyorBelt.put","text":"Put an item into the belt.","title":"put"},{"location":"conveyor/#factorysimpy.edges.slotted_conveyor.ConveyorBelt.put--parameters","text":"event : simpy.Event The event that was reserved for putting an item. item : Item The item to be put on the belt.","title":"Parameters"},{"location":"conveyor/#factorysimpy.edges.slotted_conveyor.ConveyorBelt.put--returns","text":"simpy.Event An event that will be triggered when the item is successfully put on the belt.","title":"Returns"},{"location":"conveyor/#factorysimpy.edges.slotted_conveyor.ConveyorBelt.get","text":"Get an item from the belt.","title":"get"},{"location":"conveyor/#factorysimpy.edges.slotted_conveyor.ConveyorBelt.get--parameters","text":"event : simpy.Event The event that was reserved for getting an item.","title":"Parameters"},{"location":"conveyor/#factorysimpy.edges.slotted_conveyor.ConveyorBelt.get--returns","text":"Item The item retrieved from the belt.","title":"Returns"},{"location":"conveyor/#factorysimpy.edges.slotted_conveyor.ConveyorBelt.set_conveyor_state","text":"Set the conveyor state and manage belt store interrupts/resumes. Parameters: new_state ( str ) \u2013 The new conveyor state","title":"set_conveyor_state"},{"location":"edges/","text":"Edge ( env , id , capacity ) \u00b6 Edge represents the passive components. It used to connect two nodes and helps to move items between them. It is the base class used to model buffers, conveyors, fleets, etc in manufacturing system. Parameters: id ( str ) \u2013 unique identifier for the edge src_node ( Node ) \u2013 reference to the source node connected to this edge. dest_node ( Node ) \u2013 reference to the destination node connected to this edge. Raises: TypeError \u2013 If the type of env or id is incorrect. ValueError \u2013 If the delay parameter is not a valid type (int, float, generator, or callable). ValueError \u2013 If the edge is already connected to a source or destination node and reconnect is False. ValueError \u2013 If the source or destination nodes are not valid Node instances. get_delay ( delay ) \u00b6 Returns value based on the type of parameter delay provided. Parameters: delay ( int, float, generator, or callable ) \u2013 The delay time, which can be: int or float: Used as a constant delay. generator: A generator instance yielding delay values. callable: A function that returns a delay values. Returns: \u2013 Returns a constant delay if delay is an int or float, a value yielded if delay is a generator, or the value returned from a Callable function if delay is callable. update_state ( new_state , current_time ) \u00b6 Update node state and track the time spent in the previous state. Parameters: new_state ( str ) \u2013 The new state to transition to. Must be one of \"SETUP_STATE\", \"GENERATING_STATE\", \"BLOCKED_STATE\". current_time ( float ) \u2013 The current simulation time. connect ( src , dest , reconnect = False ) \u00b6 Connects this edge to a source node and a destination node. This method checks that both src and dest are valid Node objects and that the edge is not already connected, unless reconnect is set to True. It also registers this edge in the out_edges of the source node and the in_edges of the destination node. Parameters: src ( Node ) \u2013 The source node to connect. dest ( Node ) \u2013 The destination node to connect. reconnect ( bool , default: False ) \u2013 If True, allows reconnection even if the edge is already connected. Defaults to False. Raises: ValueError \u2013 If the edge is already connected and reconnect is False. ValueError \u2013 If src or dest is not a valid Node instance.","title":"Edges"},{"location":"edges/#factorysimpy.edges.edge.Edge","text":"Edge represents the passive components. It used to connect two nodes and helps to move items between them. It is the base class used to model buffers, conveyors, fleets, etc in manufacturing system. Parameters: id ( str ) \u2013 unique identifier for the edge src_node ( Node ) \u2013 reference to the source node connected to this edge. dest_node ( Node ) \u2013 reference to the destination node connected to this edge. Raises: TypeError \u2013 If the type of env or id is incorrect. ValueError \u2013 If the delay parameter is not a valid type (int, float, generator, or callable). ValueError \u2013 If the edge is already connected to a source or destination node and reconnect is False. ValueError \u2013 If the source or destination nodes are not valid Node instances.","title":"Edge"},{"location":"edges/#factorysimpy.edges.edge.Edge.get_delay","text":"Returns value based on the type of parameter delay provided. Parameters: delay ( int, float, generator, or callable ) \u2013 The delay time, which can be: int or float: Used as a constant delay. generator: A generator instance yielding delay values. callable: A function that returns a delay values. Returns: \u2013 Returns a constant delay if delay is an int or float, a value yielded if delay is a generator, or the value returned from a Callable function if delay is callable.","title":"get_delay"},{"location":"edges/#factorysimpy.edges.edge.Edge.update_state","text":"Update node state and track the time spent in the previous state. Parameters: new_state ( str ) \u2013 The new state to transition to. Must be one of \"SETUP_STATE\", \"GENERATING_STATE\", \"BLOCKED_STATE\". current_time ( float ) \u2013 The current simulation time.","title":"update_state"},{"location":"edges/#factorysimpy.edges.edge.Edge.connect","text":"Connects this edge to a source node and a destination node. This method checks that both src and dest are valid Node objects and that the edge is not already connected, unless reconnect is set to True. It also registers this edge in the out_edges of the source node and the in_edges of the destination node. Parameters: src ( Node ) \u2013 The source node to connect. dest ( Node ) \u2013 The destination node to connect. reconnect ( bool , default: False ) \u2013 If True, allows reconnection even if the edge is already connected. Defaults to False. Raises: ValueError \u2013 If the edge is already connected and reconnect is False. ValueError \u2013 If src or dest is not a valid Node instance.","title":"connect"},{"location":"examples/","text":"Examples \u00b6 In this section, we present examples that demonstrate how to use FactorySimPy A simple example \u00b6 Here's a simple example to connect a machine to an input buffer and output buffer and to simulate item flow through them. Shown below is a very simple example. Here, the delays to be configured are inter_arrival_time , and processing_delay of the source and the machine respectively. In this example, the delays inter_arrival_time , and processing_delay , are specified as constant values at the time of node initiation. Similarly in_edge_selection and out_edge_selection can also be provided as a constant or use one of the generator functions available in the package. These functions can be passed as a string. See this page for details about edge selection policy. # System layout # SRC \u2500\u2500> BUF1 \u2500\u2500> MACHINE1 \u2500\u2500> BUF2 \u2500\u2500> SINK import factorysimpy from factorysimpy.nodes.machine import Machine from factorysimpy.edges.buffer import Buffer from factorysimpy.nodes.source import Source from factorysimpy.nodes.sink import Sink env = simpy . Environment () # Initializing nodes SRC = Source ( env , id = \"SRC\" , inter_arrival_time = 0.8 , blocking = False , out_edge_selection = 0 ) MACHINE1 = Machine ( env , id = \"MACHINE1\" , work_capacity = 4 , processing_delay = 1.1 , in_edge_selection = 0 , out_edge_selection = \"RANDOM\" ) SINK = Sink ( env , id = \"SINK\" ) # Initializing edges BUF1 = Buffer ( env , id = \"BUF1\" , store_capacity = 4 , delay = 0.5 , mode = \"FIFO\" ) BUF2 = Buffer ( env , id = \"BUF2\" , store_capacity = 4 , delay = 0.5 , mode = \"FIFO\" ) # Adding connections BUF1 . connect ( SRC , MACHINE1 ) BUF2 . connect ( MACHINE1 , SINK ) env . run ( until = 10 ) A simple example with fleet \u00b6 Here's a simple example for fleet Shown below is a very simple example. Here, the delays to be configured are inter_arrival_time , and processing_delay of the source and the machine respectively. In this example, the delays inter_arrival_time , and processing_delay , are specified as constant values at the time of node initiation. Similarly in_edge_selection and out_edge_selection can also be provided as a constant or use one of the generator functions available in the package. These functions can be passed as a string. See this page for details about edge selection policy. # System layout # SRC \u2500\u2500> FLEET1 \u2500\u2500> MACHINE1 \u2500\u2500> BUF2 \u2500\u2500> SINK import factorysimpy from factorysimpy.nodes.machine import Machine from factorysimpy.edges.buffer import Buffer from factorysimpy.edges.fleet import Fleet from factorysimpy.nodes.source import Source from factorysimpy.nodes.sink import Sink env = simpy . Environment () # Initializing nodes SRC = Source ( env , id = \"SRC\" , inter_arrival_time = 0.2 , blocking = True , out_edge_selection = 0 ) #src= Source(env, id=\"Source-1\", inter_arrival_time=0.2,blocking=True,out_edge_selection=0 ) MACHINE1 = Machine ( env , id = \"MACHINE1\" , node_setup_time = 0 , work_capacity = 1 , blocking = True , processing_delay = 0.5 , in_edge_selection = 0 , out_edge_selection = \"ROUND_ROBIN\" ) SINK = Sink ( env , id = \"SINK\" ) # Initializing edges FLEET1 = Fleet ( env , id = \"FLEET1\" , capacity = 3 , delay = 1 , transit_delay = 1.4 ) BUFFER2 = Buffer ( env , id = \"BUFFER2\" , capacity = 5 , delay = 0 , mode = \"FIFO\" ) # Adding connections FLEET1 . connect ( SRC , MACHINE1 ) BUFFER2 . connect ( MACHINE1 , SINK ) time = 10 env . run ( until = time ) A simple example with slotted type conveyor \u00b6 Here's a simple example of conveyorbelt from factorysimpy.nodes.machine import Machine from factorysimpy.edges.slotted_conveyor import ConveyorBelt from factorysimpy.edges.buffer import Buffer from factorysimpy.nodes.source import Source from factorysimpy.nodes.sink import Sink import random #SRC \u2500\u2500> CONVEYORBELT1 \u2500\u2500> MACHINE1 \u2500\u2500\u2500> BUF2 \u2500\u2500>SINK env = simpy . Environment () # Initializing nodes SRC = Source ( env , id = \"SRC\" , inter_arrival_time = 0.3 , blocking = True , out_edge_selection = \"FIRST_AVAILABLE\" ) #src= Source(env, id=\"Source-1\", inter_arrival_time=0.2,blocking=True,out_edge_selection=0 ) MACHINE1 = Machine ( env , id = \"MACHINE1\" , node_setup_time = 0 , work_capacity = 1 , blocking = True , processing_delay = 0.7 , in_edge_selection = \"FIRST_AVAILABLE\" , out_edge_selection = \"ROUND_ROBIN\" ) SINK = Sink ( env , id = \"SINK\" ) # Initializing edges BUFFER1 = Buffer ( env , id = \"BUFFER1\" , capacity = 1 , delay = 0 , mode = \"FIFO\" ) CONVEYORBELT1 = ConveyorBelt ( env , id = \"CONVEYORBELT1\" , capacity = 5 , delay = 1 , accumulating = True ) # Adding connections CONVEYORBELT1 . connect ( SRC , MACHINE1 ) BUFFER1 . connect ( MACHINE1 , SINK ) time = 100 env . run ( until = time ) A simple example with continuous type conveyor \u00b6 Here's a simple example of conveyorbelt from factorysimpy.nodes.machine import Machine from factorysimpy.edges.continuous_conveyor import ConveyorBelt from factorysimpy.edges.buffer import Buffer from factorysimpy.nodes.source import Source from factorysimpy.nodes.sink import Sink import random #SRC \u2500\u2500> CONVEYORBELT1 \u2500\u2500> MACHINE1 \u2500\u2500\u2500> BUF2 \u2500\u2500>SINK env = simpy . Environment () # Initializing nodes SRC = Source ( env , id = \"SRC\" , inter_arrival_time = 0.3 , blocking = True , out_edge_selection = \"FIRST_AVAILABLE\" ) #src= Source(env, id=\"Source-1\", inter_arrival_time=0.2,blocking=True,out_edge_selection=0 ) MACHINE1 = Machine ( env , id = \"MACHINE1\" , node_setup_time = 0 , work_capacity = 1 , blocking = True , processing_delay = 0.7 , in_edge_selection = \"FIRST_AVAILABLE\" , out_edge_selection = \"ROUND_ROBIN\" ) SINK = Sink ( env , id = \"SINK\" ) # Initializing edges BUFFER1 = Buffer ( env , id = \"BUFFER1\" , capacity = 1 , delay = 0 , mode = \"FIFO\" ) CONVEYORBELT1 = ConveyorBelt ( env , id = \"CONVEYORBELT1\" , capacity = 5 , speed = 1 , length = 1 , accumulating = True ) # Adding connections CONVEYORBELT1 . connect ( SRC , MACHINE1 ) BUFFER1 . connect ( MACHINE1 , SINK ) time = 100 env . run ( until = time ) Example with delay as a reference to a function \u00b6 Shown below is a very simple example where the source generates items and puts it to a machine through a buffer and the items processed in machine is moved to a sink using another buffer. This example shows how to pass a function as a parameter. Delay as python function \u00b6 An example showing how to pass python functions as delay parameters. In this example, the delays to be configured are inter_arrival_time , and processing_delay of source and machine. These are specified as a reference to a python function. Let the inter arrival time of the source be a value sampled from a gaussian distribution with mean = 1, std deviation is = 0.25 and the processing delay of the machine be a value function of the duration of the time spent by the machine in processing state. # System layout # SRC \u2500\u2500> BUF1 \u2500\u2500> MACHINE1 \u2500\u2500> BUF2 \u2500\u2500> SINK import random import factorysimpy from factorysimpy.nodes.machine import Machine from factorysimpy.edges.buffer import Buffer from factorysimpy.nodes.source import Source from factorysimpy.nodes.sink import Sink env = simpy . Environment () env = simpy . Environment () #let the inter arrival time of the source be a value sampled from a gaussian distribution with mean = 1, std deviation is = 0.25 #Gaussian distribution as a python function def generate_gaussian_distribution (): return random . gauss ( mu = 1 , sigma = 0.25 ) #let the processing delay of the machine be a value function of the duration of the time spent by the machine in processing state #if the time spent in processing state is greater than 7, the processing delay has to take one value in index 0 of the return_vals #if the time spent in processing state is less than or equal to 7, the processing delay has to take the value in index 1 #This behaviour as a python function def generate_process_delay (): return_vals = [ 0.9 , 1.2 ] if node . stats [ \"total_time_spent_in_states\" ][ \"PROCESSING_STATE\" ] > 7 : return return_vals [ 0 ] else : return return_vals [ 1 ] # Initializing nodes SRC = Source ( env , id = \"SRC\" , inter_arrival_time = generate_gaussian_distribution , blocking = False , out_edge_selection = 0 ) MACHINE1 = Machine ( env , id = \"MACHINE1\" , work_capacity = 1 , processing_delay = generate_process_delay , in_edge_selection = \"RANDOM\" , out_edge_selection = \"RANDOM\" ) SINK = Sink ( env , id = \"SINK\" ) # Initializing edges BUF1 = Buffer ( env , id = \"BUF1\" , store_capacity = 4 , delay = 0.5 ) BUF2 = Buffer ( env , id = \"BUF2\" , store_capacity = 4 , delay = 0.5 ) # Adding connections BUF1 . connect ( SRC , MACHINE1 ) BUF2 . connect ( MACHINE1 , SINK ) env . run ( until = 10 ) Delay as generator function \u00b6 An example showing how to pass python generator functions as delay parameters. In this example (same as above), the delays to be configured are inter_arrival_time , and processing_delay of source and machine. These are specified as a reference to a python generator function instance. Let the inter arrival time of the source be a value sampled from a gaussian distribution with mean = 1, std deviation is = 0.25 and the processing delay of the machine be a value function of the duration of the time spent by the machine in processing state. Generator functions are created for the two cases and supplied as parameters. # System layout # SRC \u2500\u2500> BUF1 \u2500\u2500> MACHINE1 \u2500\u2500> BUF2 \u2500\u2500> SINK import random import factorysimpy from factorysimpy.nodes.machine import Machine from factorysimpy.edges.buffer import Buffer from factorysimpy.nodes.source import Source from factorysimpy.nodes.sink import Sink env = simpy . Environment () #let the inter arrival time of the source be a value sampled from a gaussian distribution with mean = 2, std deviation is = 0.5 #Gaussian distribution as a generator function def generate_gaussian_distribution (): while True : yield random . gauss ( mu = 2 , sigma = 0.5 ) #let the processing delay of the machine be a value function of the duration of the time spent by the machine in processing state #if the time spent in processing state is greater than 7, the processing delay has to take one value in index 0 of the return_vals #if the time spent in processing state is less than or equal to 7, the processing delay has to take the value in index 1 #This behaviour as a generator function def generate_process_delay ( node , env ): return_vals = [ 0.9 , 1.2 ] while True : if node . stats [ \"total_time_spent_in_states\" ][ \"PROCESSING_STATE\" ] > 7 : yield return_vals [ 0 ] else : yield return_vals [ 1 ] # Initializing nodes SRC = Source ( env , id = \"SRC\" , inter_arrival_time = generate_gaussian_distribution , blocking = False , out_edge_selection = 0 ) MACHINE1 = Machine ( env , id = \"MACHINE1\" , work_capacity = 1 , processing_delay = None , in_edge_selection = \"RANDOM\" , out_edge_selection = \"RANDOM\" ) processing_delay_func = generate_process_delay ( MACHINE1 , env ) MACHINE1 . processing_delay = processing_delay_func SINK = Sink ( env , id = \"SINK\" ) # Initializing edges BUF1 = Buffer ( env , id = \"BUF1\" , store_capacity = 4 , delay = 0.5 ) BUF2 = Buffer ( env , id = \"BUF2\" , store_capacity = 4 , delay = 0.5 ) # Adding connections BUF1 . connect ( SRC , MACHINE1 ) BUF2 . connect ( MACHINE1 , SINK ) env . run ( until = 10 ) Example with a custom edge selection policy as a function \u00b6 In the example below, there are multiple sources that generates items and puts it into their output buffers. The machine chooses one of its in_edges and picks an item and processes it and chooses an output edge and puts the item there. It choses the input edge and output edge based on the values yielded from function specified in in_edge_selection parameter and out_edge_selection parameter. Edge selection as python function \u00b6 An example that shows how to interconnect a source to a machine using buffers and pass a python function as parameter. Consider the case when the edge selection parameters are to be modelled as a python function. Here is an example that shows how to pass a python function instance as a parameter. Let us consider a case where the in_edge_selection is dependant on the values sampled from a uniform distribution [0,1], if the sampled value is less than 0.5, then always index 1 is returned and if the sampled value is greater than 0.5 then index 0 is returned. out_edge_selection is dependant on the values sampled from a gaussian distribution with mean 4 and standard deviation 1 , if the value is greater than 3, then edge 0 is selected otherwise edge 1 is selected. Edge selection parameters of SRC1, and all the SINKs are provided with options that are implemented within the package. See this page for details about edge selection policy. # System layout # SRC1 \u2500\u2500> BUFFER1 \u2500\u2500\u2510 # \u2502 # SRC2 \u2500\u2500> BUFFER2 \u2500\u2500\u2534\u2500> MACHINE1 \u2500\u2500\u252c\u2500> BUFFER3 \u2500\u2500> SINK1 # \u2502 \u2502 # \u2514\u2500> BUFFER5 \u2500\u2500> SINK3 \u2514\u2500> BUFFER4 \u2500\u2500> SINK2 # import random import factorysimpy from factorysimpy.nodes.machine import Machine from factorysimpy.edges.buffer import Buffer from factorysimpy.nodes.source import Source from factorysimpy.nodes.sink import Sink env = simpy . Environment () #let the in_edge_selection of the machine be a function that yields 1 or 0 based on the value sampled from uniform distribution [0,1] # This function will yield 1 if value 0.5, and 0 if it is otherwise. #in_edge_selection as a function for machine def machine_in_edge_selector (): if random . random () < 0.5 : return 1 else : return 0 #let the out_edge_selection of the machine be a function that yields the index of the edge to be selected # This function will yield the index of the edge to be selected based on the value sampled from a gaussian dostribution with mean=4 and sigma=1 # it will return 1 is the sampled value is >3, else it will return 0 #out_edge_selection as a function for machine def machine_out_edge_selector (): if random . gauss ( mu = 4 , sigma = 1 ) > 3 : return 1 else : return 0 #let the out_edge_selection of the source 2 be a generator function that yields 1 or 0 based on the current time # This generator function will yield 1 if the current time is even, and 0 if it is odd. #out_edge_selection as a function for source def source_out_edge_selector ( env ): if env . now % 2 == 0 : return 1 else : return 0 # Initializing nodes SRC1 = Source ( env , id = \"SRC1\" , inter_arrival_time = 0.7 , blocking = False , out_edge_selection = \"FIRST_AVAILABLE\" ) SRC2 = Source ( env , id = \"SRC2\" , inter_arrival_time = 0.4 , blocking = False , out_edge_selection = source_out_edge_selector ( env ) ) MACHINE1 = Machine ( env , id = \"MACHINE1\" , work_capacity = 4 , processing_delay = 1 , in_edge_selection = machine_in_edge_selector , out_edge_selection = machine_out_edge_selector ) SINK1 = Sink ( env , id = \"SINK1\" , in_edge_selection = \"RANDOM\" ) SINK2 = Sink ( env , id = \"SINK2\" , in_edge_selection = \"RANDOM\" ) SINK3 = Sink ( env , id = \"SINK3\" , in_edge_selection = \"FIRST_AVAILABLE\" ) # Initializing edges # Initializing edges BUF1 = Buffer ( env , id = \"BUF1\" , store_capacity = 4 , delay = 0.5 ) BUF2 = Buffer ( env , id = \"BUF2\" , store_capacity = 4 , delay = 0.5 ) BUF3 = Buffer ( env , id = \"BUF3\" , store_capacity = 4 , delay = 0.5 ) BUF4 = Buffer ( env , id = \"BUF4\" , store_capacity = 4 , delay = 0.5 ) BUF5 = Buffer ( env , id = \"BUF5\" , store_capacity = 4 , delay = 0.5 ) # Adding connections BUF1 . connect ( SRC1 , MACHINE1 ) BUF2 . connect ( SRC2 , MACHINE1 ) BUF3 . connect ( MACHINE1 , SINK1 ) BUF4 . connect ( MACHINE1 , SINK2 ) BUF5 . connect ( SRC2 , SINK3 ) env . run ( until = 10 ) Edge selection as generator function \u00b6 An example that shows how to interconnect a source to a machine using buffers and pass a python function or a generator instance as parameter. Consider the case when the edge selection parameters are to be modelled as a generator function that depends on the node object or the current time of the simulation environment. Here is an example that shows how to pass a generator function instance as a parameter. # System layout # SRC1 \u2500\u2500> BUFFER1 \u2500\u2500\u2510 # \u2502 # SRC2 \u2500\u2500> BUFFER2 \u2500\u2500\u2534\u2500> MACHINE1 \u2500\u2500\u252c\u2500> BUFFER3 \u2500\u2500> SINK1 # \u2502 \u2502 # \u2514\u2500> BUFFER5 \u2500\u2500> SINK3 \u2514\u2500> BUFFER4 \u2500\u2500> SINK2 # import factorysimpy from factorysimpy.nodes.machine import Machine from factorysimpy.edges.buffer import Buffer from factorysimpy.nodes.source import Source from factorysimpy.nodes.sink import Sink env = simpy . Environment () #let the out_edge_selection of the source be a generator function that yields 1 or 0 based on the current time # This generator function will yield 1 if the current time is even, and 0 if it is odd. # This will simulate a scenario where the source alternates between two output edges based on the time. #out_edge_selection as a generator function for machine def machine_out_edge_selector ( node , env ): while True : if env . now % 2 == 0 : yield 1 else : yield 0 #let the in_edge_selection of the machine be a generator function that yields the index of the edge to be selected # This generator function will yield the index of the edge to be selected based on the current time. # The index will be incremented every time the generator is called, and will wrap around when it reaches the number of edges. #in_edge_selection as a generator function for machine def machine_in_edge_selector ( node , env ): num_edges = len ( node . in_edges ) i = 0 while True : yield i yield i i = ( i + 1 ) % num_edges #let the out_edge_selection of the source be a generator function that yields 1 or 0 based on the current time # This generator function will yield 1 if the current time is even, and 0 if it is odd. #out_edge_selection as a generator function for source def source_out_edge_selector ( node , env ): while True : if env . now % 2 == 0 : yield 1 else : yield 0 # Initializing nodes SRC1 = Source ( env , id = \"SRC1\" , inter_arrival_time = 0.7 , blocking = False , out_edge_selection = \"FIRST_AVAILABLE\" ) SRC2 = Source ( env , id = \"SRC2\" , inter_arrival_time = 0.4 , blocking = False , out_edge_selection = None ) MACHINE1 = Machine ( env , id = \"MACHINE1\" , work_capacity = 4 , processing_delay = 1 , in_edge_selection = None , out_edge_selection = None ) SINK1 = Sink ( env , id = \"SINK1\" , in_edge_selection = \"RANDOM\" ) SINK2 = Sink ( env , id = \"SINK2\" , in_edge_selection = \"RANDOM\" ) SINK3 = Sink ( env , id = \"SINK3\" , in_edge_selection = \"FIRST_AVAILABLE\" ) #initialising out_edge_selection for source source_out_edge_func = source_out_edge_selector ( SRC2 , env ) SRC2 . out_edge_selection = source_out_edge_func #initialising in_edge_selection parameter machine_in_edge_func = machine_in_edge_selector ( MACHINE1 , env ) MACHINE1 . in_edge_selection = machine_in_edge_func #initialising in_edge_selection parameter for machine machine_out_edge_func = machine_out_edge_selector ( MACHINE1 , env ) MACHINE1 . out_edge_selection = machine_out_edge_func # Initializing edges # Initializing edges BUF1 = Buffer ( env , id = \"BUF1\" , store_capacity = 4 , delay = 0.5 ) BUF2 = Buffer ( env , id = \"BUF2\" , store_capacity = 4 , delay = 0.5 ) BUF3 = Buffer ( env , id = \"BUF3\" , store_capacity = 4 , delay = 0.5 ) BUF4 = Buffer ( env , id = \"BUF4\" , store_capacity = 4 , delay = 0.5 ) BUF5 = Buffer ( env , id = \"BUF5\" , store_capacity = 4 , delay = 0.5 ) # Adding connections BUF1 . connect ( SRC1 , MACHINE1 ) BUF2 . connect ( SRC2 , MACHINE1 ) BUF3 . connect ( MACHINE1 , SINK1 ) BUF4 . connect ( MACHINE1 , SINK2 ) BUF5 . connect ( SRC2 , SINK3 ) env . run ( until = 10 ) Example to illustrate the use of the components splitter and combiner \u00b6 An example to understand how to simulate packing and unpacking of items using SPLITTER and COMBINER Consider a system which has to pack 5 base items of flow_item_type =\"item\" in to an entity of flow_item_type =\"pallet\". And in the same example the method to unpack these packed items using a SPLITTER is also shown. There are two sources, SRC1 (producing \"items\") and SRC2 (producing \"pallets\"). These flow items are combined inside combiner and are pushed to a buffer. Splitter takes the items from the combiner and splits it into items and pallets and pushes it into sinks. Out_edge_selection of the splitter is a generator function that depends on the type of the item. It chooses index 0, incase the flow item is of type \"item\" and 1 if it is type \"pallet\". # System layout # SRC1 \u2500\u2500> BUFFER1 \u2500\u2500\u2510 # \u2502 # SRC2 \u2500\u2500> BUFFER2 \u2500\u2500\u2534\u2500> COMBINER1 \u2500\u2500> BUFFER3 \u2500\u2500>SPLITTER1 \u2500\u2500\u252c\u2500> BUFFER4 \u2500\u2500> SINK1 # \u2502 # \u2514\u2500> BUFFER5 \u2500\u2500> SINK2 # import factorysimpy from factorysimpy.nodes.machine import Machine from factorysimpy.edges.buffer import Buffer from factorysimpy.nodes.source import Source from factorysimpy.nodes.sink import Sink from factorysimpy.nodes.combiner import Combiner from factorysimpy.nodes.splitter import Splitter env = simpy . Environment () #generator function for out edge selection of splitter def splitter_out_edge_selector ( node ): while True : proc = node . env . active_process item_in_process = proc . item_to_put if item_in_process is None : raise RuntimeError ( \"Unknown calling process\" ) if item_in_process . flow_item_type == \"item\" : yield 0 elif item_in_process . flow_item_type == \"pallet\" and len ( item_in_process . items ) == 0 : yield 1 else : raise ValueError ( \"Invalid item_type encountered\" ) # Initializing nodes SRC1 = Source ( env , id = \"SRC1\" , flow_item_type = \"pallet\" , inter_arrival_time = 0.8 , blocking = False , out_edge_selection = \"RANDOM\" ) SRC2 = Source ( env , id = \"SRC2\" , flow_item_type = \"item\" , inter_arrival_time = 0.8 , blocking = False , out_edge_selection = \"RANDOM\" ) COMBINER1 = Combiner ( env , id = \"COMBINER1\" , target_quantity_of_each_item = [ 1 , 5 ], processing_delay = 1.1 , blocking = False , out_edge_selection = \"RANDOM\" ) SPLITTER1 = Splitter ( env , id = \"SPLITTER1\" , processing_delay = 1.1 , in_edge_selection = \"RANDOM\" , out_edge_selection = None ) SINK1 = Sink ( env , id = \"SINK1\" ) SINK2 = Sink ( env , id = \"SINK2\" ) #initialising in_edge_selection parameter for SPLITTER splitter_out_edge_func = splitter_out_edge_selector ( SPLITTER1 ) splitter . out_edge_selection = splitter_out_edge_func # Initializing edges BUF1 = Buffer ( env , id = \"BUF1\" , store_capacity = 2 , delay = 0.5 , mode = \"FIFO\" ) BUF2 = Buffer ( env , id = \"BUF2\" , store_capacity = 2 , delay = 0.5 , mode = \"FIFO\" ) BUF3 = Buffer ( env , id = \"BUF3\" , store_capacity = 2 , delay = 0.5 , mode = \"FIFO\" ) BUF4 = Buffer ( env , id = \"BUF4\" , store_capacity = 2 , delay = 0 , mode = \"FIFO\" ) BUF5 = Buffer ( env , id = \"BUF5\" , store_capacity = 2 , delay = 0 , mode = \"FIFO\" ) # Adding connections BUF1 . connect ( SRC1 , COMBINER1 ) BUF2 . connect ( SRC2 , COMBINER1 ) BUF3 . connect ( COMBINER1 , SPLITTER1 ) BUF4 . connect ( SPLITTER1 , SINK1 ) BUF5 . connect ( SPLITTER1 , SINK2 ) env . run ( until = 10 ) Example with constructs \u00b6 Here's an example that shows the utility of the constructs Suppose you want to model an assembly line with 20 machines connected in series, each separated by a buffer. Manually creating and connecting each machine and buffer would be repetitive, error-prone, and require a lot of code. To simplify this process for large, homogeneous systems, FactorySimPy provides constructs that automate the creation and connection of such chains. # System layout # SRC \u2500\u2500> BUF1 \u2500\u2500> MACHINE1 \u2500\u2500> BUF2 \u2500\u2500> MACHINE2 \u2500\u2500> # \u2500\u2500> BUF3 \u2500\u2500> MACHINE3 \u2500\u2500> BUF4 \u2500\u2500> MACHINE4 \u2500\u2500> ... # . . . . # . . . . # ... BUF19 \u2500\u2500> MACHINE19 \u2500\u2500> BUF20 \u2500\u2500> MACHINE20 \u2500\u2500> SINK # (20 machines in series, each separated by a buffer) import factorysimpy from factorysimpy.nodes.machine import Machine from factorysimpy.edges.buffer import Buffer from factorysimpy.nodes.source import Source from factorysimpy.nodes.sink import Sink from factorysimpy.constructs.chain import connect_chain_with_source_sink , connect_nodes_with_buffers env = simpy . Environment () node_kwargs = { \"node_setup_time\" : 0 , \"work_capacity\" : 1 , \"processing_delay\" : 0.8 , \"in_edge_selection\" : \"RANDOM\" , \"out_edge_selection\" : \"FIRST_AVAILABLE\" } edge_kwargs = { \"store_capacity\" : 4 , \"delay\" : 0 , \"mode\" : \"LIFO\" } source_kwargs = { \"inter_arrival_time\" : 1 , \"blocking\" : True , \"out_edge_selection\" : \"FIRST_AVAILABLE\" } sink_kwargs = { \"id\" : \"Sink-1\" } # Example for a chain of 1 machine (count=1) nodes , edges , src , sink = connect_chain_with_source_sink ( env , count = 20 , node_cls = Machine , edge_cls = Buffer , source_cls = Source , sink_cls = Sink , node_kwargs = node_kwargs , edge_kwargs = edge_kwargs , source_kwargs = source_kwargs , sink_kwargs = sink_kwargs , prefix = \"Machine\" , edge_prefix = \"Buffer\" ) machines , buffers = connect_nodes_with_buffers ( nodes , edges , src , sink ) env . run ( until = 100 )","title":"Examples"},{"location":"examples/#examples","text":"In this section, we present examples that demonstrate how to use FactorySimPy","title":"Examples"},{"location":"examples/#a-simple-example","text":"Here's a simple example to connect a machine to an input buffer and output buffer and to simulate item flow through them. Shown below is a very simple example. Here, the delays to be configured are inter_arrival_time , and processing_delay of the source and the machine respectively. In this example, the delays inter_arrival_time , and processing_delay , are specified as constant values at the time of node initiation. Similarly in_edge_selection and out_edge_selection can also be provided as a constant or use one of the generator functions available in the package. These functions can be passed as a string. See this page for details about edge selection policy. # System layout # SRC \u2500\u2500> BUF1 \u2500\u2500> MACHINE1 \u2500\u2500> BUF2 \u2500\u2500> SINK import factorysimpy from factorysimpy.nodes.machine import Machine from factorysimpy.edges.buffer import Buffer from factorysimpy.nodes.source import Source from factorysimpy.nodes.sink import Sink env = simpy . Environment () # Initializing nodes SRC = Source ( env , id = \"SRC\" , inter_arrival_time = 0.8 , blocking = False , out_edge_selection = 0 ) MACHINE1 = Machine ( env , id = \"MACHINE1\" , work_capacity = 4 , processing_delay = 1.1 , in_edge_selection = 0 , out_edge_selection = \"RANDOM\" ) SINK = Sink ( env , id = \"SINK\" ) # Initializing edges BUF1 = Buffer ( env , id = \"BUF1\" , store_capacity = 4 , delay = 0.5 , mode = \"FIFO\" ) BUF2 = Buffer ( env , id = \"BUF2\" , store_capacity = 4 , delay = 0.5 , mode = \"FIFO\" ) # Adding connections BUF1 . connect ( SRC , MACHINE1 ) BUF2 . connect ( MACHINE1 , SINK ) env . run ( until = 10 )","title":"A simple example"},{"location":"examples/#a-simple-example-with-fleet","text":"Here's a simple example for fleet Shown below is a very simple example. Here, the delays to be configured are inter_arrival_time , and processing_delay of the source and the machine respectively. In this example, the delays inter_arrival_time , and processing_delay , are specified as constant values at the time of node initiation. Similarly in_edge_selection and out_edge_selection can also be provided as a constant or use one of the generator functions available in the package. These functions can be passed as a string. See this page for details about edge selection policy. # System layout # SRC \u2500\u2500> FLEET1 \u2500\u2500> MACHINE1 \u2500\u2500> BUF2 \u2500\u2500> SINK import factorysimpy from factorysimpy.nodes.machine import Machine from factorysimpy.edges.buffer import Buffer from factorysimpy.edges.fleet import Fleet from factorysimpy.nodes.source import Source from factorysimpy.nodes.sink import Sink env = simpy . Environment () # Initializing nodes SRC = Source ( env , id = \"SRC\" , inter_arrival_time = 0.2 , blocking = True , out_edge_selection = 0 ) #src= Source(env, id=\"Source-1\", inter_arrival_time=0.2,blocking=True,out_edge_selection=0 ) MACHINE1 = Machine ( env , id = \"MACHINE1\" , node_setup_time = 0 , work_capacity = 1 , blocking = True , processing_delay = 0.5 , in_edge_selection = 0 , out_edge_selection = \"ROUND_ROBIN\" ) SINK = Sink ( env , id = \"SINK\" ) # Initializing edges FLEET1 = Fleet ( env , id = \"FLEET1\" , capacity = 3 , delay = 1 , transit_delay = 1.4 ) BUFFER2 = Buffer ( env , id = \"BUFFER2\" , capacity = 5 , delay = 0 , mode = \"FIFO\" ) # Adding connections FLEET1 . connect ( SRC , MACHINE1 ) BUFFER2 . connect ( MACHINE1 , SINK ) time = 10 env . run ( until = time )","title":"A simple example with fleet"},{"location":"examples/#a-simple-example-with-slotted-type-conveyor","text":"Here's a simple example of conveyorbelt from factorysimpy.nodes.machine import Machine from factorysimpy.edges.slotted_conveyor import ConveyorBelt from factorysimpy.edges.buffer import Buffer from factorysimpy.nodes.source import Source from factorysimpy.nodes.sink import Sink import random #SRC \u2500\u2500> CONVEYORBELT1 \u2500\u2500> MACHINE1 \u2500\u2500\u2500> BUF2 \u2500\u2500>SINK env = simpy . Environment () # Initializing nodes SRC = Source ( env , id = \"SRC\" , inter_arrival_time = 0.3 , blocking = True , out_edge_selection = \"FIRST_AVAILABLE\" ) #src= Source(env, id=\"Source-1\", inter_arrival_time=0.2,blocking=True,out_edge_selection=0 ) MACHINE1 = Machine ( env , id = \"MACHINE1\" , node_setup_time = 0 , work_capacity = 1 , blocking = True , processing_delay = 0.7 , in_edge_selection = \"FIRST_AVAILABLE\" , out_edge_selection = \"ROUND_ROBIN\" ) SINK = Sink ( env , id = \"SINK\" ) # Initializing edges BUFFER1 = Buffer ( env , id = \"BUFFER1\" , capacity = 1 , delay = 0 , mode = \"FIFO\" ) CONVEYORBELT1 = ConveyorBelt ( env , id = \"CONVEYORBELT1\" , capacity = 5 , delay = 1 , accumulating = True ) # Adding connections CONVEYORBELT1 . connect ( SRC , MACHINE1 ) BUFFER1 . connect ( MACHINE1 , SINK ) time = 100 env . run ( until = time )","title":"A simple example with slotted type conveyor"},{"location":"examples/#a-simple-example-with-continuous-type-conveyor","text":"Here's a simple example of conveyorbelt from factorysimpy.nodes.machine import Machine from factorysimpy.edges.continuous_conveyor import ConveyorBelt from factorysimpy.edges.buffer import Buffer from factorysimpy.nodes.source import Source from factorysimpy.nodes.sink import Sink import random #SRC \u2500\u2500> CONVEYORBELT1 \u2500\u2500> MACHINE1 \u2500\u2500\u2500> BUF2 \u2500\u2500>SINK env = simpy . Environment () # Initializing nodes SRC = Source ( env , id = \"SRC\" , inter_arrival_time = 0.3 , blocking = True , out_edge_selection = \"FIRST_AVAILABLE\" ) #src= Source(env, id=\"Source-1\", inter_arrival_time=0.2,blocking=True,out_edge_selection=0 ) MACHINE1 = Machine ( env , id = \"MACHINE1\" , node_setup_time = 0 , work_capacity = 1 , blocking = True , processing_delay = 0.7 , in_edge_selection = \"FIRST_AVAILABLE\" , out_edge_selection = \"ROUND_ROBIN\" ) SINK = Sink ( env , id = \"SINK\" ) # Initializing edges BUFFER1 = Buffer ( env , id = \"BUFFER1\" , capacity = 1 , delay = 0 , mode = \"FIFO\" ) CONVEYORBELT1 = ConveyorBelt ( env , id = \"CONVEYORBELT1\" , capacity = 5 , speed = 1 , length = 1 , accumulating = True ) # Adding connections CONVEYORBELT1 . connect ( SRC , MACHINE1 ) BUFFER1 . connect ( MACHINE1 , SINK ) time = 100 env . run ( until = time )","title":"A simple example with continuous type conveyor"},{"location":"examples/#example-with-delay-as-a-reference-to-a-function","text":"Shown below is a very simple example where the source generates items and puts it to a machine through a buffer and the items processed in machine is moved to a sink using another buffer. This example shows how to pass a function as a parameter.","title":"Example with delay as a reference to a function"},{"location":"examples/#delay-as-python-function","text":"An example showing how to pass python functions as delay parameters. In this example, the delays to be configured are inter_arrival_time , and processing_delay of source and machine. These are specified as a reference to a python function. Let the inter arrival time of the source be a value sampled from a gaussian distribution with mean = 1, std deviation is = 0.25 and the processing delay of the machine be a value function of the duration of the time spent by the machine in processing state. # System layout # SRC \u2500\u2500> BUF1 \u2500\u2500> MACHINE1 \u2500\u2500> BUF2 \u2500\u2500> SINK import random import factorysimpy from factorysimpy.nodes.machine import Machine from factorysimpy.edges.buffer import Buffer from factorysimpy.nodes.source import Source from factorysimpy.nodes.sink import Sink env = simpy . Environment () env = simpy . Environment () #let the inter arrival time of the source be a value sampled from a gaussian distribution with mean = 1, std deviation is = 0.25 #Gaussian distribution as a python function def generate_gaussian_distribution (): return random . gauss ( mu = 1 , sigma = 0.25 ) #let the processing delay of the machine be a value function of the duration of the time spent by the machine in processing state #if the time spent in processing state is greater than 7, the processing delay has to take one value in index 0 of the return_vals #if the time spent in processing state is less than or equal to 7, the processing delay has to take the value in index 1 #This behaviour as a python function def generate_process_delay (): return_vals = [ 0.9 , 1.2 ] if node . stats [ \"total_time_spent_in_states\" ][ \"PROCESSING_STATE\" ] > 7 : return return_vals [ 0 ] else : return return_vals [ 1 ] # Initializing nodes SRC = Source ( env , id = \"SRC\" , inter_arrival_time = generate_gaussian_distribution , blocking = False , out_edge_selection = 0 ) MACHINE1 = Machine ( env , id = \"MACHINE1\" , work_capacity = 1 , processing_delay = generate_process_delay , in_edge_selection = \"RANDOM\" , out_edge_selection = \"RANDOM\" ) SINK = Sink ( env , id = \"SINK\" ) # Initializing edges BUF1 = Buffer ( env , id = \"BUF1\" , store_capacity = 4 , delay = 0.5 ) BUF2 = Buffer ( env , id = \"BUF2\" , store_capacity = 4 , delay = 0.5 ) # Adding connections BUF1 . connect ( SRC , MACHINE1 ) BUF2 . connect ( MACHINE1 , SINK ) env . run ( until = 10 )","title":"Delay as python function"},{"location":"examples/#delay-as-generator-function","text":"An example showing how to pass python generator functions as delay parameters. In this example (same as above), the delays to be configured are inter_arrival_time , and processing_delay of source and machine. These are specified as a reference to a python generator function instance. Let the inter arrival time of the source be a value sampled from a gaussian distribution with mean = 1, std deviation is = 0.25 and the processing delay of the machine be a value function of the duration of the time spent by the machine in processing state. Generator functions are created for the two cases and supplied as parameters. # System layout # SRC \u2500\u2500> BUF1 \u2500\u2500> MACHINE1 \u2500\u2500> BUF2 \u2500\u2500> SINK import random import factorysimpy from factorysimpy.nodes.machine import Machine from factorysimpy.edges.buffer import Buffer from factorysimpy.nodes.source import Source from factorysimpy.nodes.sink import Sink env = simpy . Environment () #let the inter arrival time of the source be a value sampled from a gaussian distribution with mean = 2, std deviation is = 0.5 #Gaussian distribution as a generator function def generate_gaussian_distribution (): while True : yield random . gauss ( mu = 2 , sigma = 0.5 ) #let the processing delay of the machine be a value function of the duration of the time spent by the machine in processing state #if the time spent in processing state is greater than 7, the processing delay has to take one value in index 0 of the return_vals #if the time spent in processing state is less than or equal to 7, the processing delay has to take the value in index 1 #This behaviour as a generator function def generate_process_delay ( node , env ): return_vals = [ 0.9 , 1.2 ] while True : if node . stats [ \"total_time_spent_in_states\" ][ \"PROCESSING_STATE\" ] > 7 : yield return_vals [ 0 ] else : yield return_vals [ 1 ] # Initializing nodes SRC = Source ( env , id = \"SRC\" , inter_arrival_time = generate_gaussian_distribution , blocking = False , out_edge_selection = 0 ) MACHINE1 = Machine ( env , id = \"MACHINE1\" , work_capacity = 1 , processing_delay = None , in_edge_selection = \"RANDOM\" , out_edge_selection = \"RANDOM\" ) processing_delay_func = generate_process_delay ( MACHINE1 , env ) MACHINE1 . processing_delay = processing_delay_func SINK = Sink ( env , id = \"SINK\" ) # Initializing edges BUF1 = Buffer ( env , id = \"BUF1\" , store_capacity = 4 , delay = 0.5 ) BUF2 = Buffer ( env , id = \"BUF2\" , store_capacity = 4 , delay = 0.5 ) # Adding connections BUF1 . connect ( SRC , MACHINE1 ) BUF2 . connect ( MACHINE1 , SINK ) env . run ( until = 10 )","title":"Delay as generator function"},{"location":"examples/#example-with-a-custom-edge-selection-policy-as-a-function","text":"In the example below, there are multiple sources that generates items and puts it into their output buffers. The machine chooses one of its in_edges and picks an item and processes it and chooses an output edge and puts the item there. It choses the input edge and output edge based on the values yielded from function specified in in_edge_selection parameter and out_edge_selection parameter.","title":"Example with a custom edge selection policy as a function"},{"location":"examples/#edge-selection-as-python-function","text":"An example that shows how to interconnect a source to a machine using buffers and pass a python function as parameter. Consider the case when the edge selection parameters are to be modelled as a python function. Here is an example that shows how to pass a python function instance as a parameter. Let us consider a case where the in_edge_selection is dependant on the values sampled from a uniform distribution [0,1], if the sampled value is less than 0.5, then always index 1 is returned and if the sampled value is greater than 0.5 then index 0 is returned. out_edge_selection is dependant on the values sampled from a gaussian distribution with mean 4 and standard deviation 1 , if the value is greater than 3, then edge 0 is selected otherwise edge 1 is selected. Edge selection parameters of SRC1, and all the SINKs are provided with options that are implemented within the package. See this page for details about edge selection policy. # System layout # SRC1 \u2500\u2500> BUFFER1 \u2500\u2500\u2510 # \u2502 # SRC2 \u2500\u2500> BUFFER2 \u2500\u2500\u2534\u2500> MACHINE1 \u2500\u2500\u252c\u2500> BUFFER3 \u2500\u2500> SINK1 # \u2502 \u2502 # \u2514\u2500> BUFFER5 \u2500\u2500> SINK3 \u2514\u2500> BUFFER4 \u2500\u2500> SINK2 # import random import factorysimpy from factorysimpy.nodes.machine import Machine from factorysimpy.edges.buffer import Buffer from factorysimpy.nodes.source import Source from factorysimpy.nodes.sink import Sink env = simpy . Environment () #let the in_edge_selection of the machine be a function that yields 1 or 0 based on the value sampled from uniform distribution [0,1] # This function will yield 1 if value 0.5, and 0 if it is otherwise. #in_edge_selection as a function for machine def machine_in_edge_selector (): if random . random () < 0.5 : return 1 else : return 0 #let the out_edge_selection of the machine be a function that yields the index of the edge to be selected # This function will yield the index of the edge to be selected based on the value sampled from a gaussian dostribution with mean=4 and sigma=1 # it will return 1 is the sampled value is >3, else it will return 0 #out_edge_selection as a function for machine def machine_out_edge_selector (): if random . gauss ( mu = 4 , sigma = 1 ) > 3 : return 1 else : return 0 #let the out_edge_selection of the source 2 be a generator function that yields 1 or 0 based on the current time # This generator function will yield 1 if the current time is even, and 0 if it is odd. #out_edge_selection as a function for source def source_out_edge_selector ( env ): if env . now % 2 == 0 : return 1 else : return 0 # Initializing nodes SRC1 = Source ( env , id = \"SRC1\" , inter_arrival_time = 0.7 , blocking = False , out_edge_selection = \"FIRST_AVAILABLE\" ) SRC2 = Source ( env , id = \"SRC2\" , inter_arrival_time = 0.4 , blocking = False , out_edge_selection = source_out_edge_selector ( env ) ) MACHINE1 = Machine ( env , id = \"MACHINE1\" , work_capacity = 4 , processing_delay = 1 , in_edge_selection = machine_in_edge_selector , out_edge_selection = machine_out_edge_selector ) SINK1 = Sink ( env , id = \"SINK1\" , in_edge_selection = \"RANDOM\" ) SINK2 = Sink ( env , id = \"SINK2\" , in_edge_selection = \"RANDOM\" ) SINK3 = Sink ( env , id = \"SINK3\" , in_edge_selection = \"FIRST_AVAILABLE\" ) # Initializing edges # Initializing edges BUF1 = Buffer ( env , id = \"BUF1\" , store_capacity = 4 , delay = 0.5 ) BUF2 = Buffer ( env , id = \"BUF2\" , store_capacity = 4 , delay = 0.5 ) BUF3 = Buffer ( env , id = \"BUF3\" , store_capacity = 4 , delay = 0.5 ) BUF4 = Buffer ( env , id = \"BUF4\" , store_capacity = 4 , delay = 0.5 ) BUF5 = Buffer ( env , id = \"BUF5\" , store_capacity = 4 , delay = 0.5 ) # Adding connections BUF1 . connect ( SRC1 , MACHINE1 ) BUF2 . connect ( SRC2 , MACHINE1 ) BUF3 . connect ( MACHINE1 , SINK1 ) BUF4 . connect ( MACHINE1 , SINK2 ) BUF5 . connect ( SRC2 , SINK3 ) env . run ( until = 10 )","title":"Edge selection as python function"},{"location":"examples/#edge-selection-as-generator-function","text":"An example that shows how to interconnect a source to a machine using buffers and pass a python function or a generator instance as parameter. Consider the case when the edge selection parameters are to be modelled as a generator function that depends on the node object or the current time of the simulation environment. Here is an example that shows how to pass a generator function instance as a parameter. # System layout # SRC1 \u2500\u2500> BUFFER1 \u2500\u2500\u2510 # \u2502 # SRC2 \u2500\u2500> BUFFER2 \u2500\u2500\u2534\u2500> MACHINE1 \u2500\u2500\u252c\u2500> BUFFER3 \u2500\u2500> SINK1 # \u2502 \u2502 # \u2514\u2500> BUFFER5 \u2500\u2500> SINK3 \u2514\u2500> BUFFER4 \u2500\u2500> SINK2 # import factorysimpy from factorysimpy.nodes.machine import Machine from factorysimpy.edges.buffer import Buffer from factorysimpy.nodes.source import Source from factorysimpy.nodes.sink import Sink env = simpy . Environment () #let the out_edge_selection of the source be a generator function that yields 1 or 0 based on the current time # This generator function will yield 1 if the current time is even, and 0 if it is odd. # This will simulate a scenario where the source alternates between two output edges based on the time. #out_edge_selection as a generator function for machine def machine_out_edge_selector ( node , env ): while True : if env . now % 2 == 0 : yield 1 else : yield 0 #let the in_edge_selection of the machine be a generator function that yields the index of the edge to be selected # This generator function will yield the index of the edge to be selected based on the current time. # The index will be incremented every time the generator is called, and will wrap around when it reaches the number of edges. #in_edge_selection as a generator function for machine def machine_in_edge_selector ( node , env ): num_edges = len ( node . in_edges ) i = 0 while True : yield i yield i i = ( i + 1 ) % num_edges #let the out_edge_selection of the source be a generator function that yields 1 or 0 based on the current time # This generator function will yield 1 if the current time is even, and 0 if it is odd. #out_edge_selection as a generator function for source def source_out_edge_selector ( node , env ): while True : if env . now % 2 == 0 : yield 1 else : yield 0 # Initializing nodes SRC1 = Source ( env , id = \"SRC1\" , inter_arrival_time = 0.7 , blocking = False , out_edge_selection = \"FIRST_AVAILABLE\" ) SRC2 = Source ( env , id = \"SRC2\" , inter_arrival_time = 0.4 , blocking = False , out_edge_selection = None ) MACHINE1 = Machine ( env , id = \"MACHINE1\" , work_capacity = 4 , processing_delay = 1 , in_edge_selection = None , out_edge_selection = None ) SINK1 = Sink ( env , id = \"SINK1\" , in_edge_selection = \"RANDOM\" ) SINK2 = Sink ( env , id = \"SINK2\" , in_edge_selection = \"RANDOM\" ) SINK3 = Sink ( env , id = \"SINK3\" , in_edge_selection = \"FIRST_AVAILABLE\" ) #initialising out_edge_selection for source source_out_edge_func = source_out_edge_selector ( SRC2 , env ) SRC2 . out_edge_selection = source_out_edge_func #initialising in_edge_selection parameter machine_in_edge_func = machine_in_edge_selector ( MACHINE1 , env ) MACHINE1 . in_edge_selection = machine_in_edge_func #initialising in_edge_selection parameter for machine machine_out_edge_func = machine_out_edge_selector ( MACHINE1 , env ) MACHINE1 . out_edge_selection = machine_out_edge_func # Initializing edges # Initializing edges BUF1 = Buffer ( env , id = \"BUF1\" , store_capacity = 4 , delay = 0.5 ) BUF2 = Buffer ( env , id = \"BUF2\" , store_capacity = 4 , delay = 0.5 ) BUF3 = Buffer ( env , id = \"BUF3\" , store_capacity = 4 , delay = 0.5 ) BUF4 = Buffer ( env , id = \"BUF4\" , store_capacity = 4 , delay = 0.5 ) BUF5 = Buffer ( env , id = \"BUF5\" , store_capacity = 4 , delay = 0.5 ) # Adding connections BUF1 . connect ( SRC1 , MACHINE1 ) BUF2 . connect ( SRC2 , MACHINE1 ) BUF3 . connect ( MACHINE1 , SINK1 ) BUF4 . connect ( MACHINE1 , SINK2 ) BUF5 . connect ( SRC2 , SINK3 ) env . run ( until = 10 )","title":"Edge selection as generator function"},{"location":"examples/#example-to-illustrate-the-use-of-the-components-splitter-and-combiner","text":"An example to understand how to simulate packing and unpacking of items using SPLITTER and COMBINER Consider a system which has to pack 5 base items of flow_item_type =\"item\" in to an entity of flow_item_type =\"pallet\". And in the same example the method to unpack these packed items using a SPLITTER is also shown. There are two sources, SRC1 (producing \"items\") and SRC2 (producing \"pallets\"). These flow items are combined inside combiner and are pushed to a buffer. Splitter takes the items from the combiner and splits it into items and pallets and pushes it into sinks. Out_edge_selection of the splitter is a generator function that depends on the type of the item. It chooses index 0, incase the flow item is of type \"item\" and 1 if it is type \"pallet\". # System layout # SRC1 \u2500\u2500> BUFFER1 \u2500\u2500\u2510 # \u2502 # SRC2 \u2500\u2500> BUFFER2 \u2500\u2500\u2534\u2500> COMBINER1 \u2500\u2500> BUFFER3 \u2500\u2500>SPLITTER1 \u2500\u2500\u252c\u2500> BUFFER4 \u2500\u2500> SINK1 # \u2502 # \u2514\u2500> BUFFER5 \u2500\u2500> SINK2 # import factorysimpy from factorysimpy.nodes.machine import Machine from factorysimpy.edges.buffer import Buffer from factorysimpy.nodes.source import Source from factorysimpy.nodes.sink import Sink from factorysimpy.nodes.combiner import Combiner from factorysimpy.nodes.splitter import Splitter env = simpy . Environment () #generator function for out edge selection of splitter def splitter_out_edge_selector ( node ): while True : proc = node . env . active_process item_in_process = proc . item_to_put if item_in_process is None : raise RuntimeError ( \"Unknown calling process\" ) if item_in_process . flow_item_type == \"item\" : yield 0 elif item_in_process . flow_item_type == \"pallet\" and len ( item_in_process . items ) == 0 : yield 1 else : raise ValueError ( \"Invalid item_type encountered\" ) # Initializing nodes SRC1 = Source ( env , id = \"SRC1\" , flow_item_type = \"pallet\" , inter_arrival_time = 0.8 , blocking = False , out_edge_selection = \"RANDOM\" ) SRC2 = Source ( env , id = \"SRC2\" , flow_item_type = \"item\" , inter_arrival_time = 0.8 , blocking = False , out_edge_selection = \"RANDOM\" ) COMBINER1 = Combiner ( env , id = \"COMBINER1\" , target_quantity_of_each_item = [ 1 , 5 ], processing_delay = 1.1 , blocking = False , out_edge_selection = \"RANDOM\" ) SPLITTER1 = Splitter ( env , id = \"SPLITTER1\" , processing_delay = 1.1 , in_edge_selection = \"RANDOM\" , out_edge_selection = None ) SINK1 = Sink ( env , id = \"SINK1\" ) SINK2 = Sink ( env , id = \"SINK2\" ) #initialising in_edge_selection parameter for SPLITTER splitter_out_edge_func = splitter_out_edge_selector ( SPLITTER1 ) splitter . out_edge_selection = splitter_out_edge_func # Initializing edges BUF1 = Buffer ( env , id = \"BUF1\" , store_capacity = 2 , delay = 0.5 , mode = \"FIFO\" ) BUF2 = Buffer ( env , id = \"BUF2\" , store_capacity = 2 , delay = 0.5 , mode = \"FIFO\" ) BUF3 = Buffer ( env , id = \"BUF3\" , store_capacity = 2 , delay = 0.5 , mode = \"FIFO\" ) BUF4 = Buffer ( env , id = \"BUF4\" , store_capacity = 2 , delay = 0 , mode = \"FIFO\" ) BUF5 = Buffer ( env , id = \"BUF5\" , store_capacity = 2 , delay = 0 , mode = \"FIFO\" ) # Adding connections BUF1 . connect ( SRC1 , COMBINER1 ) BUF2 . connect ( SRC2 , COMBINER1 ) BUF3 . connect ( COMBINER1 , SPLITTER1 ) BUF4 . connect ( SPLITTER1 , SINK1 ) BUF5 . connect ( SPLITTER1 , SINK2 ) env . run ( until = 10 )","title":"Example to illustrate the use of the components splitter and combiner"},{"location":"examples/#example-with-constructs","text":"Here's an example that shows the utility of the constructs Suppose you want to model an assembly line with 20 machines connected in series, each separated by a buffer. Manually creating and connecting each machine and buffer would be repetitive, error-prone, and require a lot of code. To simplify this process for large, homogeneous systems, FactorySimPy provides constructs that automate the creation and connection of such chains. # System layout # SRC \u2500\u2500> BUF1 \u2500\u2500> MACHINE1 \u2500\u2500> BUF2 \u2500\u2500> MACHINE2 \u2500\u2500> # \u2500\u2500> BUF3 \u2500\u2500> MACHINE3 \u2500\u2500> BUF4 \u2500\u2500> MACHINE4 \u2500\u2500> ... # . . . . # . . . . # ... BUF19 \u2500\u2500> MACHINE19 \u2500\u2500> BUF20 \u2500\u2500> MACHINE20 \u2500\u2500> SINK # (20 machines in series, each separated by a buffer) import factorysimpy from factorysimpy.nodes.machine import Machine from factorysimpy.edges.buffer import Buffer from factorysimpy.nodes.source import Source from factorysimpy.nodes.sink import Sink from factorysimpy.constructs.chain import connect_chain_with_source_sink , connect_nodes_with_buffers env = simpy . Environment () node_kwargs = { \"node_setup_time\" : 0 , \"work_capacity\" : 1 , \"processing_delay\" : 0.8 , \"in_edge_selection\" : \"RANDOM\" , \"out_edge_selection\" : \"FIRST_AVAILABLE\" } edge_kwargs = { \"store_capacity\" : 4 , \"delay\" : 0 , \"mode\" : \"LIFO\" } source_kwargs = { \"inter_arrival_time\" : 1 , \"blocking\" : True , \"out_edge_selection\" : \"FIRST_AVAILABLE\" } sink_kwargs = { \"id\" : \"Sink-1\" } # Example for a chain of 1 machine (count=1) nodes , edges , src , sink = connect_chain_with_source_sink ( env , count = 20 , node_cls = Machine , edge_cls = Buffer , source_cls = Source , sink_cls = Sink , node_kwargs = node_kwargs , edge_kwargs = edge_kwargs , source_kwargs = source_kwargs , sink_kwargs = sink_kwargs , prefix = \"Machine\" , edge_prefix = \"Buffer\" ) machines , buffers = connect_nodes_with_buffers ( nodes , edges , src , sink ) env . run ( until = 100 )","title":"Example with constructs"},{"location":"extendedresources/","text":"Extended resources for FactorySimPy \u00b6 ReservablePriorityReqStore \u00b6 The ReservablePriorityReqStore is a class derived from SimPy's Store class that addresses a missing capability in the library by allowing both priority-based retrieval and reservation of items(or space) before they are actually retrieved (or put), respecting the capacity of the store. This is particularly useful in manufacturing systems where materials or products must be allocated in advance, ensuring that specific parts are reserved for machines before processing begins. It also allows priority-based retrieval, ensuring that urgent requests are handled first. Additionally, decoupling reservation from yielding a \"get\" request ensures that items remain in storage until they are actually needed, and can be retrieved using a simple get method, improving coordination in assembly lines and buffer management. Only the reservation request has to be yielded, and upon yielding it, the user can just call the get or put method to get or put an item. Unlike SimPy\u2019s existing resource reservation methods, which manage process-related elements like machines or operators, ReservablePriorityReqStore focuses on item-level management, making it a valuable addition for handling inventory, buffer stocks, and material flows in discrete-event simulations. However, when implementing SimPy interrupts, the events should be manually canceled in case of an interruption. The ReservablePriorityReqStore extends SimPy's Store by allowing users to: Reserve Capacity : Processes can reserve space (or item) in the store before actually putting (or getting) in it. Enforce Reservation Rules : Prohibits any process from adding (or getting) items to the store without a prior reservation. Priority for requests : Users can pass a priority along with the reservation requests. The requests with the highest priority(lowest first) will be yielded first. Two requests with same priority will be yielded in a FIFO manner. Cancel a reservation : Allows users to cancel a placed/yielded reserve_put (or reserve_get) request. Parameters \u00b6 env : The SimPy environment managing the simulation. capacity : Maximum number of items the store can hold (default: infinite). Example Usage \u00b6 import simpy import random from ReservablePriorityReqStore import ReservablePriorityReqStore class Item : \"\"\"Represents an item to be stored.\"\"\" def __init__ ( self , name ): self . name = name # Simulation Setup env = simpy . Environment () itemstore = ReservablePriorityReqStore ( env , capacity = 3 ) def producer ( env , itemstore , name , priority ): \"\"\"Producer process produces items and puts it in the store.\"\"\" yield env . timeout ( random . uniform ( 1 , 3 )) # Simulate time before producing put_reservation = itemstore . reserve_put ( priority = priority ) yield put_reservation # Wait for reservation to succeed item = Item ( f \" { name } \" ) itemstore . put ( put_reservation , item ) print ( f \"T= { env . now : .2f } : { name } added to store with priority { priority } \" ) def consumer ( env , itemstore , name , priority , cancel = False ): \"\"\"Consumer process picks up items from the store.\"\"\" get_reservation = itemstore . reserve_get ( priority = priority ) print ( f \"T= { env . now : .2f } : { name } placed a reserve_get request to store with priority { priority } \") if cancel and random . choice ([ True , False ]): itemstore . reserve_get_cancel ( get_reservation ) print ( f \"T= { env . now : .2f } : { name } CANCELED reservation\" ) return yield get_reservation # Wait for reservation to succeed print ( f \"T= { env . now : .2f } : { name } yielded from store with priority { priority } \" ) yield env . timeout ( random . uniform ( 2 , 5 )) item = itemstore . get ( get_reservation ) print ( f \"T= { env . now : .2f } : { name } retrieved { item . name } from store with priority { priority } \") # Creating producers and consumers env . process ( consumer ( env , itemstore , \"Consumer1\" , priority = 3 , cancel = True )) env . process ( consumer ( env , itemstore , \"Consumer2\" , priority = 1 )) env . process ( consumer ( env , itemstore , \"Consumer3\" , priority = 2 )) env . process ( producer ( env , itemstore , \"ItemA\" , priority = 2 )) env . process ( producer ( env , itemstore , \"ItemB\" , priority = 1 )) env . process ( producer ( env , itemstore , \"ItemC\" , priority = 3 )) env . run ( until = 10 ) Simulation output T=0.00 : Consumer1 placed a reserve_get request to store with priority 3 T=0.00 : Consumer1 CANCELED reservation T=0.00 : Consumer2 placed a reserve_get request to store with priority 1 T=0.00 : Consumer3 placed a reserve_get request to store with priority 2 T=2.14 : ItemB added to store with priority 1 T=2.14 : Consumer2 yielded from store with priority 1 T=2.23 : ItemA added to store with priority 2 T=2.23 : Consumer3 yielded from store with priority 2 T=2.54 : ItemC added to store with priority 3 T=5.40 : Consumer2 retrieved ItemB from store with priority 1 T=6.02 : Consumer3 retrieved ItemA from store with priority 2 Usecase \u00b6 # @title Usecase import simpy from ReservablePriorityReqStore import ReservablePriorityReqStore ''' In this simulation, two machines (MachineGreen and MachineOrange) produce new items by consuming specific part. MachineGreen,which produces green balls, requests parts (like yellow and blue balls) with a higher priority, while MachineOrange, which produces orange balls, requests parts (like yellow and red balls) with lower priority. Producers generate red, yellow, and blue balls at defined intervals, and consumers retrieve the assembled green and orange balls from their respective stores.''' # ----- Producer ----- def producer ( env , interarrival , store , item_prefix ): \"\"\"Produces items with a given prefix into a store.\"\"\" i = 0 while True : yield env . timeout ( interarrival ) put_req = store . reserve_put () yield put_req item_name = f \" { item_prefix }{ i + 1 } \" store . put ( put_req , item_name ) print ( f \"T= { env . now : .2f } : Producer { item_prefix } : added { item_name } )\" ) i += 1 # ----- Consumer ----- def consumer ( env , interarrival , store , consumer_name ): \"\"\"Consumes items from a store.\"\"\" while True : yield env . timeout ( interarrival ) get_req = store . reserve_get () yield get_req item = store . get ( get_req ) print ( f \"T= { env . now : .2f } : Consumer { consumer_name } : got item { item } \" ) # ----- Machine ----- def machine ( env , delay , input_stores , input_priorities , output_store , output_prefix ): \"\"\" A machine that requests multiple items from input stores (with optional priorities),waits processing time, and outputs a new item. Args: input_stores (list): list of stores to get inputs from input_priorities (list): list of priorities (None if no priority) output_store: where to put output output_prefix: name prefix for output items \"\"\" i = 0 while True : put_req = output_store . reserve_put () yield put_req # Request input items input_requests = [] for store , priority in zip ( input_stores , input_priorities ): if priority is not None : req = store . reserve_get ( priority = priority ) else : req = store . reserve_get () input_requests . append ( req ) print ( f \"T= { env . now : .2f } : Machine { output_prefix } : waiting to yield reserve_get requests \") yield env . all_of ( input_requests ) # Get input items for store , req in zip ( input_stores , input_requests ): store . get ( req ) print ( f \"T= { env . now : .2f } : Machine { output_prefix } : got both inputs\" ) yield env . timeout ( delay ) output_store . put ( put_req , f \" { output_prefix }{ i } \" ) print ( f \"T= { env . now : .2f } : Machine { output_prefix } : finished product is available in its store \") i += 1 # ----- Simulation Setup ----- def run_simulation (): env = simpy . Environment () # Create Stores redstore = ReservablePriorityReqStore ( env , capacity = 5 ) yellowstore = ReservablePriorityReqStore ( env , capacity = 1 ) bluestore = ReservablePriorityReqStore ( env , capacity = 5 ) orangestore = ReservablePriorityReqStore ( env , capacity = 1 ) greenstore = ReservablePriorityReqStore ( env , capacity = 1 ) # Producer setups producer_params = [ ( 1 , redstore , \"red\" ), ( 2 , yellowstore , \"yellow\" ), ( 1 , bluestore , \"blue\" ) ] # Consumer setups consumer_params = [ ( 1 , orangestore , \"orange\" ), ( 1 , greenstore , \"green\" ) ] # Machine setups machine_params = [ ( 1 , [ yellowstore , redstore ], [ None , None ], orangestore , \"orange\" ), #Machine1 ( 1 , [ yellowstore , bluestore ], [ - 2 , None ], greenstore , \"green\" ) # Machine2 ] # Start Producers for interarrival , store , prefix in producer_params : env . process ( producer ( env , interarrival , store , prefix )) # Start Consumers for interarrival , store , name in consumer_params : env . process ( consumer ( env , interarrival , store , name )) # Start Machines for delay , inputs , priorities , output , prefix in machine_params : env . process ( machine ( env , delay , inputs , priorities , output , prefix )) # Run Simulation env . run ( until = 5 ) # Run it run_simulation () Simulation output T=0.00: Machine orange: waiting to yield reserve_get requests T=0.00: Machine green: waiting to yield reserve_get requests T=1.00: Producer red: added red1 T=1.00: Producer blue: added blue1 T=2.00: Producer yellow: added yellow1 T=2.00: Producer red: added red2 T=2.00: Producer blue: added blue2 T=2.00: Machine green: got both inputs T=3.00: Machine green: finished product is available in its store T=3.00: Producer red: added red3 T=3.00: Producer blue: added blue3 T=3.00: Consumer green: got item green0 T=3.00: Machine green: waiting to yield reserve_get requests T=4.00: Producer yellow: added yellow2 T=4.00: Producer red: added red4 T=4.00: Producer blue: added blue4 T=4.00: Machine green: got both inputs Go to API Reference PriorityReqStore \u00b6 PriorityReqStore is a resource store with priority handling capabilities. Users can add a priority for each of the get(or put) requests. Request with lower values of priority yields first among all get(or put) requests. If two requests with same priority are placed from two processes then FIFO order is followed to yield the requests. Main Features: Priority for requests : Manages concurrent requests with different priority values. Parameters \u00b6 env : The SimPy environment managing the simulation. capacity : Maximum number of items the store can hold (default: infinite). Example Usage \u00b6 import simpy from PriorityReqStore import PriorityReqStore class item : def __init__ ( self , name ): self . name = name def source ( name , env , delay , priority = 0 ): i = 1 yield env . timeout ( delay ) item1 = item ( name = 'item' + str ( name ) + str ( i )) print ( f 'T= { env . now : .2f } : Source { name } Going to put an item in store { item1 . name } with priority { priority } ') yield store . put ( item1 , priority ) i += 2 def sink ( name , env , delay , priority ): yield env . timeout ( delay ) print ( f 'T= { env . now : .2f } : Sink { name } placed a get request with priority { priority } in the store ') item = yield store . get ( priority ) print ( f 'T= { env . now : .2f } : Sink { name } Got an item from store { item . name } ' ) env = simpy . Environment () store = PriorityReqStore ( env , 2 ) p1 = env . process ( sink ( 'OUT-1' , env , 0 , 2 )) p2 = env . process ( sink ( 'OUT-2' , env , 0 , 1 )) p3 = env . process ( source ( 'IN-A' , env , 1 , 2 )) p4 = env . process ( source ( 'IN-B' , env , 1 , 1 )) env . run ( until = 5 ) Simulation output T=0.00: Sink OUT-1 placed a get request with priority 2 in the store T=0.00: Sink OUT-2 placed a get request with priority 1 in the store T=1.00: Source IN-A Going to put an item in store itemIN-A1 with priority 2 T=1.00: Source IN-B Going to put an item in store itemIN-B1 with priority 1 T=1.00: Sink OUT-2 Got an item from store itemIN-A1 T=1.00: Sink OUT-1 Got an item from store itemIN-B1 Usecase \u00b6 ''' A university\u2019s Central IT Department supports Admin, Library, Student Labs, and Research Labs. Departments request IT systems (computers). Systems are allocated based on request priority \u2014 higher-priority departments get systems first.''' import simpy from PriorityReqStore import PriorityReqStore # Importing your PriorityReqStore class CentralITDepartment : def __init__ ( self , env , initial_stock = 0 ): self . env = env self . store = PriorityReqStore ( env ) self . results = [] # Pre-load some stock if needed for i in range ( initial_stock ): self . store . items . append ( f \"Preloaded_System_ { i + 1 } \" ) def department_request ( self , department_name , priority ): \"\"\"Department places a request for a system.\"\"\" print ( f \"T= { self . env . now : .2f } : { department_name } places a request with priority { priority } \") system = yield self . store . get ( priority = priority ) self . results . append (( self . env . now , department_name , system )) print ( f \"T= { self . env . now : .2f } : { department_name } received { system } \" ) def add_systems ( self , count , delay = 0 ): \"\"\"IT department adds systems after a delay.\"\"\" yield self . env . timeout ( delay ) for i in range ( count ): system_name = f \"System_ { i + 1 } _after_delay\" yield self . store . put ( system_name ) print ( f \"T= { self . env . now : .2f } : IT Department added { system_name } \" ) def run_central_it_simulation (): env = simpy . Environment () it_department = CentralITDepartment ( env ) # Start departments making requests env . process ( it_department . department_request ( 'Admin' , priority = 3 )) env . process ( it_department . department_request ( 'Library' , priority = 3 )) env . process ( it_department . department_request ( 'Student Lab' , priority = 1 )) env . process ( it_department . department_request ( 'Research Lab' , priority = 2 )) # IT Department will add new systems after 2 time units env . process ( it_department . add_systems ( count = 3 , delay = 2 )) env . run ( until = 10 ) if __name__ == \"__main__\" : run_central_it_simulation () Simulation output T=0.00: Admin places a request with priority 3 T=0.00: Library places a request with priority 3 T=0.00: Student Lab places a request with priority 1 T=0.00: Research Lab places a request with priority 2 T=2.00: IT Department added System_1_after_delay T=2.00: Student Lab received System_1_after_delay T=2.00: IT Department added System_2_after_delay T=2.00: Research Lab received System_2_after_delay T=2.00: IT Department added System_3_after_delay T=2.00: Admin received System_3_after_delay Go to API Reference","title":"Supporting classes"},{"location":"extendedresources/#extended-resources-for-factorysimpy","text":"","title":"Extended resources for FactorySimPy"},{"location":"extendedresources/#reservablepriorityreqstore","text":"The ReservablePriorityReqStore is a class derived from SimPy's Store class that addresses a missing capability in the library by allowing both priority-based retrieval and reservation of items(or space) before they are actually retrieved (or put), respecting the capacity of the store. This is particularly useful in manufacturing systems where materials or products must be allocated in advance, ensuring that specific parts are reserved for machines before processing begins. It also allows priority-based retrieval, ensuring that urgent requests are handled first. Additionally, decoupling reservation from yielding a \"get\" request ensures that items remain in storage until they are actually needed, and can be retrieved using a simple get method, improving coordination in assembly lines and buffer management. Only the reservation request has to be yielded, and upon yielding it, the user can just call the get or put method to get or put an item. Unlike SimPy\u2019s existing resource reservation methods, which manage process-related elements like machines or operators, ReservablePriorityReqStore focuses on item-level management, making it a valuable addition for handling inventory, buffer stocks, and material flows in discrete-event simulations. However, when implementing SimPy interrupts, the events should be manually canceled in case of an interruption. The ReservablePriorityReqStore extends SimPy's Store by allowing users to: Reserve Capacity : Processes can reserve space (or item) in the store before actually putting (or getting) in it. Enforce Reservation Rules : Prohibits any process from adding (or getting) items to the store without a prior reservation. Priority for requests : Users can pass a priority along with the reservation requests. The requests with the highest priority(lowest first) will be yielded first. Two requests with same priority will be yielded in a FIFO manner. Cancel a reservation : Allows users to cancel a placed/yielded reserve_put (or reserve_get) request.","title":"ReservablePriorityReqStore"},{"location":"extendedresources/#parameters","text":"env : The SimPy environment managing the simulation. capacity : Maximum number of items the store can hold (default: infinite).","title":"Parameters"},{"location":"extendedresources/#example-usage","text":"import simpy import random from ReservablePriorityReqStore import ReservablePriorityReqStore class Item : \"\"\"Represents an item to be stored.\"\"\" def __init__ ( self , name ): self . name = name # Simulation Setup env = simpy . Environment () itemstore = ReservablePriorityReqStore ( env , capacity = 3 ) def producer ( env , itemstore , name , priority ): \"\"\"Producer process produces items and puts it in the store.\"\"\" yield env . timeout ( random . uniform ( 1 , 3 )) # Simulate time before producing put_reservation = itemstore . reserve_put ( priority = priority ) yield put_reservation # Wait for reservation to succeed item = Item ( f \" { name } \" ) itemstore . put ( put_reservation , item ) print ( f \"T= { env . now : .2f } : { name } added to store with priority { priority } \" ) def consumer ( env , itemstore , name , priority , cancel = False ): \"\"\"Consumer process picks up items from the store.\"\"\" get_reservation = itemstore . reserve_get ( priority = priority ) print ( f \"T= { env . now : .2f } : { name } placed a reserve_get request to store with priority { priority } \") if cancel and random . choice ([ True , False ]): itemstore . reserve_get_cancel ( get_reservation ) print ( f \"T= { env . now : .2f } : { name } CANCELED reservation\" ) return yield get_reservation # Wait for reservation to succeed print ( f \"T= { env . now : .2f } : { name } yielded from store with priority { priority } \" ) yield env . timeout ( random . uniform ( 2 , 5 )) item = itemstore . get ( get_reservation ) print ( f \"T= { env . now : .2f } : { name } retrieved { item . name } from store with priority { priority } \") # Creating producers and consumers env . process ( consumer ( env , itemstore , \"Consumer1\" , priority = 3 , cancel = True )) env . process ( consumer ( env , itemstore , \"Consumer2\" , priority = 1 )) env . process ( consumer ( env , itemstore , \"Consumer3\" , priority = 2 )) env . process ( producer ( env , itemstore , \"ItemA\" , priority = 2 )) env . process ( producer ( env , itemstore , \"ItemB\" , priority = 1 )) env . process ( producer ( env , itemstore , \"ItemC\" , priority = 3 )) env . run ( until = 10 ) Simulation output T=0.00 : Consumer1 placed a reserve_get request to store with priority 3 T=0.00 : Consumer1 CANCELED reservation T=0.00 : Consumer2 placed a reserve_get request to store with priority 1 T=0.00 : Consumer3 placed a reserve_get request to store with priority 2 T=2.14 : ItemB added to store with priority 1 T=2.14 : Consumer2 yielded from store with priority 1 T=2.23 : ItemA added to store with priority 2 T=2.23 : Consumer3 yielded from store with priority 2 T=2.54 : ItemC added to store with priority 3 T=5.40 : Consumer2 retrieved ItemB from store with priority 1 T=6.02 : Consumer3 retrieved ItemA from store with priority 2","title":"Example Usage"},{"location":"extendedresources/#usecase","text":"# @title Usecase import simpy from ReservablePriorityReqStore import ReservablePriorityReqStore ''' In this simulation, two machines (MachineGreen and MachineOrange) produce new items by consuming specific part. MachineGreen,which produces green balls, requests parts (like yellow and blue balls) with a higher priority, while MachineOrange, which produces orange balls, requests parts (like yellow and red balls) with lower priority. Producers generate red, yellow, and blue balls at defined intervals, and consumers retrieve the assembled green and orange balls from their respective stores.''' # ----- Producer ----- def producer ( env , interarrival , store , item_prefix ): \"\"\"Produces items with a given prefix into a store.\"\"\" i = 0 while True : yield env . timeout ( interarrival ) put_req = store . reserve_put () yield put_req item_name = f \" { item_prefix }{ i + 1 } \" store . put ( put_req , item_name ) print ( f \"T= { env . now : .2f } : Producer { item_prefix } : added { item_name } )\" ) i += 1 # ----- Consumer ----- def consumer ( env , interarrival , store , consumer_name ): \"\"\"Consumes items from a store.\"\"\" while True : yield env . timeout ( interarrival ) get_req = store . reserve_get () yield get_req item = store . get ( get_req ) print ( f \"T= { env . now : .2f } : Consumer { consumer_name } : got item { item } \" ) # ----- Machine ----- def machine ( env , delay , input_stores , input_priorities , output_store , output_prefix ): \"\"\" A machine that requests multiple items from input stores (with optional priorities),waits processing time, and outputs a new item. Args: input_stores (list): list of stores to get inputs from input_priorities (list): list of priorities (None if no priority) output_store: where to put output output_prefix: name prefix for output items \"\"\" i = 0 while True : put_req = output_store . reserve_put () yield put_req # Request input items input_requests = [] for store , priority in zip ( input_stores , input_priorities ): if priority is not None : req = store . reserve_get ( priority = priority ) else : req = store . reserve_get () input_requests . append ( req ) print ( f \"T= { env . now : .2f } : Machine { output_prefix } : waiting to yield reserve_get requests \") yield env . all_of ( input_requests ) # Get input items for store , req in zip ( input_stores , input_requests ): store . get ( req ) print ( f \"T= { env . now : .2f } : Machine { output_prefix } : got both inputs\" ) yield env . timeout ( delay ) output_store . put ( put_req , f \" { output_prefix }{ i } \" ) print ( f \"T= { env . now : .2f } : Machine { output_prefix } : finished product is available in its store \") i += 1 # ----- Simulation Setup ----- def run_simulation (): env = simpy . Environment () # Create Stores redstore = ReservablePriorityReqStore ( env , capacity = 5 ) yellowstore = ReservablePriorityReqStore ( env , capacity = 1 ) bluestore = ReservablePriorityReqStore ( env , capacity = 5 ) orangestore = ReservablePriorityReqStore ( env , capacity = 1 ) greenstore = ReservablePriorityReqStore ( env , capacity = 1 ) # Producer setups producer_params = [ ( 1 , redstore , \"red\" ), ( 2 , yellowstore , \"yellow\" ), ( 1 , bluestore , \"blue\" ) ] # Consumer setups consumer_params = [ ( 1 , orangestore , \"orange\" ), ( 1 , greenstore , \"green\" ) ] # Machine setups machine_params = [ ( 1 , [ yellowstore , redstore ], [ None , None ], orangestore , \"orange\" ), #Machine1 ( 1 , [ yellowstore , bluestore ], [ - 2 , None ], greenstore , \"green\" ) # Machine2 ] # Start Producers for interarrival , store , prefix in producer_params : env . process ( producer ( env , interarrival , store , prefix )) # Start Consumers for interarrival , store , name in consumer_params : env . process ( consumer ( env , interarrival , store , name )) # Start Machines for delay , inputs , priorities , output , prefix in machine_params : env . process ( machine ( env , delay , inputs , priorities , output , prefix )) # Run Simulation env . run ( until = 5 ) # Run it run_simulation () Simulation output T=0.00: Machine orange: waiting to yield reserve_get requests T=0.00: Machine green: waiting to yield reserve_get requests T=1.00: Producer red: added red1 T=1.00: Producer blue: added blue1 T=2.00: Producer yellow: added yellow1 T=2.00: Producer red: added red2 T=2.00: Producer blue: added blue2 T=2.00: Machine green: got both inputs T=3.00: Machine green: finished product is available in its store T=3.00: Producer red: added red3 T=3.00: Producer blue: added blue3 T=3.00: Consumer green: got item green0 T=3.00: Machine green: waiting to yield reserve_get requests T=4.00: Producer yellow: added yellow2 T=4.00: Producer red: added red4 T=4.00: Producer blue: added blue4 T=4.00: Machine green: got both inputs Go to API Reference","title":"Usecase"},{"location":"extendedresources/#priorityreqstore","text":"PriorityReqStore is a resource store with priority handling capabilities. Users can add a priority for each of the get(or put) requests. Request with lower values of priority yields first among all get(or put) requests. If two requests with same priority are placed from two processes then FIFO order is followed to yield the requests. Main Features: Priority for requests : Manages concurrent requests with different priority values.","title":"PriorityReqStore"},{"location":"extendedresources/#parameters_1","text":"env : The SimPy environment managing the simulation. capacity : Maximum number of items the store can hold (default: infinite).","title":"Parameters"},{"location":"extendedresources/#example-usage_1","text":"import simpy from PriorityReqStore import PriorityReqStore class item : def __init__ ( self , name ): self . name = name def source ( name , env , delay , priority = 0 ): i = 1 yield env . timeout ( delay ) item1 = item ( name = 'item' + str ( name ) + str ( i )) print ( f 'T= { env . now : .2f } : Source { name } Going to put an item in store { item1 . name } with priority { priority } ') yield store . put ( item1 , priority ) i += 2 def sink ( name , env , delay , priority ): yield env . timeout ( delay ) print ( f 'T= { env . now : .2f } : Sink { name } placed a get request with priority { priority } in the store ') item = yield store . get ( priority ) print ( f 'T= { env . now : .2f } : Sink { name } Got an item from store { item . name } ' ) env = simpy . Environment () store = PriorityReqStore ( env , 2 ) p1 = env . process ( sink ( 'OUT-1' , env , 0 , 2 )) p2 = env . process ( sink ( 'OUT-2' , env , 0 , 1 )) p3 = env . process ( source ( 'IN-A' , env , 1 , 2 )) p4 = env . process ( source ( 'IN-B' , env , 1 , 1 )) env . run ( until = 5 ) Simulation output T=0.00: Sink OUT-1 placed a get request with priority 2 in the store T=0.00: Sink OUT-2 placed a get request with priority 1 in the store T=1.00: Source IN-A Going to put an item in store itemIN-A1 with priority 2 T=1.00: Source IN-B Going to put an item in store itemIN-B1 with priority 1 T=1.00: Sink OUT-2 Got an item from store itemIN-A1 T=1.00: Sink OUT-1 Got an item from store itemIN-B1","title":"Example Usage"},{"location":"extendedresources/#usecase_1","text":"''' A university\u2019s Central IT Department supports Admin, Library, Student Labs, and Research Labs. Departments request IT systems (computers). Systems are allocated based on request priority \u2014 higher-priority departments get systems first.''' import simpy from PriorityReqStore import PriorityReqStore # Importing your PriorityReqStore class CentralITDepartment : def __init__ ( self , env , initial_stock = 0 ): self . env = env self . store = PriorityReqStore ( env ) self . results = [] # Pre-load some stock if needed for i in range ( initial_stock ): self . store . items . append ( f \"Preloaded_System_ { i + 1 } \" ) def department_request ( self , department_name , priority ): \"\"\"Department places a request for a system.\"\"\" print ( f \"T= { self . env . now : .2f } : { department_name } places a request with priority { priority } \") system = yield self . store . get ( priority = priority ) self . results . append (( self . env . now , department_name , system )) print ( f \"T= { self . env . now : .2f } : { department_name } received { system } \" ) def add_systems ( self , count , delay = 0 ): \"\"\"IT department adds systems after a delay.\"\"\" yield self . env . timeout ( delay ) for i in range ( count ): system_name = f \"System_ { i + 1 } _after_delay\" yield self . store . put ( system_name ) print ( f \"T= { self . env . now : .2f } : IT Department added { system_name } \" ) def run_central_it_simulation (): env = simpy . Environment () it_department = CentralITDepartment ( env ) # Start departments making requests env . process ( it_department . department_request ( 'Admin' , priority = 3 )) env . process ( it_department . department_request ( 'Library' , priority = 3 )) env . process ( it_department . department_request ( 'Student Lab' , priority = 1 )) env . process ( it_department . department_request ( 'Research Lab' , priority = 2 )) # IT Department will add new systems after 2 time units env . process ( it_department . add_systems ( count = 3 , delay = 2 )) env . run ( until = 10 ) if __name__ == \"__main__\" : run_central_it_simulation () Simulation output T=0.00: Admin places a request with priority 3 T=0.00: Library places a request with priority 3 T=0.00: Student Lab places a request with priority 1 T=0.00: Research Lab places a request with priority 2 T=2.00: IT Department added System_1_after_delay T=2.00: Student Lab received System_1_after_delay T=2.00: IT Department added System_2_after_delay T=2.00: Research Lab received System_2_after_delay T=2.00: IT Department added System_3_after_delay T=2.00: Admin received System_3_after_delay Go to API Reference","title":"Usecase"},{"location":"extending_components/","text":"","title":"Extending Components"},{"location":"fleet/","text":"Fleet ( env , id , capacity = 1 , delay = 1 , transit_delay = 0 ) \u00b6 Bases: Edge Fleet class representing an AGV (Automated Guided Vehicle) or a group of transporters. Inherits from the Edge class. This fleet can have a single input edge and a single output edge. Attributes: state ( str ) \u2013 The current state of the fleet. capacity ( int ) \u2013 The capacity of the fleet's internal storage. delay ( ( int , float ) ) \u2013 Delay after which fleet activates to move items incase the target capacity is not reached. It Can be int or float: Used as a constant delay. transit_delay ( ( int , float ) ) \u2013 It is the time taken by the fleet to transport the item from src node to destination node. (can be a constant, generator, or callable). Behavior: The Fleet is a type of edge represents components that moves multiple items simulataneaously between nodes. User can specify a parameter capacity to specify how many items can be moved at once. Incoming edges can use reserve_get and reserve_put calls on the store in the fleet to reserve an item or space and after yielding the requests, an item can be put and obtained by using put and get methods. Raises: AssertionError \u2013 If the fleet does not have at least one source node or one destination node. Output performance metrics The key performance metrics of the fleet edge are captured in the stats attribute (dict) during a simulation run. last_state_change_time : Time when the state was last changed . time_averaged_num_of_items_in_fleet : Time - averaged number of items available in the fleet . total_time_spent_in_states : Dictionary with total time spent in each state . can_put () \u00b6 Check if the fleet can accept an item. Returns \u00b6 bool True if the fleet can accept an item, False otherwise. can_get () \u00b6 Check if the fleet can accept an item. Returns \u00b6 bool True if the fleet can give an item, False otherwise. get ( event ) \u00b6 Get an item from the fleet. Parameters \u00b6 event : simpy.Event The event that was reserved for getting an item. Returns \u00b6 item : object The item retrieved from the fleet. reserve_get_cancel ( event ) \u00b6 Cancel a reserved get event. Parameters \u00b6 event : simpy.Event The event that was reserved for getting an item. reserve_put_cancel ( event ) \u00b6 Cancel a reserved put event. Parameters \u00b6 event : simpy.Event The event that was reserved for putting an item.","title":"Fleet"},{"location":"fleet/#factorysimpy.edges.fleet.Fleet","text":"Bases: Edge Fleet class representing an AGV (Automated Guided Vehicle) or a group of transporters. Inherits from the Edge class. This fleet can have a single input edge and a single output edge. Attributes: state ( str ) \u2013 The current state of the fleet. capacity ( int ) \u2013 The capacity of the fleet's internal storage. delay ( ( int , float ) ) \u2013 Delay after which fleet activates to move items incase the target capacity is not reached. It Can be int or float: Used as a constant delay. transit_delay ( ( int , float ) ) \u2013 It is the time taken by the fleet to transport the item from src node to destination node. (can be a constant, generator, or callable). Behavior: The Fleet is a type of edge represents components that moves multiple items simulataneaously between nodes. User can specify a parameter capacity to specify how many items can be moved at once. Incoming edges can use reserve_get and reserve_put calls on the store in the fleet to reserve an item or space and after yielding the requests, an item can be put and obtained by using put and get methods. Raises: AssertionError \u2013 If the fleet does not have at least one source node or one destination node. Output performance metrics The key performance metrics of the fleet edge are captured in the stats attribute (dict) during a simulation run. last_state_change_time : Time when the state was last changed . time_averaged_num_of_items_in_fleet : Time - averaged number of items available in the fleet . total_time_spent_in_states : Dictionary with total time spent in each state .","title":"Fleet"},{"location":"fleet/#factorysimpy.edges.fleet.Fleet.can_put","text":"Check if the fleet can accept an item.","title":"can_put"},{"location":"fleet/#factorysimpy.edges.fleet.Fleet.can_put--returns","text":"bool True if the fleet can accept an item, False otherwise.","title":"Returns"},{"location":"fleet/#factorysimpy.edges.fleet.Fleet.can_get","text":"Check if the fleet can accept an item.","title":"can_get"},{"location":"fleet/#factorysimpy.edges.fleet.Fleet.can_get--returns","text":"bool True if the fleet can give an item, False otherwise.","title":"Returns"},{"location":"fleet/#factorysimpy.edges.fleet.Fleet.get","text":"Get an item from the fleet.","title":"get"},{"location":"fleet/#factorysimpy.edges.fleet.Fleet.get--parameters","text":"event : simpy.Event The event that was reserved for getting an item.","title":"Parameters"},{"location":"fleet/#factorysimpy.edges.fleet.Fleet.get--returns","text":"item : object The item retrieved from the fleet.","title":"Returns"},{"location":"fleet/#factorysimpy.edges.fleet.Fleet.reserve_get_cancel","text":"Cancel a reserved get event.","title":"reserve_get_cancel"},{"location":"fleet/#factorysimpy.edges.fleet.Fleet.reserve_get_cancel--parameters","text":"event : simpy.Event The event that was reserved for getting an item.","title":"Parameters"},{"location":"fleet/#factorysimpy.edges.fleet.Fleet.reserve_put_cancel","text":"Cancel a reserved put event.","title":"reserve_put_cancel"},{"location":"fleet/#factorysimpy.edges.fleet.Fleet.reserve_put_cancel--parameters","text":"event : simpy.Event The event that was reserved for putting an item.","title":"Parameters"},{"location":"getting_started/","text":"Getting Started with FactorySimPy \u00b6 Welcome to FactorySimPy \u2013 a lightweight, open-source component library for discrete-event simulation (DES) of manufacturing systems, built on top of SimPy v4.1.1 . This guide will help you to get started with the packages in a few minutes. Installation \u00b6 Install FactorySimPy. Make sure you have Python \u2265 3.8. From Github Install SimPy (if not already installed) pip install simpy Install FactorySimPy pip install git+https://github.com/FactorySimPy/FactorySimPy.git What You Can Model \u00b6 FactorySimPy lets you simulate typical manufacturing scenarios using ready-made building blocks like: Machine is a node with configurable processing delay Splitter ** and Combiner** are nodes for splitting an item or joining multiple items. Buffer , Conveyor and Fleet are entities of type edge for aiding in item transfer from one node to another Source and Sink for generating and collecting items All components can be customized, and extended easily. A Minimal Working Example \u00b6 An example that shows how to simulate a simple system with a machine and two buffers # System layout # SRC \u2500\u2500> BUF1 \u2500\u2500> MACHINE1 \u2500\u2500> BUF2 \u2500\u2500> SINK import factorysimpy from factorysimpy.nodes.machine import Machine from factorysimpy.edges.buffer import Buffer from factorysimpy.nodes.source import Source from factorysimpy.nodes.sink import Sink env = simpy . Environment () # Initializing nodes SRC = Source ( env , id = \"SRC\" , flow_item_type = \"item\" , inter_arrival_time = 0.8 , blocking = False , out_edge_selection = \"RANDOM\" ) MACHINE1 = Machine ( env , id = \"MACHINE1\" , work_capacity = 4 , processing_delay = 1.1 , blocking = False , in_edge_selection = \"RANDOM\" , out_edge_selection = \"RANDOM\" ) SINK = Sink ( env , id = \"SINK\" ) # Initializing edges BUF1 = Buffer ( env , id = \"BUF1\" , store_capacity = 4 , delay = 0.5 , mode = \"FIFO\" ) BUF2 = Buffer ( env , id = \"BUF2\" , store_capacity = 4 , delay = 0.5 , mode = \"FIFO\" ) # Adding connections BUF1 . connect ( SRC , MACHINE1 ) BUF2 . connect ( MACHINE1 , SINK ) env . run ( until = 10 ) Directory Structure \u00b6 FactorySimPy/ \u251c\u2500 src/factorysimpy/ \u2502 \u251c\u2500 nodes/ # Processor, Source, Sink, Combiner, Splitter \u2502 \u251c\u2500 edges/ # Buffer, Conveyor, Fleet \u2502 \u251c\u2500 base/ # SimPy extensions \u2502 \u251c\u2500 constructs/ # constructs to simplify model creation \u2502 \u251c\u2500 helper/ # Other necessary classes like Item, baseflowitem, pallet \u2502 \u2514\u2500 utils/ # Other utility functions \u251c\u2500 docs/ \u2502 \u251c\u2500 index.md \u2502 \u2514\u2500 examples/ \u251c\u2500 tests/ \u251c\u2500 examples/ \u2514\u2500 README.md","title":"Getting Started"},{"location":"getting_started/#getting-started-with-factorysimpy","text":"Welcome to FactorySimPy \u2013 a lightweight, open-source component library for discrete-event simulation (DES) of manufacturing systems, built on top of SimPy v4.1.1 . This guide will help you to get started with the packages in a few minutes.","title":"Getting Started with FactorySimPy"},{"location":"getting_started/#installation","text":"Install FactorySimPy. Make sure you have Python \u2265 3.8. From Github Install SimPy (if not already installed) pip install simpy Install FactorySimPy pip install git+https://github.com/FactorySimPy/FactorySimPy.git","title":"Installation"},{"location":"getting_started/#what-you-can-model","text":"FactorySimPy lets you simulate typical manufacturing scenarios using ready-made building blocks like: Machine is a node with configurable processing delay Splitter ** and Combiner** are nodes for splitting an item or joining multiple items. Buffer , Conveyor and Fleet are entities of type edge for aiding in item transfer from one node to another Source and Sink for generating and collecting items All components can be customized, and extended easily.","title":"What You Can Model"},{"location":"getting_started/#a-minimal-working-example","text":"An example that shows how to simulate a simple system with a machine and two buffers # System layout # SRC \u2500\u2500> BUF1 \u2500\u2500> MACHINE1 \u2500\u2500> BUF2 \u2500\u2500> SINK import factorysimpy from factorysimpy.nodes.machine import Machine from factorysimpy.edges.buffer import Buffer from factorysimpy.nodes.source import Source from factorysimpy.nodes.sink import Sink env = simpy . Environment () # Initializing nodes SRC = Source ( env , id = \"SRC\" , flow_item_type = \"item\" , inter_arrival_time = 0.8 , blocking = False , out_edge_selection = \"RANDOM\" ) MACHINE1 = Machine ( env , id = \"MACHINE1\" , work_capacity = 4 , processing_delay = 1.1 , blocking = False , in_edge_selection = \"RANDOM\" , out_edge_selection = \"RANDOM\" ) SINK = Sink ( env , id = \"SINK\" ) # Initializing edges BUF1 = Buffer ( env , id = \"BUF1\" , store_capacity = 4 , delay = 0.5 , mode = \"FIFO\" ) BUF2 = Buffer ( env , id = \"BUF2\" , store_capacity = 4 , delay = 0.5 , mode = \"FIFO\" ) # Adding connections BUF1 . connect ( SRC , MACHINE1 ) BUF2 . connect ( MACHINE1 , SINK ) env . run ( until = 10 )","title":"A Minimal Working Example"},{"location":"getting_started/#directory-structure","text":"FactorySimPy/ \u251c\u2500 src/factorysimpy/ \u2502 \u251c\u2500 nodes/ # Processor, Source, Sink, Combiner, Splitter \u2502 \u251c\u2500 edges/ # Buffer, Conveyor, Fleet \u2502 \u251c\u2500 base/ # SimPy extensions \u2502 \u251c\u2500 constructs/ # constructs to simplify model creation \u2502 \u251c\u2500 helper/ # Other necessary classes like Item, baseflowitem, pallet \u2502 \u2514\u2500 utils/ # Other utility functions \u251c\u2500 docs/ \u2502 \u251c\u2500 index.md \u2502 \u2514\u2500 examples/ \u251c\u2500 tests/ \u251c\u2500 examples/ \u2514\u2500 README.md","title":"Directory Structure"},{"location":"interrupts/","text":"","title":"Modeling interrupts"},{"location":"license/","text":"MIT License(MIT) Copyright (c) 2024-2030 Lekshmi P, Neha Karanjkar Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"machine/","text":"Machine ( env , id , in_edges = None , out_edges = None , node_setup_time = 0 , work_capacity = 1 , processing_delay = 0 , blocking = True , in_edge_selection = 'FIRST_AVAILABLE' , out_edge_selection = 'FIRST_AVAILABLE' ) \u00b6 Bases: Node Machine represents a processing node in a factory simulation. This Machine can have multiple input edges and output edges. Parameters: state_rep ( tuple ) \u2013 Current state of the machine node representates as a tuple based on the state of the worker threads (num_worker_threads_processing, num_worker_threads_blocked). Worker threads can be either in the processing state or in the blocked state. Based on that machine can be in one or many of the following states: SETUP_STATE: Initial setup phase before machine starts to operate. Denoted as (-1,-1) IDLE_STATE: Worker threads waiting to receive items. Denoted as (0,0) ATLEAST_ONE_PROCESSING_STATE: Active state where items are being processed. State when atleast one thread is in processing state. ALL_ACTIVE_BLOCKED_STATE: The state when all the worker_threads that are currently active are in \"BLOCKED_STATE\" as they are waiting for the out edge to be available to accept the processed item. Number of active threads can be equal to greater than work_capacity. ALL_ACTIVE_PROCESSING_STATE: The state when all the active threads are in processing state. Number of active threads can be equal to greater than work_capacity. ATLEAST_ONE_BLOCKED_STATE: The state when atleast one of the worker_threads is in \"BLOCKED_STATE\" as it is waiting for the out edge to be available to accept the processed item. blocking ( bool , default: True ) \u2013 If True, the source waits until it can put an item into the out edge. If False, it discards the item if the out edge is full and cannot accept the item that is being pushed by the machine. work_capacity ( int , default: 1 ) \u2013 Maximum no. of processing that can be performed simultaneously.1 worker thread can process one item. processing_delay ( (None, int , float , Generator , Callable ) , default: 0 ) \u2013 Delay for processing items. Can be: None: Used when the processing time depends on parameters of the node object (like current state of the object) or environment. int or float: Used as a constant delay. Generator: A generator function yielding delay values over time. Callable: A function that returns a delay (int or float). in_edge_selection ( None or str or callable , default: 'FIRST_AVAILABLE' ) \u2013 Criterion or function for selecting the edge. Options include \"RANDOM\", \"ROUND_ROBIN\", \"FIRST_AVAILABLE\". None: None: Used when edge selction depends on parameters of the node object (like current state of the object) or environment. str: A string that specifies the selection method. \"RANDOM\": Selects a random edge. \"ROUND_ROBIN\": Selects edges in a round-robin manner. \"FIRST_AVAILABLE\": Selects the first out edge that can give an item. callable: A function that returns an edge index. out_edge_selection ( None or str or callable , default: 'FIRST_AVAILABLE' ) \u2013 Criterion or function for selecting the out edge. Options include \"RANDOM\", \"ROUND_ROBIN\", \"FIRST_AVAILABLE\". None: None: Used when out edge selction depends on parameters of the node object (like current state of the object) or environment. str: A string that specifies the selection method. \"RANDOM\": Selects a random out edge in the out_edges list. \"ROUND_ROBIN\": Selects out edges in a round-robin manner. \"FIRST_AVAILABLE\": Selects the first out edge that can accept an item. callable: A function that returns an edge index. Behavior The machine node represents components that process or modify the items that flow in the simulation model. It can have multiple incoming edges and multiple outgoing edge. Edge from which the item comes in and the edge to which processed item is pushed is decided using the method specified in the parameter in_edge_selection and out_edge_selection . Machine will transition through the states- SETUP_STATE , PROCESSING_STATE , IDLE_STATE and BLOCKED_STATE . The machine has a blocking behavior if blocking = True and gets blocked when all its worker threads have processed items and the out edge is full and cannot accept the item that is being pushed by the machine and waits until the out edge can accept the item. If blocking = False , the machine will discard the item if the out edge is full and cannot accept the item that is being pushed by the machine. Raises: AssertionError \u2013 If the Machine has no input or output edges. Output performance metrics: The key performance metrics of the Machine node is captured in stats attribute (dict) during a simulation run. last_state_change_time : Time when the state was last changed . num_item_processed : Total number of items generated . num_item_discarded : Total number of items discarded . total_time_spent_in_states : Dictionary with total time spent in each state . update_state_rep ( current_time ) \u00b6 Update the state representation tuple based on the current state of worker threads. Parameters: state ( str ) \u2013 The current state of the machine. current_time ( float ) \u2013 The current simulation time. add_in_edges ( edge ) \u00b6 Adds an in_edge to the node. Raises an error if the edge already exists in the in_edges list. Parameters: edge (Edge Object) \u2013 The edge to be added as an in_edge. add_out_edges ( edge ) \u00b6 Adds an out_edge to the node. Raises an error if the edge already exists in the out_edges list. Parameters: edge (Edge Object) \u2013 The edge to be added as an out_edge.","title":"Machine"},{"location":"machine/#factorysimpy.nodes.machine.Machine","text":"Bases: Node Machine represents a processing node in a factory simulation. This Machine can have multiple input edges and output edges. Parameters: state_rep ( tuple ) \u2013 Current state of the machine node representates as a tuple based on the state of the worker threads (num_worker_threads_processing, num_worker_threads_blocked). Worker threads can be either in the processing state or in the blocked state. Based on that machine can be in one or many of the following states: SETUP_STATE: Initial setup phase before machine starts to operate. Denoted as (-1,-1) IDLE_STATE: Worker threads waiting to receive items. Denoted as (0,0) ATLEAST_ONE_PROCESSING_STATE: Active state where items are being processed. State when atleast one thread is in processing state. ALL_ACTIVE_BLOCKED_STATE: The state when all the worker_threads that are currently active are in \"BLOCKED_STATE\" as they are waiting for the out edge to be available to accept the processed item. Number of active threads can be equal to greater than work_capacity. ALL_ACTIVE_PROCESSING_STATE: The state when all the active threads are in processing state. Number of active threads can be equal to greater than work_capacity. ATLEAST_ONE_BLOCKED_STATE: The state when atleast one of the worker_threads is in \"BLOCKED_STATE\" as it is waiting for the out edge to be available to accept the processed item. blocking ( bool , default: True ) \u2013 If True, the source waits until it can put an item into the out edge. If False, it discards the item if the out edge is full and cannot accept the item that is being pushed by the machine. work_capacity ( int , default: 1 ) \u2013 Maximum no. of processing that can be performed simultaneously.1 worker thread can process one item. processing_delay ( (None, int , float , Generator , Callable ) , default: 0 ) \u2013 Delay for processing items. Can be: None: Used when the processing time depends on parameters of the node object (like current state of the object) or environment. int or float: Used as a constant delay. Generator: A generator function yielding delay values over time. Callable: A function that returns a delay (int or float). in_edge_selection ( None or str or callable , default: 'FIRST_AVAILABLE' ) \u2013 Criterion or function for selecting the edge. Options include \"RANDOM\", \"ROUND_ROBIN\", \"FIRST_AVAILABLE\". None: None: Used when edge selction depends on parameters of the node object (like current state of the object) or environment. str: A string that specifies the selection method. \"RANDOM\": Selects a random edge. \"ROUND_ROBIN\": Selects edges in a round-robin manner. \"FIRST_AVAILABLE\": Selects the first out edge that can give an item. callable: A function that returns an edge index. out_edge_selection ( None or str or callable , default: 'FIRST_AVAILABLE' ) \u2013 Criterion or function for selecting the out edge. Options include \"RANDOM\", \"ROUND_ROBIN\", \"FIRST_AVAILABLE\". None: None: Used when out edge selction depends on parameters of the node object (like current state of the object) or environment. str: A string that specifies the selection method. \"RANDOM\": Selects a random out edge in the out_edges list. \"ROUND_ROBIN\": Selects out edges in a round-robin manner. \"FIRST_AVAILABLE\": Selects the first out edge that can accept an item. callable: A function that returns an edge index. Behavior The machine node represents components that process or modify the items that flow in the simulation model. It can have multiple incoming edges and multiple outgoing edge. Edge from which the item comes in and the edge to which processed item is pushed is decided using the method specified in the parameter in_edge_selection and out_edge_selection . Machine will transition through the states- SETUP_STATE , PROCESSING_STATE , IDLE_STATE and BLOCKED_STATE . The machine has a blocking behavior if blocking = True and gets blocked when all its worker threads have processed items and the out edge is full and cannot accept the item that is being pushed by the machine and waits until the out edge can accept the item. If blocking = False , the machine will discard the item if the out edge is full and cannot accept the item that is being pushed by the machine. Raises: AssertionError \u2013 If the Machine has no input or output edges. Output performance metrics: The key performance metrics of the Machine node is captured in stats attribute (dict) during a simulation run. last_state_change_time : Time when the state was last changed . num_item_processed : Total number of items generated . num_item_discarded : Total number of items discarded . total_time_spent_in_states : Dictionary with total time spent in each state .","title":"Machine"},{"location":"machine/#factorysimpy.nodes.machine.Machine.update_state_rep","text":"Update the state representation tuple based on the current state of worker threads. Parameters: state ( str ) \u2013 The current state of the machine. current_time ( float ) \u2013 The current simulation time.","title":"update_state_rep"},{"location":"machine/#factorysimpy.nodes.machine.Machine.add_in_edges","text":"Adds an in_edge to the node. Raises an error if the edge already exists in the in_edges list. Parameters: edge (Edge Object) \u2013 The edge to be added as an in_edge.","title":"add_in_edges"},{"location":"machine/#factorysimpy.nodes.machine.Machine.add_out_edges","text":"Adds an out_edge to the node. Raises an error if the edge already exists in the out_edges list. Parameters: edge (Edge Object) \u2013 The edge to be added as an out_edge.","title":"add_out_edges"},{"location":"monitoring/","text":"Monitoring and Measurement All components has an attribute stats that stores all the parameters that are required to analyse the performance of that component. The details of the parameters that are available in each of the components are below Source \u00b6 The source component reports the following key metrics: Total number of items generated Number of items discarded (non-blocking mode) Time spent in each state Machine \u00b6 The Machine component reports the following key metrics: Total number of items processed Time spent in each state Buffer \u00b6 The Buffer component reports the following key metrics: time averaged number of items available in buffer. Time spent in each state Conveyor \u00b6 The conveyor reports the following key metrics: Time averaged number of items Time spent in each state","title":"Monitoring and Measurement"},{"location":"monitoring/#source","text":"The source component reports the following key metrics: Total number of items generated Number of items discarded (non-blocking mode) Time spent in each state","title":"Source"},{"location":"monitoring/#machine","text":"The Machine component reports the following key metrics: Total number of items processed Time spent in each state","title":"Machine"},{"location":"monitoring/#buffer","text":"The Buffer component reports the following key metrics: time averaged number of items available in buffer. Time spent in each state","title":"Buffer"},{"location":"monitoring/#conveyor","text":"The conveyor reports the following key metrics: Time averaged number of items Time spent in each state","title":"Conveyor"},{"location":"nodes/","text":"Node \u00b6 Node ( env , id , in_edges = None , out_edges = None , node_setup_time = 0 ) \u00b6 Base class to represent an active entity in a manufacturing system, such as machines, splits, or joints. Parameters: id ( str ) \u2013 Identifier for the node. node_setup_time ( int, or float , default: 0 ) \u2013 Initial setup time for the node. Can be: int or float: Used as a constant delay. in_edges ( list , default: None ) \u2013 List of input edges connected to the node. out_edges ( list , default: None ) \u2013 List of output edges connected to the node. Raises: TypeError \u2013 If the type of env or id is incorrect. ValueError \u2013 If node_setup_time input is invalid. Source code in src/factorysimpy/nodes/node.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def __init__ ( self , env , id , in_edges = None , out_edges = None , node_setup_time = 0 ): # Type checks if not isinstance ( env , simpy . Environment ): raise TypeError ( \"env must be a simpy.Environment instance\" ) if not isinstance ( id , str ): raise TypeError ( \"name must be a string\" ) self . env = env self . id = id # Identifier for the node. self . node_setup_time = node_setup_time # Time taken to set up the node. self . in_edges = in_edges # List of input edges connected to the node. self . out_edges = out_edges #List of output edges connected to the node. if isinstance ( node_setup_time , ( int , float )): self . node_setup_time = node_setup_time else : raise ValueError ( \"Invalid node_setup_time value. Provide constant ( int or float).\" ) get_delay ( delay ) \u00b6 Returns value based on the type of parameter delay provided. Parameters: delay ( int, float, generator, or callable ) \u2013 The delay time, which can be: int or float: Used as a constant delay. generator: A generator instance yielding delay values. callable: A function that returns a delay values. Returns: \u2013 Returns a constant delay if delay is an int or float, a value yielded if delay is a generator, or the value returned from a Callable function if delay is callable. Source code in src/factorysimpy/nodes/node.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def get_delay ( self , delay ): \"\"\" Returns value based on the type of parameter `delay` provided. Args: delay (int, float, generator, or callable): The delay time, which can be: - int or float: Used as a constant delay. - generator: A generator instance yielding delay values. - callable: A function that returns a delay values. Returns: Returns a constant delay if `delay` is an int or float, a value yielded if `delay` is a generator, or the value returned from a Callable function if `delay` is callable. \"\"\" if hasattr ( delay , '__next__' ): # Generator instance val = next ( delay ) elif callable ( delay ): # Function val = delay () else : # int or float val = delay #print(self.id) assert val >= 0 , f \" { self . id } - Delay must be non-negative\" return val update_state ( new_state , current_time ) \u00b6 Update node state and track the time spent in the previous state. Parameters: new_state ( str ) \u2013 The new state to transition to. Must be one of \"SETUP_STATE\", \"GENERATING_STATE\", \"BLOCKED_STATE\". current_time ( float ) \u2013 The current simulation time. Source code in src/factorysimpy/nodes/node.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 def update_state ( self , new_state : str , current_time : float ): \"\"\" Update node state and track the time spent in the previous state. Args: new_state (str): The new state to transition to. Must be one of \"SETUP_STATE\", \"GENERATING_STATE\", \"BLOCKED_STATE\". current_time (float): The current simulation time. \"\"\" if self . state is not None and self . stats [ \"last_state_change_time\" ] is not None : elapsed = current_time - self . stats [ \"last_state_change_time\" ] self . stats [ \"total_time_spent_in_states\" ][ self . state ] = ( self . stats [ \"total_time_spent_in_states\" ] . get ( self . state , 0.0 ) + elapsed ) self . state = new_state self . stats [ \"last_state_change_time\" ] = current_time","title":"Node"},{"location":"nodes/#node","text":"","title":"Node"},{"location":"nodes/#factorysimpy.nodes.node.Node","text":"Base class to represent an active entity in a manufacturing system, such as machines, splits, or joints. Parameters: id ( str ) \u2013 Identifier for the node. node_setup_time ( int, or float , default: 0 ) \u2013 Initial setup time for the node. Can be: int or float: Used as a constant delay. in_edges ( list , default: None ) \u2013 List of input edges connected to the node. out_edges ( list , default: None ) \u2013 List of output edges connected to the node. Raises: TypeError \u2013 If the type of env or id is incorrect. ValueError \u2013 If node_setup_time input is invalid. Source code in src/factorysimpy/nodes/node.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def __init__ ( self , env , id , in_edges = None , out_edges = None , node_setup_time = 0 ): # Type checks if not isinstance ( env , simpy . Environment ): raise TypeError ( \"env must be a simpy.Environment instance\" ) if not isinstance ( id , str ): raise TypeError ( \"name must be a string\" ) self . env = env self . id = id # Identifier for the node. self . node_setup_time = node_setup_time # Time taken to set up the node. self . in_edges = in_edges # List of input edges connected to the node. self . out_edges = out_edges #List of output edges connected to the node. if isinstance ( node_setup_time , ( int , float )): self . node_setup_time = node_setup_time else : raise ValueError ( \"Invalid node_setup_time value. Provide constant ( int or float).\" )","title":"Node"},{"location":"nodes/#factorysimpy.nodes.node.Node.get_delay","text":"Returns value based on the type of parameter delay provided. Parameters: delay ( int, float, generator, or callable ) \u2013 The delay time, which can be: int or float: Used as a constant delay. generator: A generator instance yielding delay values. callable: A function that returns a delay values. Returns: \u2013 Returns a constant delay if delay is an int or float, a value yielded if delay is a generator, or the value returned from a Callable function if delay is callable. Source code in src/factorysimpy/nodes/node.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def get_delay ( self , delay ): \"\"\" Returns value based on the type of parameter `delay` provided. Args: delay (int, float, generator, or callable): The delay time, which can be: - int or float: Used as a constant delay. - generator: A generator instance yielding delay values. - callable: A function that returns a delay values. Returns: Returns a constant delay if `delay` is an int or float, a value yielded if `delay` is a generator, or the value returned from a Callable function if `delay` is callable. \"\"\" if hasattr ( delay , '__next__' ): # Generator instance val = next ( delay ) elif callable ( delay ): # Function val = delay () else : # int or float val = delay #print(self.id) assert val >= 0 , f \" { self . id } - Delay must be non-negative\" return val","title":"get_delay"},{"location":"nodes/#factorysimpy.nodes.node.Node.update_state","text":"Update node state and track the time spent in the previous state. Parameters: new_state ( str ) \u2013 The new state to transition to. Must be one of \"SETUP_STATE\", \"GENERATING_STATE\", \"BLOCKED_STATE\". current_time ( float ) \u2013 The current simulation time. Source code in src/factorysimpy/nodes/node.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 def update_state ( self , new_state : str , current_time : float ): \"\"\" Update node state and track the time spent in the previous state. Args: new_state (str): The new state to transition to. Must be one of \"SETUP_STATE\", \"GENERATING_STATE\", \"BLOCKED_STATE\". current_time (float): The current simulation time. \"\"\" if self . state is not None and self . stats [ \"last_state_change_time\" ] is not None : elapsed = current_time - self . stats [ \"last_state_change_time\" ] self . stats [ \"total_time_spent_in_states\" ][ self . state ] = ( self . stats [ \"total_time_spent_in_states\" ] . get ( self . state , 0.0 ) + elapsed ) self . state = new_state self . stats [ \"last_state_change_time\" ] = current_time","title":"update_state"},{"location":"priorityreqstore/","text":"SortedQueue ( maxlen = None ) \u00b6 Bases: list Queue for sorting events by their :attr: ~PriorityRequest.key attribute. maxlen = maxlen instance-attribute \u00b6 Maximum length of the queue. append ( item ) \u00b6 Sort item into the queue. Raise a :exc: RuntimeError if the queue is full. PriorityGet ( resource , priority = 0 ) \u00b6 Bases: Get priority = priority instance-attribute \u00b6 The priority of this request. A smaller number means higher priority. time = resource . _env . now instance-attribute \u00b6 The time at which the request was made. PriorityPut ( resource , item , priority = 0 ) \u00b6 Bases: Put priority = priority instance-attribute \u00b6 The priority of this request. A smaller number means higher priority. time = resource . _env . now instance-attribute \u00b6 The time at which the request was made. PriorityReqStore ( env , capacity = 1 ) \u00b6 Bases: Store This is a class derived from SimPy's Store class and has extra capabilities that makes it a priority-based store for put and get. Processes can pass a priority as argument in the put and get request. Request with lower values of priority yields first among all get(or put) requests. If two requests with same priority are placed from two processes then FIFO order is followed to yield the requests. get = BoundClass ( PriorityGet ) class-attribute instance-attribute \u00b6 yields a get request with the given priority . put = BoundClass ( PriorityPut ) class-attribute instance-attribute \u00b6 yields a put request with the given priority","title":"Priorityreqstore"},{"location":"priorityreqstore/#factorysimpy.base.priority_req_store.SortedQueue","text":"Bases: list Queue for sorting events by their :attr: ~PriorityRequest.key attribute.","title":"SortedQueue"},{"location":"priorityreqstore/#factorysimpy.base.priority_req_store.SortedQueue.maxlen","text":"Maximum length of the queue.","title":"maxlen"},{"location":"priorityreqstore/#factorysimpy.base.priority_req_store.SortedQueue.append","text":"Sort item into the queue. Raise a :exc: RuntimeError if the queue is full.","title":"append"},{"location":"priorityreqstore/#factorysimpy.base.priority_req_store.PriorityGet","text":"Bases: Get","title":"PriorityGet"},{"location":"priorityreqstore/#factorysimpy.base.priority_req_store.PriorityGet.priority","text":"The priority of this request. A smaller number means higher priority.","title":"priority"},{"location":"priorityreqstore/#factorysimpy.base.priority_req_store.PriorityGet.time","text":"The time at which the request was made.","title":"time"},{"location":"priorityreqstore/#factorysimpy.base.priority_req_store.PriorityPut","text":"Bases: Put","title":"PriorityPut"},{"location":"priorityreqstore/#factorysimpy.base.priority_req_store.PriorityPut.priority","text":"The priority of this request. A smaller number means higher priority.","title":"priority"},{"location":"priorityreqstore/#factorysimpy.base.priority_req_store.PriorityPut.time","text":"The time at which the request was made.","title":"time"},{"location":"priorityreqstore/#factorysimpy.base.priority_req_store.PriorityReqStore","text":"Bases: Store This is a class derived from SimPy's Store class and has extra capabilities that makes it a priority-based store for put and get. Processes can pass a priority as argument in the put and get request. Request with lower values of priority yields first among all get(or put) requests. If two requests with same priority are placed from two processes then FIFO order is followed to yield the requests.","title":"PriorityReqStore"},{"location":"priorityreqstore/#factorysimpy.base.priority_req_store.PriorityReqStore.get","text":"yields a get request with the given priority .","title":"get"},{"location":"priorityreqstore/#factorysimpy.base.priority_req_store.PriorityReqStore.put","text":"yields a put request with the given priority","title":"put"},{"location":"reservablepriorityreqfilterstore/","text":"ReservablePriorityReqFilterStore ( env , capacity = float ( 'inf' ), trigger_delay = 0 ) \u00b6 Bases: FilterStore This is a class that is derived from SimPy's Store class and has extra capabilities that makes it a priority-based reservable store for processes to reserve space for storing and retrieving items with priority-based access. It supports user tp only get items that match a user criteria Processes can use reserve_put() and reserve_get() methods to get notified when a space becomes available in the store or when an item gets available in the ReservablePriorityReqStore. These methods returns a unique event (SimPy.Event) to the process for every reserve requests it makes. Processes can also pass a priority as argument in the request. Lower values indicate higher priority. Filter to be used while using \"get\" can be passed in the reserve_get request. get and put are two methods that can be used for item storing and retrieval from ReservablePriorityReqStore. Process has to make a prior reservation and pass the associated reservation event as argument in the get and put requests. ReservablePriorityReqStore maintains separate queues for reserve_put and reserve_get operations to ensures that only processes with valid reservations can store or retrieve items. ReservablePriorityReqStore preserves item order by associating an unreserved item in the store with a reservation event by index when a reserve_get() request is made. As a result, it maintains a list of reserved events to preserve item order. It also allows users to cancel an already placed reserve_get or reserve_put request even if it is yielded. It also handles the dissociation of the event and item done at the time of reservation when an already yielded event is canceled. Attributes: reserved_events ( list ) \u2013 Maintains events corresponding to reserved items to preserve item order by index reserve_put_queue ( list ) \u2013 Queue for managing reserve_put reservations reservations_put ( list ) \u2013 List of successful put reservations reserve_get_queue ( list ) \u2013 Queue for managing reserve_get reservations reservations_get ( list ) \u2013 List of successful get reservations trigger_delay ( int ) \u2013 Delay time after which a trigger_reserve_get is called to allow waiting get calls to succeed. Initializes a reservable store with priority-based reservations. Args: capacity (int, optional): The maximum number of items the store can hold. Defaults to infinity. reserve_put ( priority = 0 ) \u00b6 Create a reservation request to put an item into the store. This function generates a SimPy event representing a reservation request. The event is assigned attributes such as priority, resource name, and the process making the request. The event is then added to reserve_put_queue , which is maintained in priority order. After adding the event to the queue, _trigger_reserve_put is called to process any pending reservations. Parameters: priority ( int , default: 0 ) \u2013 The priority level of the reservation request. Lower values indicate higher priority. Defaults to 0. Returns: event ( Event ) \u2013 A reservation event that will succeed when space is available. reserve_put_cancel ( put_event_to_cancel ) \u00b6 Cancel a previously made reserve_put request. This method allows a process to cancel its reservation for putting an item into the store. If the reservation exists in the reserve_put_queue , it is removed before triggering _trigger_reserve_put to process any pending reservations. If the reservation is already in reservations_put , it is also removed and _trigger_reserve_put is triggered. Parameters: put_event_to_cancel ( Event ) \u2013 The reservation event that needs to be canceled. Returns: proceed ( bool ) \u2013 True if the reservation was successfully canceled. Raises: RuntimeError \u2013 If the specified event does not exist in reserve_put_queue or reservations_put . reserve_get_cancel ( get_event_to_cancel ) \u00b6 Cancel a previously made reserve_get request. This method allows a process to cancel its reservation for retrieving an item from the store. If the reservation exists in the reserve_get_queue , it is removed, and _trigger_reserve_get() is called to process any remaining reservations. If the reservation is already in reservations_get , it is removed, and the corresponding item is repositioned in the store to maintain order. _trigger_reserve_get() is then triggered to handle pending reservations. Parameters: get_event_to_cancel ( Event ) \u2013 The reservation event that needs to be canceled. Returns: proceed ( bool ) \u2013 True if the reservation was successfully canceled. Raises: RuntimeError \u2013 If the specified event does not exist in reserve_get_queue or reservations_get . reserve_get ( priority = 0 , filter = None ) \u00b6 Create a reservation request to retrieve an item from the store. This method generates a SimPy event representing a request to reserve an item for retrieval ( get ). The event is assigned attributes such as priority, the resource it belongs to, and the process making the request. The event is then added to reserve_get_queue , which is maintained in priority order, and _trigger_reserve_get() is called to process pending reservations if items are available. Parameters: priority ( int , default: 0 ) \u2013 The priority level of the reservation request. Lower values indicate higher priority. Defaults to 0. filter ( filter=lambdaitem=True , default: None ) \u2013 Filter to be used while using \"reserve_get Returns: event ( Event ) \u2013 A reservation event that will succeed when an item becomes available. get ( get_event ) \u00b6 Retrieve an item from the store after a successful reservation. This method attempts to retrieve an item associated with a reserve_get event. If the reservation exists, it triggers _trigger_get to retrieve the item. If successful, _trigger_reserve_put is called to process any pending reserve_put requests. If the item retrieval fails, an error message is raised. Parameters: get_event ( Event ) \u2013 The reservation event associated with the request. Returns: item ( Object ) \u2013 The retrieved item if successful, otherwise raises an error Raises: RuntimeError \u2013 If no reservations are available in the reservations_get RuntimeError \u2013 If item returned is None put ( put_event , item ) \u00b6 Perform a put operation on the store and trigger any pending reserve_get requests. Ensures that only processes with a valid reservation can put items into the store. If the put operation succeeds, it triggers _trigger_reserve_get to process pending get requests. Parameters: put_event ( Event ) \u2013 The event corresponding to the reservation. item ( object ) \u2013 The item to be added to the store. Returns: proceed ( bool ) \u2013 True if the put operation succeeded, False otherwise. Raises: RuntimeError \u2013 If no reservations are available in the reservations_put RuntimeError \u2013 If proceed is False after put operation","title":"Reservablepriorityreqfilterstore"},{"location":"reservablepriorityreqfilterstore/#factorysimpy.base.reservable_priority_req_filter_store.ReservablePriorityReqFilterStore","text":"Bases: FilterStore This is a class that is derived from SimPy's Store class and has extra capabilities that makes it a priority-based reservable store for processes to reserve space for storing and retrieving items with priority-based access. It supports user tp only get items that match a user criteria Processes can use reserve_put() and reserve_get() methods to get notified when a space becomes available in the store or when an item gets available in the ReservablePriorityReqStore. These methods returns a unique event (SimPy.Event) to the process for every reserve requests it makes. Processes can also pass a priority as argument in the request. Lower values indicate higher priority. Filter to be used while using \"get\" can be passed in the reserve_get request. get and put are two methods that can be used for item storing and retrieval from ReservablePriorityReqStore. Process has to make a prior reservation and pass the associated reservation event as argument in the get and put requests. ReservablePriorityReqStore maintains separate queues for reserve_put and reserve_get operations to ensures that only processes with valid reservations can store or retrieve items. ReservablePriorityReqStore preserves item order by associating an unreserved item in the store with a reservation event by index when a reserve_get() request is made. As a result, it maintains a list of reserved events to preserve item order. It also allows users to cancel an already placed reserve_get or reserve_put request even if it is yielded. It also handles the dissociation of the event and item done at the time of reservation when an already yielded event is canceled. Attributes: reserved_events ( list ) \u2013 Maintains events corresponding to reserved items to preserve item order by index reserve_put_queue ( list ) \u2013 Queue for managing reserve_put reservations reservations_put ( list ) \u2013 List of successful put reservations reserve_get_queue ( list ) \u2013 Queue for managing reserve_get reservations reservations_get ( list ) \u2013 List of successful get reservations trigger_delay ( int ) \u2013 Delay time after which a trigger_reserve_get is called to allow waiting get calls to succeed. Initializes a reservable store with priority-based reservations. Args: capacity (int, optional): The maximum number of items the store can hold. Defaults to infinity.","title":"ReservablePriorityReqFilterStore"},{"location":"reservablepriorityreqfilterstore/#factorysimpy.base.reservable_priority_req_filter_store.ReservablePriorityReqFilterStore.reserve_put","text":"Create a reservation request to put an item into the store. This function generates a SimPy event representing a reservation request. The event is assigned attributes such as priority, resource name, and the process making the request. The event is then added to reserve_put_queue , which is maintained in priority order. After adding the event to the queue, _trigger_reserve_put is called to process any pending reservations. Parameters: priority ( int , default: 0 ) \u2013 The priority level of the reservation request. Lower values indicate higher priority. Defaults to 0. Returns: event ( Event ) \u2013 A reservation event that will succeed when space is available.","title":"reserve_put"},{"location":"reservablepriorityreqfilterstore/#factorysimpy.base.reservable_priority_req_filter_store.ReservablePriorityReqFilterStore.reserve_put_cancel","text":"Cancel a previously made reserve_put request. This method allows a process to cancel its reservation for putting an item into the store. If the reservation exists in the reserve_put_queue , it is removed before triggering _trigger_reserve_put to process any pending reservations. If the reservation is already in reservations_put , it is also removed and _trigger_reserve_put is triggered. Parameters: put_event_to_cancel ( Event ) \u2013 The reservation event that needs to be canceled. Returns: proceed ( bool ) \u2013 True if the reservation was successfully canceled. Raises: RuntimeError \u2013 If the specified event does not exist in reserve_put_queue or reservations_put .","title":"reserve_put_cancel"},{"location":"reservablepriorityreqfilterstore/#factorysimpy.base.reservable_priority_req_filter_store.ReservablePriorityReqFilterStore.reserve_get_cancel","text":"Cancel a previously made reserve_get request. This method allows a process to cancel its reservation for retrieving an item from the store. If the reservation exists in the reserve_get_queue , it is removed, and _trigger_reserve_get() is called to process any remaining reservations. If the reservation is already in reservations_get , it is removed, and the corresponding item is repositioned in the store to maintain order. _trigger_reserve_get() is then triggered to handle pending reservations. Parameters: get_event_to_cancel ( Event ) \u2013 The reservation event that needs to be canceled. Returns: proceed ( bool ) \u2013 True if the reservation was successfully canceled. Raises: RuntimeError \u2013 If the specified event does not exist in reserve_get_queue or reservations_get .","title":"reserve_get_cancel"},{"location":"reservablepriorityreqfilterstore/#factorysimpy.base.reservable_priority_req_filter_store.ReservablePriorityReqFilterStore.reserve_get","text":"Create a reservation request to retrieve an item from the store. This method generates a SimPy event representing a request to reserve an item for retrieval ( get ). The event is assigned attributes such as priority, the resource it belongs to, and the process making the request. The event is then added to reserve_get_queue , which is maintained in priority order, and _trigger_reserve_get() is called to process pending reservations if items are available. Parameters: priority ( int , default: 0 ) \u2013 The priority level of the reservation request. Lower values indicate higher priority. Defaults to 0. filter ( filter=lambdaitem=True , default: None ) \u2013 Filter to be used while using \"reserve_get Returns: event ( Event ) \u2013 A reservation event that will succeed when an item becomes available.","title":"reserve_get"},{"location":"reservablepriorityreqfilterstore/#factorysimpy.base.reservable_priority_req_filter_store.ReservablePriorityReqFilterStore.get","text":"Retrieve an item from the store after a successful reservation. This method attempts to retrieve an item associated with a reserve_get event. If the reservation exists, it triggers _trigger_get to retrieve the item. If successful, _trigger_reserve_put is called to process any pending reserve_put requests. If the item retrieval fails, an error message is raised. Parameters: get_event ( Event ) \u2013 The reservation event associated with the request. Returns: item ( Object ) \u2013 The retrieved item if successful, otherwise raises an error Raises: RuntimeError \u2013 If no reservations are available in the reservations_get RuntimeError \u2013 If item returned is None","title":"get"},{"location":"reservablepriorityreqfilterstore/#factorysimpy.base.reservable_priority_req_filter_store.ReservablePriorityReqFilterStore.put","text":"Perform a put operation on the store and trigger any pending reserve_get requests. Ensures that only processes with a valid reservation can put items into the store. If the put operation succeeds, it triggers _trigger_reserve_get to process pending get requests. Parameters: put_event ( Event ) \u2013 The event corresponding to the reservation. item ( object ) \u2013 The item to be added to the store. Returns: proceed ( bool ) \u2013 True if the put operation succeeded, False otherwise. Raises: RuntimeError \u2013 If no reservations are available in the reservations_put RuntimeError \u2013 If proceed is False after put operation","title":"put"},{"location":"reservablepriorityreqstore/","text":"ReservablePriorityReqStore ( env , capacity = float ( 'inf' )) \u00b6 Bases: Store This is a class that is derived from SimPy's Store class and has extra capabilities that makes it a priority-based reservable store for processes to reserve space for storing and retrieving items with priority-based access. Processes can use reserve_put() and reserve_get() methods to get notified when a space becomes available in the store or when an item gets available in the ReservablePriorityReqStore. These methods returns a unique event (SimPy.Event) to the process for every reserve requests it makes. Processes can also pass a priority as argument in the request. Lower values indicate higher priority. get and put are two methods that can be used for item storing and retrieval from ReservablePriorityReqStore. Process has to make a prior reservation and pass the associated reservation event as argument in the get and put requests. ReservablePriorityReqStore maintains separate queues for reserve_put and reserve_get operations to ensures that only processes with valid reservations can store or retrieve items. ReservablePriorityReqStore preserves item order by associating an unreserved item in the store with a reservation event by index when a reserve_get() request is made. As a result, it maintains a list of reserved events to preserve item order. It also allows users to cancel an already placed reserve_get or reserve_put request even if it is yielded. It also handles the dissociation of the event and item done at the time of reservation when an already yielded event is canceled. Attributes: reserved_events ( list ) \u2013 Maintains events corresponding to reserved items to preserve item order by index reserve_put_queue ( list ) \u2013 Queue for managing reserve_put reservations reservations_put ( list ) \u2013 List of successful put reservations reserve_get_queue ( list ) \u2013 Queue for managing reserve_get reservations reservations_get ( list ) \u2013 List of successful get reservations Initializes a reservable store with priority-based reservations. Args: capacity (int, optional): The maximum number of items the store can hold. Defaults to infinity. reserve_put ( priority = 0 ) \u00b6 Create a reservation request to put an item into the store. This function generates a SimPy event representing a reservation request. The event is assigned attributes such as priority, resource name, and the process making the request. The event is then added to reserve_put_queue , which is maintained in priority order. After adding the event to the queue, _trigger_reserve_put is called to process any pending reservations. Parameters: priority ( int , default: 0 ) \u2013 The priority level of the reservation request. Lower values indicate higher priority. Defaults to 0. Returns: event ( Event ) \u2013 A reservation event that will succeed when space is available. reserve_put_cancel ( put_event_to_cancel ) \u00b6 Cancel a previously made reserve_put request. This method allows a process to cancel its reservation for putting an item into the store. If the reservation exists in the reserve_put_queue , it is removed before triggering _trigger_reserve_put to process any pending reservations. If the reservation is already in reservations_put , it is also removed and _trigger_reserve_put is triggered. Parameters: put_event_to_cancel ( Event ) \u2013 The reservation event that needs to be canceled. Returns: proceed ( bool ) \u2013 True if the reservation was successfully canceled. Raises: RuntimeError \u2013 If the specified event does not exist in reserve_put_queue or reservations_put . reserve_get_cancel ( get_event_to_cancel ) \u00b6 Cancel a previously made reserve_get request. This method allows a process to cancel its reservation for retrieving an item from the store. If the reservation exists in the reserve_get_queue , it is removed, and _trigger_reserve_get() is called to process any remaining reservations. If the reservation is already in reservations_get , it is removed, and the corresponding item is repositioned in the store to maintain order. _trigger_reserve_get() is then triggered to handle pending reservations. Parameters: get_event_to_cancel ( Event ) \u2013 The reservation event that needs to be canceled. Returns: proceed ( bool ) \u2013 True if the reservation was successfully canceled. Raises: RuntimeError \u2013 If the specified event does not exist in reserve_get_queue or reservations_get . reserve_get ( priority = 0 ) \u00b6 Create a reservation request to retrieve an item from the store. This method generates a SimPy event representing a request to reserve an item for retrieval ( get ). The event is assigned attributes such as priority, the resource it belongs to, and the process making the request. The event is then added to reserve_get_queue , which is maintained in priority order, and _trigger_reserve_get() is called to process pending reservations if items are available. Parameters: priority ( int , default: 0 ) \u2013 The priority level of the reservation request. Lower values indicate higher priority. Defaults to 0. Returns: event ( Event ) \u2013 A reservation event that will succeed when an item becomes available. get ( get_event ) \u00b6 Retrieve an item from the store after a successful reservation. This method attempts to retrieve an item associated with a reserve_get event. If the reservation exists, it triggers _trigger_get to retrieve the item. If successful, _trigger_reserve_put is called to process any pending reserve_put requests. If the item retrieval fails, an error message is raised. Parameters: get_event ( Event ) \u2013 The reservation event associated with the request. Returns: item ( Object ) \u2013 The retrieved item if successful, otherwise raises an error Raises: RuntimeError \u2013 If no reservations are available in the reservations_get RuntimeError \u2013 If item returned is None put ( put_event , item ) \u00b6 Perform a put operation on the store and trigger any pending reserve_get requests. Ensures that only processes with a valid reservation can put items into the store. If the put operation succeeds, it triggers _trigger_reserve_get to process pending get requests. Parameters: put_event ( Event ) \u2013 The event corresponding to the reservation. item ( object ) \u2013 The item to be added to the store. Returns: proceed ( bool ) \u2013 True if the put operation succeeded, False otherwise. Raises: RuntimeError \u2013 If no reservations are available in the reservations_put RuntimeError \u2013 If proceed is False after put operation","title":"Reservablepriorityreqstore"},{"location":"reservablepriorityreqstore/#factorysimpy.base.reservable_priority_req_store.ReservablePriorityReqStore","text":"Bases: Store This is a class that is derived from SimPy's Store class and has extra capabilities that makes it a priority-based reservable store for processes to reserve space for storing and retrieving items with priority-based access. Processes can use reserve_put() and reserve_get() methods to get notified when a space becomes available in the store or when an item gets available in the ReservablePriorityReqStore. These methods returns a unique event (SimPy.Event) to the process for every reserve requests it makes. Processes can also pass a priority as argument in the request. Lower values indicate higher priority. get and put are two methods that can be used for item storing and retrieval from ReservablePriorityReqStore. Process has to make a prior reservation and pass the associated reservation event as argument in the get and put requests. ReservablePriorityReqStore maintains separate queues for reserve_put and reserve_get operations to ensures that only processes with valid reservations can store or retrieve items. ReservablePriorityReqStore preserves item order by associating an unreserved item in the store with a reservation event by index when a reserve_get() request is made. As a result, it maintains a list of reserved events to preserve item order. It also allows users to cancel an already placed reserve_get or reserve_put request even if it is yielded. It also handles the dissociation of the event and item done at the time of reservation when an already yielded event is canceled. Attributes: reserved_events ( list ) \u2013 Maintains events corresponding to reserved items to preserve item order by index reserve_put_queue ( list ) \u2013 Queue for managing reserve_put reservations reservations_put ( list ) \u2013 List of successful put reservations reserve_get_queue ( list ) \u2013 Queue for managing reserve_get reservations reservations_get ( list ) \u2013 List of successful get reservations Initializes a reservable store with priority-based reservations. Args: capacity (int, optional): The maximum number of items the store can hold. Defaults to infinity.","title":"ReservablePriorityReqStore"},{"location":"reservablepriorityreqstore/#factorysimpy.base.reservable_priority_req_store.ReservablePriorityReqStore.reserve_put","text":"Create a reservation request to put an item into the store. This function generates a SimPy event representing a reservation request. The event is assigned attributes such as priority, resource name, and the process making the request. The event is then added to reserve_put_queue , which is maintained in priority order. After adding the event to the queue, _trigger_reserve_put is called to process any pending reservations. Parameters: priority ( int , default: 0 ) \u2013 The priority level of the reservation request. Lower values indicate higher priority. Defaults to 0. Returns: event ( Event ) \u2013 A reservation event that will succeed when space is available.","title":"reserve_put"},{"location":"reservablepriorityreqstore/#factorysimpy.base.reservable_priority_req_store.ReservablePriorityReqStore.reserve_put_cancel","text":"Cancel a previously made reserve_put request. This method allows a process to cancel its reservation for putting an item into the store. If the reservation exists in the reserve_put_queue , it is removed before triggering _trigger_reserve_put to process any pending reservations. If the reservation is already in reservations_put , it is also removed and _trigger_reserve_put is triggered. Parameters: put_event_to_cancel ( Event ) \u2013 The reservation event that needs to be canceled. Returns: proceed ( bool ) \u2013 True if the reservation was successfully canceled. Raises: RuntimeError \u2013 If the specified event does not exist in reserve_put_queue or reservations_put .","title":"reserve_put_cancel"},{"location":"reservablepriorityreqstore/#factorysimpy.base.reservable_priority_req_store.ReservablePriorityReqStore.reserve_get_cancel","text":"Cancel a previously made reserve_get request. This method allows a process to cancel its reservation for retrieving an item from the store. If the reservation exists in the reserve_get_queue , it is removed, and _trigger_reserve_get() is called to process any remaining reservations. If the reservation is already in reservations_get , it is removed, and the corresponding item is repositioned in the store to maintain order. _trigger_reserve_get() is then triggered to handle pending reservations. Parameters: get_event_to_cancel ( Event ) \u2013 The reservation event that needs to be canceled. Returns: proceed ( bool ) \u2013 True if the reservation was successfully canceled. Raises: RuntimeError \u2013 If the specified event does not exist in reserve_get_queue or reservations_get .","title":"reserve_get_cancel"},{"location":"reservablepriorityreqstore/#factorysimpy.base.reservable_priority_req_store.ReservablePriorityReqStore.reserve_get","text":"Create a reservation request to retrieve an item from the store. This method generates a SimPy event representing a request to reserve an item for retrieval ( get ). The event is assigned attributes such as priority, the resource it belongs to, and the process making the request. The event is then added to reserve_get_queue , which is maintained in priority order, and _trigger_reserve_get() is called to process pending reservations if items are available. Parameters: priority ( int , default: 0 ) \u2013 The priority level of the reservation request. Lower values indicate higher priority. Defaults to 0. Returns: event ( Event ) \u2013 A reservation event that will succeed when an item becomes available.","title":"reserve_get"},{"location":"reservablepriorityreqstore/#factorysimpy.base.reservable_priority_req_store.ReservablePriorityReqStore.get","text":"Retrieve an item from the store after a successful reservation. This method attempts to retrieve an item associated with a reserve_get event. If the reservation exists, it triggers _trigger_get to retrieve the item. If successful, _trigger_reserve_put is called to process any pending reserve_put requests. If the item retrieval fails, an error message is raised. Parameters: get_event ( Event ) \u2013 The reservation event associated with the request. Returns: item ( Object ) \u2013 The retrieved item if successful, otherwise raises an error Raises: RuntimeError \u2013 If no reservations are available in the reservations_get RuntimeError \u2013 If item returned is None","title":"get"},{"location":"reservablepriorityreqstore/#factorysimpy.base.reservable_priority_req_store.ReservablePriorityReqStore.put","text":"Perform a put operation on the store and trigger any pending reserve_get requests. Ensures that only processes with a valid reservation can put items into the store. If the put operation succeeds, it triggers _trigger_reserve_get to process pending get requests. Parameters: put_event ( Event ) \u2013 The event corresponding to the reservation. item ( object ) \u2013 The item to be added to the store. Returns: proceed ( bool ) \u2013 True if the put operation succeeded, False otherwise. Raises: RuntimeError \u2013 If no reservations are available in the reservations_put RuntimeError \u2013 If proceed is False after put operation","title":"put"},{"location":"sink/","text":"Sink ( env , id , in_edges = None , node_setup_time = 0 ) \u00b6 Bases: Node A Sink is a terminal node that collects flow items at the end. Once an item enters the Sink, it is considered to have exited the system and cannot be retrieved or processed further This sink can have multiple input edges and no output edges. Raises AssertionError: If the sink does not have at least 1 input edge or has an output edge.","title":"Sink"},{"location":"sink/#factorysimpy.nodes.sink.Sink","text":"Bases: Node A Sink is a terminal node that collects flow items at the end. Once an item enters the Sink, it is considered to have exited the system and cannot be retrieved or processed further This sink can have multiple input edges and no output edges. Raises AssertionError: If the sink does not have at least 1 input edge or has an output edge.","title":"Sink"},{"location":"source/","text":"Source ( env , id , in_edges = None , out_edges = None , item_length = 1 , flow_item_type = 'item' , inter_arrival_time = 0 , blocking = False , out_edge_selection = 'FIRST_AVAILABLE' ) \u00b6 Bases: Node Parameters: state ( str ) \u2013 Current state of the source node. One of : SETUP_STATE: Initial setup phase before item generation starts. GENERATING_STATE: Actively generating and dispatching items. BLOCKED_STATE: Waiting to transfer item when edge is full (in blocking mode). inter_arrival_time ( None, int, float, generator, or callable , default: 0 ) \u2013 Time between item generations. Can be: None: Used when the setup time depends on parameters of the node object (like current state of the object) or environment. int or float: Used as a constant delay. Callable: A function that returns a delay (int or float). Generator: A generator function yielding delay values over time. flow_item_type ( str , default: 'item' ) \u2013 Type of item to be generated. Default is \"item\". Can be \"item\" : Smallest unit of discrete item and it cannot hold other items inside. \"pallet\" : Entities that can store multiple smaller units of items blocking ( bool , default: False ) \u2013 If True, the source waits until it can put an item into the out edge. out_edge_selection ( None or str or callable , default: 'FIRST_AVAILABLE' ) \u2013 Criterion or function for selecting the out edge. Options include \"RANDOM\", \"FIRST\", \"LAST\", \"ROUND_ROBIN\", \"FIRST_AVAILABLE\". None: Used when out edge selection depends on parameters of the node object (like current state of the object) or environment. str: A string that specifies the selection method. \"RANDOM\": Selects a random out edge. \"ROUND_ROBIN\": Selects out edges in a round-robin manner. \"FIRST_AVAILABLE\": Selects the first out edge that can accept an item. callable: A function that returns an edge index. Behavior: The Source node is responsible for generating items that flow in the simulation model. It operates in two modes: blocking and non-blocking. when blocking=True : - After each inter_arrival_time , the source generates an item. - If the selected out edge is full, the source waits until space is available. - Once space is available, the item is transferred to the selected edge. - inter_arrival_time must not be None . when blocking=False : - After each inter_arrival_time , the source generates an item. - If the selected out edge is full, the item is discarded immediately. - If space is available, the item is transferred without waiting. - inter_arrival_time must not be 0. Raises: ValueError \u2013 If inter_arrival_time is 0 in non-blocking mode or if out_edge_selection is not a valid type. ValueError \u2013 If out_edge_selection is not a string or callable. ValueError \u2013 If out_edges is not provided or has less than one edge. ValueError \u2013 If in_edges is provided, as Source nodes should not have input edges. ValueError \u2013 If out_edges already has an edge when trying to add a new one. Output performance metrics: The key performance metrics of the Source node is captured in stats attribute (dict) during a simulation run. last_state_change_time : Time when the state was last changed . num_item_generated : Total number of items generated . num_item_discarded : Total number of items discarded due to lack of space in out edge . total_time_spent_in_states : Dictionary with total time spent in each state . add_out_edges ( edge ) \u00b6 Adds an out_edge to the source node. Raises an error if the source already has an out_edge or if the edge already exists in the out_edges list. Parameters: edge ( Edge Object ) \u2013 The edge to be added as an out_edge. update_state ( new_state , current_time ) \u00b6 Update node state and track the time spent in the previous state. Parameters: i ( int ) \u2013 The index of the worker thread to update the state for. new_state ( str ) \u2013 The new state to transition to. Must be one of \"SETUP_STATE\", \"GENERATING_STATE\", \"BLOCKED_STATE\". current_time ( float ) \u2013 The current simulation time.","title":"Source"},{"location":"source/#factorysimpy.nodes.source.Source","text":"Bases: Node Parameters: state ( str ) \u2013 Current state of the source node. One of : SETUP_STATE: Initial setup phase before item generation starts. GENERATING_STATE: Actively generating and dispatching items. BLOCKED_STATE: Waiting to transfer item when edge is full (in blocking mode). inter_arrival_time ( None, int, float, generator, or callable , default: 0 ) \u2013 Time between item generations. Can be: None: Used when the setup time depends on parameters of the node object (like current state of the object) or environment. int or float: Used as a constant delay. Callable: A function that returns a delay (int or float). Generator: A generator function yielding delay values over time. flow_item_type ( str , default: 'item' ) \u2013 Type of item to be generated. Default is \"item\". Can be \"item\" : Smallest unit of discrete item and it cannot hold other items inside. \"pallet\" : Entities that can store multiple smaller units of items blocking ( bool , default: False ) \u2013 If True, the source waits until it can put an item into the out edge. out_edge_selection ( None or str or callable , default: 'FIRST_AVAILABLE' ) \u2013 Criterion or function for selecting the out edge. Options include \"RANDOM\", \"FIRST\", \"LAST\", \"ROUND_ROBIN\", \"FIRST_AVAILABLE\". None: Used when out edge selection depends on parameters of the node object (like current state of the object) or environment. str: A string that specifies the selection method. \"RANDOM\": Selects a random out edge. \"ROUND_ROBIN\": Selects out edges in a round-robin manner. \"FIRST_AVAILABLE\": Selects the first out edge that can accept an item. callable: A function that returns an edge index. Behavior: The Source node is responsible for generating items that flow in the simulation model. It operates in two modes: blocking and non-blocking. when blocking=True : - After each inter_arrival_time , the source generates an item. - If the selected out edge is full, the source waits until space is available. - Once space is available, the item is transferred to the selected edge. - inter_arrival_time must not be None . when blocking=False : - After each inter_arrival_time , the source generates an item. - If the selected out edge is full, the item is discarded immediately. - If space is available, the item is transferred without waiting. - inter_arrival_time must not be 0. Raises: ValueError \u2013 If inter_arrival_time is 0 in non-blocking mode or if out_edge_selection is not a valid type. ValueError \u2013 If out_edge_selection is not a string or callable. ValueError \u2013 If out_edges is not provided or has less than one edge. ValueError \u2013 If in_edges is provided, as Source nodes should not have input edges. ValueError \u2013 If out_edges already has an edge when trying to add a new one. Output performance metrics: The key performance metrics of the Source node is captured in stats attribute (dict) during a simulation run. last_state_change_time : Time when the state was last changed . num_item_generated : Total number of items generated . num_item_discarded : Total number of items discarded due to lack of space in out edge . total_time_spent_in_states : Dictionary with total time spent in each state .","title":"Source"},{"location":"source/#factorysimpy.nodes.source.Source.add_out_edges","text":"Adds an out_edge to the source node. Raises an error if the source already has an out_edge or if the edge already exists in the out_edges list. Parameters: edge ( Edge Object ) \u2013 The edge to be added as an out_edge.","title":"add_out_edges"},{"location":"source/#factorysimpy.nodes.source.Source.update_state","text":"Update node state and track the time spent in the previous state. Parameters: i ( int ) \u2013 The index of the worker thread to update the state for. new_state ( str ) \u2013 The new state to transition to. Must be one of \"SETUP_STATE\", \"GENERATING_STATE\", \"BLOCKED_STATE\". current_time ( float ) \u2013 The current simulation time.","title":"update_state"},{"location":"splitter/","text":"Splitter ( env , id , in_edges = None , out_edges = None , node_setup_time = 0 , processing_delay = 0 , blocking = True , mode = 'UNPACK' , split_quantity = None , in_edge_selection = 'FIRST_AVAILABLE' , out_edge_selection = 'FIRST_AVAILABLE' ) \u00b6 Bases: Node Splitter class representing a processing node that can unpack an incoming item and send it to multiple outgoing edges in a factory simulation. Parameters: state ( str ) \u2013 Current state of the splitter node. One of : SETUP_STATE: Initial setup phase before splitter starts to operate. IDLE_STATE: Worker threads waiting to receive items. PROCESSING_STATE: Actively processing items. BLOCKED_STATE: When all the worker threads are waiting to push the processed item but the out going edge is full. blocking ( bool , default: True ) \u2013 If True, the node waits until it can put an item into the out edge. If False, it discards the item if the out edge is full and cannot accept the item that is being pushed by the splitter. mode ( str , default: 'UNPACK' ) \u2013 Mode of operation of the splitter. Either \"UNPACK\" or \"SPLIT\". - \"UNPACK\": The splitter unpacks all items from a packed item (like a pallet) and pushes each item to an output edge, one by one. After all items are pushed, the empty container itself is pushed to an output edge. - \"SPLIT\": The splitter splits the incoming item into a target quantity of items, specified by split_quantity and pushes each item to an output edge, one by one. split_quantity ( int , default: None ) \u2013 Target quantity of items to split the input flow item into. This parameter is required if mode is \"SPLIT\". If mode is \"UNPACK\", this parameter is ignored. processing_delay ( (None, int , float , Generator , Callable ) , default: 0 ) \u2013 Delay for processing items. Can be: None: Used when the processing time depends on parameters of the node object (like current state of the object) or environment. int or float: Used as a constant delay. Generator: A generator function yielding delay values over time. Callable: A function that returns a delay (int or float). in_edge_selection ( None or str or callable , default: 'FIRST_AVAILABLE' ) \u2013 Criterion or function for selecting the edge. Options include \"RANDOM\", \"ROUND_ROBIN\", \"FIRST_AVAILABLE\". None: Used when edge selction depends on parameters of the node object (like current state of the object) or environment. str: A string that specifies the selection method. \"RANDOM\": Selects a random edge. \"ROUND_ROBIN\": Selects edges in a round-robin manner. \"FIRST_AVAILABLE\": Selects the first out edge that can give an item. callable: A function that returns an edge index. out_edge_selection ( None or str or callable , default: 'FIRST_AVAILABLE' ) \u2013 Criterion or function for selecting the out edge. Options include \"RANDOM\", \"ROUND_ROBIN\", \"FIRST_AVAILABLE\". None: None: Used when out edge selction depends on parameters of the node object (like current state of the object) or environment. str: A string that specifies the selection method. \"RANDOM\": Selects a random out edge in the out_edges list. \"ROUND_ROBIN\": Selects out edges in a round-robin manner. \"FIRST_AVAILABLE\": Selects the first out edge that can accept an item. callable: A function that returns an edge index. Behavior The Splitter node represents components that process or modify the items that flow in the simulation model. It can have multiple incoming edges and multiple outgoing edge. Edge from which the item comes in and the edge to which processed item is pushed is decided using the method specified in the parameter in_edge_selection and out_edge_selection . Splitter will transition through the states- SETUP_STATE , PROCESSING_STATE , IDLE_STATE and BLOCKED_STATE . The Splitter has a blocking behavior if blocking = True and gets blocked when all its worker threads have processed items and the out edge is full and cannot accept the item that is being pushed by the Splitter and waits until the out edge can accept the item. If blocking = False , the Splitter will discard the item if the out edge is full and cannot accept the item that is being pushed by the Splitter. Raises: AssertionError \u2013 If the Splitter has no input or output edges. Output performance metrics: The key performance metrics of the Splitter node is captured in stats attribute (dict) during a simulation run. last_state_change_time : Time when the state was last changed . num_item_processed : Total number of items generated . num_item_discarded : Total number of items discarded . total_time_spent_in_states : Dictionary with total time spent in each state . update_state ( new_state , current_time ) \u00b6 Update node state and track the time spent in the previous state. Parameters: i ( int ) \u2013 The index of the worker thread to update the state for. new_state ( str ) \u2013 The new state to transition to. Must be one of \"SETUP_STATE\", \"GENERATING_STATE\", \"BLOCKED_STATE\". current_time ( float ) \u2013 The current simulation time. add_in_edges ( edge ) \u00b6 Adds an in_edge to the node. Raises an error if the edge already exists in the in_edges list. Parameters: edge (Edge Object) \u2013 The edge to be added as an in_edge. add_out_edges ( edge ) \u00b6 Adds an out_edge to the node. Raises an error if the edge already exists in the out_edges list. Parameters: edge (Edge Object) \u2013 The edge to be added as an out_edge.","title":"Splitter"},{"location":"splitter/#factorysimpy.nodes.splitter.Splitter","text":"Bases: Node Splitter class representing a processing node that can unpack an incoming item and send it to multiple outgoing edges in a factory simulation. Parameters: state ( str ) \u2013 Current state of the splitter node. One of : SETUP_STATE: Initial setup phase before splitter starts to operate. IDLE_STATE: Worker threads waiting to receive items. PROCESSING_STATE: Actively processing items. BLOCKED_STATE: When all the worker threads are waiting to push the processed item but the out going edge is full. blocking ( bool , default: True ) \u2013 If True, the node waits until it can put an item into the out edge. If False, it discards the item if the out edge is full and cannot accept the item that is being pushed by the splitter. mode ( str , default: 'UNPACK' ) \u2013 Mode of operation of the splitter. Either \"UNPACK\" or \"SPLIT\". - \"UNPACK\": The splitter unpacks all items from a packed item (like a pallet) and pushes each item to an output edge, one by one. After all items are pushed, the empty container itself is pushed to an output edge. - \"SPLIT\": The splitter splits the incoming item into a target quantity of items, specified by split_quantity and pushes each item to an output edge, one by one. split_quantity ( int , default: None ) \u2013 Target quantity of items to split the input flow item into. This parameter is required if mode is \"SPLIT\". If mode is \"UNPACK\", this parameter is ignored. processing_delay ( (None, int , float , Generator , Callable ) , default: 0 ) \u2013 Delay for processing items. Can be: None: Used when the processing time depends on parameters of the node object (like current state of the object) or environment. int or float: Used as a constant delay. Generator: A generator function yielding delay values over time. Callable: A function that returns a delay (int or float). in_edge_selection ( None or str or callable , default: 'FIRST_AVAILABLE' ) \u2013 Criterion or function for selecting the edge. Options include \"RANDOM\", \"ROUND_ROBIN\", \"FIRST_AVAILABLE\". None: Used when edge selction depends on parameters of the node object (like current state of the object) or environment. str: A string that specifies the selection method. \"RANDOM\": Selects a random edge. \"ROUND_ROBIN\": Selects edges in a round-robin manner. \"FIRST_AVAILABLE\": Selects the first out edge that can give an item. callable: A function that returns an edge index. out_edge_selection ( None or str or callable , default: 'FIRST_AVAILABLE' ) \u2013 Criterion or function for selecting the out edge. Options include \"RANDOM\", \"ROUND_ROBIN\", \"FIRST_AVAILABLE\". None: None: Used when out edge selction depends on parameters of the node object (like current state of the object) or environment. str: A string that specifies the selection method. \"RANDOM\": Selects a random out edge in the out_edges list. \"ROUND_ROBIN\": Selects out edges in a round-robin manner. \"FIRST_AVAILABLE\": Selects the first out edge that can accept an item. callable: A function that returns an edge index. Behavior The Splitter node represents components that process or modify the items that flow in the simulation model. It can have multiple incoming edges and multiple outgoing edge. Edge from which the item comes in and the edge to which processed item is pushed is decided using the method specified in the parameter in_edge_selection and out_edge_selection . Splitter will transition through the states- SETUP_STATE , PROCESSING_STATE , IDLE_STATE and BLOCKED_STATE . The Splitter has a blocking behavior if blocking = True and gets blocked when all its worker threads have processed items and the out edge is full and cannot accept the item that is being pushed by the Splitter and waits until the out edge can accept the item. If blocking = False , the Splitter will discard the item if the out edge is full and cannot accept the item that is being pushed by the Splitter. Raises: AssertionError \u2013 If the Splitter has no input or output edges. Output performance metrics: The key performance metrics of the Splitter node is captured in stats attribute (dict) during a simulation run. last_state_change_time : Time when the state was last changed . num_item_processed : Total number of items generated . num_item_discarded : Total number of items discarded . total_time_spent_in_states : Dictionary with total time spent in each state .","title":"Splitter"},{"location":"splitter/#factorysimpy.nodes.splitter.Splitter.update_state","text":"Update node state and track the time spent in the previous state. Parameters: i ( int ) \u2013 The index of the worker thread to update the state for. new_state ( str ) \u2013 The new state to transition to. Must be one of \"SETUP_STATE\", \"GENERATING_STATE\", \"BLOCKED_STATE\". current_time ( float ) \u2013 The current simulation time.","title":"update_state"},{"location":"splitter/#factorysimpy.nodes.splitter.Splitter.add_in_edges","text":"Adds an in_edge to the node. Raises an error if the edge already exists in the in_edges list. Parameters: edge (Edge Object) \u2013 The edge to be added as an in_edge.","title":"add_in_edges"},{"location":"splitter/#factorysimpy.nodes.splitter.Splitter.add_out_edges","text":"Adds an out_edge to the node. Raises an error if the edge already exists in the out_edges list. Parameters: edge (Edge Object) \u2013 The edge to be added as an out_edge.","title":"add_out_edges"}]}